From aa2ec981b84e1b8146f67fed3604bfebcdb84e01 Mon Sep 17 00:00:00 2001
From: Keith Lee <keith.lee@gumstix.com>
Date: Thu, 14 May 2020 11:48:03 -0700
Subject: [PATCH] Add support for OV5640 OV5670 IMX214

---
 nvidia/drivers/media/i2c/Kconfig              |   29 +
 nvidia/drivers/media/i2c/Makefile             |    3 +
 nvidia/drivers/media/i2c/imx214.c             | 1451 ++++----
 nvidia/drivers/media/i2c/imx214_mode_tbls.h   | 2956 +++++++++++++++++
 nvidia/drivers/media/i2c/ov5640.c             | 1266 +++++++
 nvidia/drivers/media/i2c/ov5640_mode_tbls.h   |  377 +++
 nvidia/drivers/media/i2c/ov5670.c             | 1268 +++++++
 nvidia/drivers/media/i2c/ov5670_mode_tbls.h   | 2955 ++++++++++++++++
 .../platform/tegra/camera/camera_common.c     |    5 +
 .../platform/tegra/camera/sensor_common.c     |    2 +
 nvidia/include/media/imx214.h                 |   91 +
 nvidia/include/media/ov5640.h                 |   87 +
 nvidia/include/media/ov56400.h                |   87 +
 nvidia/include/media/ov5670.h                 |   90 +
 nvidia/include/trace/events/imx214.h          |   45 +
 nvidia/include/trace/events/ov5640.h          |   45 +
 nvidia/include/trace/events/ov5670.h          |   45 +
 nvidia/include/uapi/media/imx214.h            |  108 +
 nvidia/include/uapi/media/ov5640.h            |  113 +
 nvidia/include/uapi/media/ov5670.h            |  113 +
 20 files changed, 10398 insertions(+), 738 deletions(-)
 create mode 100755 nvidia/drivers/media/i2c/imx214_mode_tbls.h
 create mode 100644 nvidia/drivers/media/i2c/ov5640.c
 create mode 100755 nvidia/drivers/media/i2c/ov5640_mode_tbls.h
 create mode 100644 nvidia/drivers/media/i2c/ov5670.c
 create mode 100755 nvidia/drivers/media/i2c/ov5670_mode_tbls.h
 create mode 100644 nvidia/include/media/imx214.h
 create mode 100644 nvidia/include/media/ov5640.h
 create mode 100644 nvidia/include/media/ov56400.h
 create mode 100644 nvidia/include/media/ov5670.h
 create mode 100644 nvidia/include/trace/events/imx214.h
 create mode 100644 nvidia/include/trace/events/ov5640.h
 create mode 100644 nvidia/include/trace/events/ov5670.h
 create mode 100644 nvidia/include/uapi/media/imx214.h
 create mode 100644 nvidia/include/uapi/media/ov5640.h
 create mode 100644 nvidia/include/uapi/media/ov5670.h

diff --git a/nvidia/drivers/media/i2c/Kconfig b/nvidia/drivers/media/i2c/Kconfig
index abfb5f596ed6..fc8b998df46d 100644
--- a/nvidia/drivers/media/i2c/Kconfig
+++ b/nvidia/drivers/media/i2c/Kconfig
@@ -13,6 +13,15 @@ config VIDEO_IMX185
 	To compile this driver as a module, choose M here: the module
 	will be called imx185.
 
+    config VIDEO_IMX214
+        tristate "IMX214 camera sensor support"
+    depends on I2C && VIDEO_V4L2 && VIDEO_V4L2_SUBDEV_API
+    ---help---
+      This driver supports IMX214 camera sensor from Sony
+
+      To compile this driver as a module, choose M here: the module
+      will be called imx214.
+
 config VIDEO_IMX219
         tristate "IMX219 camera sensor support"
 	depends on I2C && VIDEO_V4L2 && VIDEO_V4L2_SUBDEV_API
@@ -71,6 +80,26 @@ config VIDEO_OV5693
 	  To compile this driver as a module, choose M here: the module
 	  will be called ov5693.
 
+config VIDEO_OV5640
+	tristate "OV5640 camera sensor support"
+	depends on I2C && VIDEO_V4L2 && VIDEO_V4L2_SUBDEV_API
+	---help---
+	  This is a Video4Linux2 sensor-level driver for the OmniVision
+	  OV5640 camera.
+
+	  To compile this driver as a module, choose M here: the module
+	  will be called ov5640.
+
+config VIDEO_OV5670
+      	tristate "OV5670 camera sensor support"
+      	depends on I2C && VIDEO_V4L2 && VIDEO_V4L2_SUBDEV_API
+      	---help---
+      	  This is a Video4Linux2 sensor-level driver for the OmniVision
+      	  OV5670 camera.
+
+      	  To compile this driver as a module, choose M here: the module
+      	  will be called ov5670.
+
 config VIDEO_OV9281
 	tristate "OmniVision OV9281 camera sensor support"
 	depends on I2C && VIDEO_V4L2 && VIDEO_V4L2_SUBDEV_API
diff --git a/nvidia/drivers/media/i2c/Makefile b/nvidia/drivers/media/i2c/Makefile
index 3e808e1cefc4..a2fea940c157 100644
--- a/nvidia/drivers/media/i2c/Makefile
+++ b/nvidia/drivers/media/i2c/Makefile
@@ -5,12 +5,15 @@ ccflags-y += -I$(srctree)/drivers/video/tegra/camera
 
 obj-$(CONFIG_VIDEO_IMX185) += imx185.o
 obj-$(CONFIG_VIDEO_IMX185) += imx185_v1.o
+obj-$(CONFIG_VIDEO_IMX214) += imx214.o
 obj-$(CONFIG_VIDEO_IMX219) += imx219.o
 obj-$(CONFIG_VIDEO_IMX268) += imx268.o
 obj-$(CONFIG_VIDEO_IMX274) += imx274.o
 obj-$(CONFIG_VIDEO_IMX318) += imx318.o
 obj-$(CONFIG_VIDEO_LC898212) += lc898212.o
 obj-$(CONFIG_VIDEO_OV5693) += ov5693.o
+obj-$(CONFIG_VIDEO_OV5670) += ov5670.o
+obj-$(CONFIG_VIDEO_OV5640) += ov5640.o
 obj-$(CONFIG_VIDEO_OV9281) += ov9281.o
 obj-$(CONFIG_VIDEO_OV10823) += ov10823.o
 obj-$(CONFIG_VIDEO_OV23850) += ov23850.o
diff --git a/nvidia/drivers/media/i2c/imx214.c b/nvidia/drivers/media/i2c/imx214.c
index 20cf20a3ee2f..9ffa594482d5 100644
--- a/nvidia/drivers/media/i2c/imx214.c
+++ b/nvidia/drivers/media/i2c/imx214.c
@@ -1,7 +1,7 @@
 /*
- * imx214.c - imx214 sensor driver
+ * imx214_v4l2.c - imx214 sensor driver
  *
- * Copyright (c) 2013-2017, NVIDIA CORPORATION.  All rights reserved.
+ * Copyright (c) 2013-2019, NVIDIA CORPORATION.  All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms and conditions of the GNU General Public License,
@@ -20,6 +20,7 @@
 #include <linux/uaccess.h>
 #include <linux/gpio.h>
 #include <linux/module.h>
+#include <linux/debugfs.h>
 
 #include <linux/seq_file.h>
 #include <linux/of.h>
@@ -27,168 +28,65 @@
 #include <linux/of_gpio.h>
 
 #include <media/tegra-v4l2-camera.h>
-#include <media/camera_common.h>
+#include <media/tegracam_core.h>
 #include <media/imx214.h>
 
-#include "imx214_mode_tbls.h"
 
-#define IMX214_MAX_COARSE_DIFF		10
+#include "../platform/tegra/camera/camera_gpio.h"
+#include "imx214_mode_tbls.h"
+#define CREATE_TRACE_POINTS
+#include <trace/events/imx214.h>
 
-#define IMX214_GAIN_SHIFT		8
-#define IMX214_MIN_GAIN		(1 << IMX214_GAIN_SHIFT)
-#define IMX214_MAX_GAIN		(16 << IMX214_GAIN_SHIFT)
-#define IMX214_MIN_FRAME_LENGTH	(0x0)
-#define IMX214_MAX_FRAME_LENGTH	(0xffff)
-#define IMX214_MIN_EXPOSURE_COARSE	(0x0001)
+#define IMX214_MAX_COARSE_DIFF		6
+#define IMX214_MAX_FRAME_LENGTH	(0x7fff)
+#define IMX214_MIN_EXPOSURE_COARSE	(0x0002)
 #define IMX214_MAX_EXPOSURE_COARSE	\
 	(IMX214_MAX_FRAME_LENGTH-IMX214_MAX_COARSE_DIFF)
-
-#define IMX214_DEFAULT_GAIN		IMX214_MIN_GAIN
-#define IMX214_DEFAULT_FRAME_LENGTH	(0x0C7A)
+#define IMX214_DEFAULT_LINE_LENGTH	(0x10CC)
+#define IMX214_DEFAULT_PIXEL_CLOCK	(480)
+#define IMX214_DEFAULT_FRAME_LENGTH	(0x07C0)
 #define IMX214_DEFAULT_EXPOSURE_COARSE	\
 	(IMX214_DEFAULT_FRAME_LENGTH-IMX214_MAX_COARSE_DIFF)
 
-#define IMX214_DEFAULT_MODE	IMX214_MODE_4096X3072
-#define IMX214_DEFAULT_HDR_MODE	IMX214_MODE_4096X3072_HDR
-#define IMX214_DEFAULT_WIDTH	4096
-#define IMX214_DEFAULT_HEIGHT	3072
-#define IMX214_DEFAULT_DATAFMT	V4L2_MBUS_FMT_SRGGB10_1X10
-#define IMX214_DEFAULT_CLK_FREQ	24000000
+static const u32 ctrl_cid_list[] = {
+	TEGRA_CAMERA_CID_GAIN,
+	TEGRA_CAMERA_CID_EXPOSURE,
+	TEGRA_CAMERA_CID_EXPOSURE_SHORT,
+	TEGRA_CAMERA_CID_FRAME_RATE,
+	TEGRA_CAMERA_CID_GROUP_HOLD,
+	TEGRA_CAMERA_CID_HDR_EN,
+	TEGRA_CAMERA_CID_EEPROM_DATA,
+	TEGRA_CAMERA_CID_OTP_DATA,
+	TEGRA_CAMERA_CID_FUSE_ID,
+};
 
 struct imx214 {
-	struct camera_common_power_rail	power;
-	int				numctrls;
-	struct v4l2_ctrl_handler	ctrl_handler;
 	struct camera_common_eeprom_data eeprom[IMX214_EEPROM_NUM_BLOCKS];
 	u8				eeprom_buf[IMX214_EEPROM_SIZE];
+	u8				otp_buf[IMX214_OTP_SIZE];
 	struct i2c_client		*i2c_client;
 	struct v4l2_subdev		*subdev;
-	struct media_pad		pad;
+	u8				fuse_id[IMX214_FUSE_ID_SIZE];
+	const char			*devname;
+	struct dentry			*debugfs_dir;
+	struct mutex			streaming_lock;
+	bool				streaming;
 
 	s32				group_hold_prev;
+	u32				frame_length;
 	bool				group_hold_en;
-	struct regmap			*regmap;
+	struct camera_common_i2c	i2c_dev;
 	struct camera_common_data	*s_data;
-	struct camera_common_pdata	*pdata;
-	struct v4l2_ctrl		*ctrls[];
+	struct tegracam_device		*tc_dev;
 };
 
-static const struct regmap_config sensor_regmap_config = {
+static struct regmap_config imx214_regmap_config = {
 	.reg_bits = 16,
 	.val_bits = 8,
-	.cache_type = REGCACHE_RBTREE,
-};
-
-static int imx214_g_volatile_ctrl(struct v4l2_ctrl *ctrl);
-static int imx214_s_ctrl(struct v4l2_ctrl *ctrl);
-
-static const struct v4l2_ctrl_ops imx214_ctrl_ops = {
-	.g_volatile_ctrl = imx214_g_volatile_ctrl,
-	.s_ctrl		= imx214_s_ctrl,
-};
-
-static struct v4l2_ctrl_config ctrl_config_list[] = {
-/* Do not change the name field for the controls! */
-	{
-		.ops = &imx214_ctrl_ops,
-		.id = TEGRA_CAMERA_CID_GAIN,
-		.name = "Gain",
-		.type = V4L2_CTRL_TYPE_INTEGER,
-		.flags = V4L2_CTRL_FLAG_SLIDER,
-		.min = IMX214_MIN_GAIN,
-		.max = IMX214_MAX_GAIN,
-		.def = IMX214_DEFAULT_GAIN,
-		.step = 1,
-	},
-	{
-		.ops = &imx214_ctrl_ops,
-		.id = TEGRA_CAMERA_CID_FRAME_LENGTH,
-		.name = "Frame Length",
-		.type = V4L2_CTRL_TYPE_INTEGER,
-		.flags = V4L2_CTRL_FLAG_SLIDER,
-		.min = IMX214_MIN_FRAME_LENGTH,
-		.max = IMX214_MAX_FRAME_LENGTH,
-		.def = IMX214_DEFAULT_FRAME_LENGTH,
-		.step = 1,
-	},
-	{
-		.ops = &imx214_ctrl_ops,
-		.id = TEGRA_CAMERA_CID_COARSE_TIME,
-		.name = "Coarse Time",
-		.type = V4L2_CTRL_TYPE_INTEGER,
-		.flags = V4L2_CTRL_FLAG_SLIDER,
-		.min = IMX214_MIN_EXPOSURE_COARSE,
-		.max = IMX214_MAX_EXPOSURE_COARSE,
-		.def = IMX214_DEFAULT_EXPOSURE_COARSE,
-		.step = 1,
-	},
-	{
-		.ops = &imx214_ctrl_ops,
-		.id = TEGRA_CAMERA_CID_COARSE_TIME_SHORT,
-		.name = "Coarse Time Short",
-		.type = V4L2_CTRL_TYPE_INTEGER,
-		.flags = V4L2_CTRL_FLAG_SLIDER,
-		.min = IMX214_MIN_EXPOSURE_COARSE,
-		.max = IMX214_MAX_EXPOSURE_COARSE,
-		.def = IMX214_DEFAULT_EXPOSURE_COARSE,
-		.step = 1,
-	},
-	{
-		.ops = &imx214_ctrl_ops,
-		.id = TEGRA_CAMERA_CID_GROUP_HOLD,
-		.name = "Group Hold",
-		.type = V4L2_CTRL_TYPE_INTEGER_MENU,
-		.min = 0,
-		.max = ARRAY_SIZE(switch_ctrl_qmenu) - 1,
-		.menu_skip_mask = 0,
-		.def = 0,
-		.qmenu_int = switch_ctrl_qmenu,
-	},
-	{
-		.ops = &imx214_ctrl_ops,
-		.id = TEGRA_CAMERA_CID_HDR_EN,
-		.name = "HDR enable",
-		.type = V4L2_CTRL_TYPE_INTEGER_MENU,
-		.min = 0,
-		.max = ARRAY_SIZE(switch_ctrl_qmenu) - 1,
-		.menu_skip_mask = 0,
-		.def = 0,
-		.qmenu_int = switch_ctrl_qmenu,
-	},
-	{
-		.ops = &imx214_ctrl_ops,
-		.id = TEGRA_CAMERA_CID_EEPROM_DATA,
-		.name = "EEPROM Data",
-		.type = V4L2_CTRL_TYPE_STRING,
-		.flags = V4L2_CTRL_FLAG_VOLATILE,
-		.min = 0,
-		.max = IMX214_EEPROM_STR_SIZE,
-		.step = 2,
-	},
-	{
-		.ops = &imx214_ctrl_ops,
-		.id = TEGRA_CAMERA_CID_OTP_DATA,
-		.name = "OTP Data",
-		.type = V4L2_CTRL_TYPE_STRING,
-		.flags = V4L2_CTRL_FLAG_READ_ONLY,
-		.min = 0,
-		.max = IMX214_OTP_STR_SIZE,
-		.step = 2,
-	},
-	{
-		.ops = &imx214_ctrl_ops,
-		.id = TEGRA_CAMERA_CID_FUSE_ID,
-		.name = "Fuse ID",
-		.type = V4L2_CTRL_TYPE_STRING,
-		.flags = V4L2_CTRL_FLAG_READ_ONLY,
-		.min = 0,
-		.max = IMX214_FUSE_ID_STR_SIZE,
-		.step = 2,
-	},
 };
 
 static inline void imx214_get_frame_length_regs(imx214_reg *regs,
-				u16 frame_length)
+				u32 frame_length)
 {
 	regs->addr = IMX214_FRAME_LENGTH_ADDR_MSB;
 	regs->val = (frame_length >> 8) & 0xff;
@@ -197,20 +95,20 @@ static inline void imx214_get_frame_length_regs(imx214_reg *regs,
 }
 
 static inline void imx214_get_coarse_time_regs(imx214_reg *regs,
-				u16 coarse_time)
+				u32 coarse_time)
 {
-	regs->addr = IMX214_COARSE_TIME_ADDR_MSB;
+	regs->addr = IMX214_COARSE_TIME_ADDR_1;
 	regs->val = (coarse_time >> 8) & 0xff;
-	(regs + 1)->addr = IMX214_COARSE_TIME_ADDR_LSB;
+	(regs + 1)->addr = IMX214_COARSE_TIME_ADDR_2;
 	(regs + 1)->val = (coarse_time) & 0xff;
 }
 
 static inline void imx214_get_coarse_time_short_regs(imx214_reg *regs,
-				u16 coarse_time)
+				u32 coarse_time)
 {
-	regs->addr = IMX214_COARSE_TIME_SHORT_ADDR_MSB;
+	regs->addr = IMX214_COARSE_TIME_SHORT_ADDR_1;
 	regs->val = (coarse_time >> 8) & 0xff;
-	(regs + 1)->addr = IMX214_COARSE_TIME_SHORT_ADDR_LSB;
+	(regs + 1)->addr = IMX214_COARSE_TIME_SHORT_ADDR_2;
 	(regs + 1)->val = (coarse_time) & 0xff;
 }
 
@@ -219,16 +117,8 @@ static inline void imx214_get_gain_regs(imx214_reg *regs,
 {
 	regs->addr = IMX214_GAIN_ADDR_MSB;
 	regs->val = (gain >> 8) & 0xff;
-	(regs + 1)->addr = IMX214_GAIN_ADDR_LSB;
-	(regs + 1)->val = (gain) & 0xff;
-}
 
-static inline void imx214_get_gain_short_reg(imx214_reg *regs,
-				u16 gain)
-{
-	regs->addr = IMX214_GAIN_SHORT_ADDR_MSB;
-	regs->val = (gain >> 8) & 0xff;
-	(regs + 1)->addr = IMX214_GAIN_SHORT_ADDR_LSB;
+	(regs + 1)->addr = IMX214_GAIN_ADDR_LSB;
 	(regs + 1)->val = (gain) & 0xff;
 }
 
@@ -238,92 +128,114 @@ module_param(test_mode, int, 0644);
 static inline int imx214_read_reg(struct camera_common_data *s_data,
 				u16 addr, u8 *val)
 {
-	struct imx214 *priv = (struct imx214 *)s_data->priv;
+	int err = 0;
+	u32 reg_val = 0;
+
+	err = regmap_read(s_data->regmap, addr, &reg_val);
+	*val = reg_val & 0xFF;
 
-	return regmap_read(priv->regmap, addr, (unsigned int *) val);
+	return err;
 }
 
 static int imx214_write_reg(struct camera_common_data *s_data, u16 addr, u8 val)
 {
 	int err;
-	struct imx214 *priv = (struct imx214 *)s_data->priv;
-	struct device *dev = &priv->i2c_client->dev;
+	struct device *dev = s_data->dev;
+
+	err = regmap_write(s_data->regmap, addr, val);
 
-	err = regmap_write(priv->regmap, addr, val);
 	if (err)
-		dev_err(dev, "%s: i2c write failed, %x = %x\n",
+		dev_err(dev, "%s: i2c write failed, 0x%x = %x\n",
 			__func__, addr, val);
 
 	return err;
 }
 
 static int imx214_write_table(struct imx214 *priv,
-				const imx214_reg table[])
+			      const imx214_reg table[])
 {
-	return regmap_util_write_table_8(priv->regmap,
+	struct camera_common_data *s_data = priv->s_data;
+
+	return regmap_util_write_table_8(s_data->regmap,
 					 table,
 					 NULL, 0,
 					 IMX214_TABLE_WAIT_MS,
 					 IMX214_TABLE_END);
 }
 
+static void imx214_gpio_set(struct camera_common_data *s_data,
+			    unsigned int gpio, int val)
+{
+	struct camera_common_pdata *pdata = s_data->pdata;
+
+	if (pdata && pdata->use_cam_gpio)
+		cam_gpio_ctrl(s_data->dev, gpio, val, 1);
+	else {
+		if (gpio_cansleep(gpio))
+			gpio_set_value_cansleep(gpio, val);
+		else
+			gpio_set_value(gpio, val);
+	}
+}
+
 static int imx214_power_on(struct camera_common_data *s_data)
 {
-	struct device *dev = &priv->i2c_client->dev;
 	int err = 0;
-	struct imx214 *priv = (struct imx214 *)s_data->priv;
-	struct camera_common_power_rail *pw = &priv->power;
+	struct camera_common_power_rail *pw = s_data->power;
+	struct camera_common_pdata *pdata = s_data->pdata;
+	struct device *dev = s_data->dev;
+	u32 frame_time;
 
 	dev_dbg(dev, "%s: power on\n", __func__);
 
-	if (priv->pdata && priv->pdata->power_on) {
-		err = priv->pdata->power_on(pw);
+	if (pdata && pdata->power_on) {
+		err = pdata->power_on(pw);
 		if (err)
 			dev_err(dev, "%s failed.\n", __func__);
 		else
 			pw->state = SWITCH_ON;
 		return err;
 	}
-
-	/* sleep calls in the sequence below are for internal device
-	 * signal propagation as specified by sensor vendor */
-
-	if (pw->reset_gpio)
-		gpio_set_value(pw->reset_gpio, 0);
-	if (pw->af_gpio)
-		gpio_set_value(pw->af_gpio, 1);
-	if (pw->pwdn_gpio)
-		gpio_set_value(pw->pwdn_gpio, 0);
-	usleep_range(10, 20);
+	/* sleeps calls in the sequence below are for internal device
+	 * signal propagation as specified by sensor vendor
+	 */
 
 	if (pw->avdd)
 		err = regulator_enable(pw->avdd);
 	if (err)
 		goto imx214_avdd_fail;
 
-	if (pw->iovdd)
-		err = regulator_enable(pw->iovdd);
+	if (pw->dvdd)
+		err = regulator_enable(pw->dvdd);
 	if (err)
-		goto imx214_iovdd_fail;
+		goto imx214_dvdd_fail;
 
-	udelay(1);
-	if (pw->reset_gpio)
-		gpio_set_value(pw->reset_gpio, 1);
-	if (pw->pwdn_gpio)
-		gpio_set_value(pw->pwdn_gpio, 1);
+/*
+ * datasheet 2.9: reset requires ~2ms settling time
+ * a power on reset is generated after core power becomes stable
+ */
+	usleep_range(2000, 2010);
 
-	usleep_range(300, 310);
+	if (gpio_is_valid(pw->reset_gpio))
+		imx214_gpio_set(s_data, pw->reset_gpio, 1);
+
+    if (gpio_is_valid(pw->pwdn_gpio))
+		imx214_gpio_set(s_data, pw->pwdn_gpio, 1);
+	/* datasheet fig 2-9: t3 */
+	usleep_range(2000, 2010);
 
 	pw->state = SWITCH_ON;
+
+	frame_time = IMX214_DEFAULT_FRAME_LENGTH *
+			IMX214_DEFAULT_LINE_LENGTH / IMX214_DEFAULT_PIXEL_CLOCK;
+	usleep_range(300, 310);
+
 	return 0;
 
-imx214_iovdd_fail:
+imx214_dvdd_fail:
 	regulator_disable(pw->avdd);
 
 imx214_avdd_fail:
-	if (pw->af_gpio)
-		gpio_set_value(pw->af_gpio, 0);
-
 	dev_err(dev, "%s failed.\n", __func__);
 	return -ENODEV;
 }
@@ -331,36 +243,40 @@ static int imx214_power_on(struct camera_common_data *s_data)
 static int imx214_power_off(struct camera_common_data *s_data)
 {
 	int err = 0;
-	struct imx214 *priv = (struct imx214 *)s_data->priv;
-	struct camera_common_power_rail *pw = &priv->power;
-	struct device *dev = &priv->i2c_client->dev;
+	struct camera_common_power_rail *pw = s_data->power;
+	struct device *dev = s_data->dev;
+	struct camera_common_pdata *pdata = s_data->pdata;
 
 	dev_dbg(dev, "%s: power off\n", __func__);
 
-	if (priv->pdata && priv->pdata->power_on) {
-		err = priv->pdata->power_off(pw);
-		if (err) {
+	if (pdata && pdata->power_off) {
+		err = pdata->power_off(pw);
+		if (!err) {
+			goto power_off_done;
+		} else {
 			dev_err(dev, "%s failed.\n", __func__);
 			return err;
-		} else {
-			goto power_off_done;
 		}
 	}
 
 	/* sleeps calls in the sequence below are for internal device
-	 * signal propagation as specified by sensor vendor */
+	 * signal propagation as specified by sensor vendor
+	 */
+	usleep_range(21, 25);
+	if (gpio_is_valid(pw->reset_gpio))
+		imx214_gpio_set(s_data, pw->reset_gpio, 0);
+        
+    usleep_range(1000, 2000);
+
+    if (gpio_is_valid(pw->pwdn_gpio))
+        imx214_gpio_set(s_data, pw->pwdn_gpio, 0);
+
+    /* datasheet 2.9: reset requires ~2ms settling time*/
+	usleep_range(2000, 2010);
+
+	if (pw->dvdd)
+		regulator_disable(pw->dvdd);
 
-	usleep_range(1, 2);
-	if (pw->reset_gpio)
-		gpio_set_value(pw->reset_gpio, 0);
-	if (pw->af_gpio)
-		gpio_set_value(pw->af_gpio, 0);
-	if (pw->pwdn_gpio)
-		gpio_set_value(pw->pwdn_gpio, 0);
-	usleep_range(1, 2);
-
-	if (pw->iovdd)
-		regulator_disable(pw->iovdd);
 	if (pw->avdd)
 		regulator_disable(pw->avdd);
 
@@ -369,170 +285,145 @@ static int imx214_power_off(struct camera_common_data *s_data)
 	return 0;
 }
 
-static int imx214_power_get(struct imx214 *priv)
+static int imx214_power_put(struct tegracam_device *tc_dev)
 {
-	struct camera_common_power_rail *pw = &priv->power;
-	struct camera_common_pdata *pdata = priv->pdata;
-	struct device *dev = &priv->i2c_client->dev;
+	struct camera_common_data *s_data = tc_dev->s_data;
+	struct camera_common_power_rail *pw = s_data->power;
+	struct camera_common_pdata *pdata = s_data->pdata;
+	struct device *dev = tc_dev->dev;
+
+	if (unlikely(!pw))
+		return -EFAULT;
+
+	if (pdata && pdata->use_cam_gpio)
+		cam_gpio_deregister(dev, pw->pwdn_gpio);
+	else {
+		if (gpio_is_valid(pw->pwdn_gpio))
+			gpio_free(pw->pwdn_gpio);
+		if (gpio_is_valid(pw->reset_gpio))
+			gpio_free(pw->reset_gpio);
+	}
+
+	return 0;
+}
+
+static int imx214_power_get(struct tegracam_device *tc_dev)
+{
+	struct camera_common_data *s_data = tc_dev->s_data;
+	struct camera_common_power_rail *pw = s_data->power;
+	struct camera_common_pdata *pdata = s_data->pdata;
+	struct device *dev = tc_dev->dev;
 	const char *mclk_name;
-	int err = 0;
+	const char *parentclk_name;
+	struct clk *parent;
+	int err = 0, ret = 0;
 
-	mclk_name = priv->pdata->mclk_name ?
-		    priv->pdata->mclk_name : "cam_mclk1";
+	if (!pdata) {
+		dev_err(dev, "pdata missing\n");
+		return -EFAULT;
+	}
+
+	mclk_name = pdata->mclk_name ?
+		    pdata->mclk_name : "cam_mclk1";
 	pw->mclk = devm_clk_get(dev, mclk_name);
 	if (IS_ERR(pw->mclk)) {
 		dev_err(dev, "unable to get clock %s\n", mclk_name);
 		return PTR_ERR(pw->mclk);
 	}
+	parentclk_name = pdata->parentclk_name;
+	if (parentclk_name) {
+		parent = devm_clk_get(dev, parentclk_name);
+		if (IS_ERR(parent)) {
+			dev_err(dev, "unable to get parent clcok %s",
+				parentclk_name);
+		} else
+			clk_set_parent(pw->mclk, parent);
+	}
 
-	/* analog 2.7v */
-	err |= camera_common_regulator_get(priv->i2c_client,
+	/* analog 2.8v */
+	err |= camera_common_regulator_get(dev,
 			&pw->avdd, pdata->regulators.avdd);
-	/* digital 1.2v */
-	err |= camera_common_regulator_get(priv->i2c_client,
+	/* DVDD 1.5v */
+	err |= camera_common_regulator_get(dev,
 			&pw->dvdd, pdata->regulators.dvdd);
-	/* IO 1.8v */
-	err |= camera_common_regulator_get(priv->i2c_client,
-			&pw->iovdd, pdata->regulators.iovdd);
 
 	if (!err) {
 		pw->reset_gpio = pdata->reset_gpio;
-		pw->af_gpio = pdata->af_gpio;
 		pw->pwdn_gpio = pdata->pwdn_gpio;
 	}
-
-	pw->state = SWITCH_OFF;
-	return err;
-}
-
-static int imx214_set_gain(struct imx214 *priv, s32 val);
-static int imx214_set_frame_length(struct imx214 *priv, s32 val);
-static int imx214_set_coarse_time(struct imx214 *priv, s32 val);
-static int imx214_set_coarse_time_short(struct imx214 *priv, s32 val);
-
-static int imx214_s_stream(struct v4l2_subdev *sd, int enable)
-{
-	struct i2c_client *client = v4l2_get_subdevdata(sd);
-	struct camera_common_data *s_data = to_camera_common_data(client);
-	struct imx214 *priv = (struct imx214 *)s_data->priv;
-	struct v4l2_control control;
-	int err;
-
-	dev_dbg(&client->dev, "%s++ enable %d\n", __func__, enable);
-	if (!enable)
-		return imx214_write_table(priv,
-			mode_table[IMX214_MODE_STOP_STREAM]);
-
-	err = imx214_write_table(priv, mode_table[IMX214_MODE_COMMON]);
-	if (err)
-		goto exit;
-	err = imx214_write_table(priv, mode_table[s_data->mode]);
-	if (err)
-		goto exit;
-
-	if (s_data->override_enable) {
-		/* write list of override regs for the asking frame length, */
-		/*
-		 * coarse integration time, and gain. Failures to write
-		 * overrides are non-fatal
-		 */
-		control.id = TEGRA_CAMERA_CID_GAIN;
-		err = v4l2_g_ctrl(&priv->ctrl_handler, &control);
-		err |= imx214_set_gain(priv, control.value);
-		if (err)
-			dev_dbg(&client->dev, "%s: warning gain override failed\n",
-				__func__);
-
-		control.id = TEGRA_CAMERA_CID_FRAME_LENGTH;
-		err = v4l2_g_ctrl(&priv->ctrl_handler, &control);
-		err |= imx214_set_frame_length(priv, control.value);
-		if (err)
-			dev_dbg(&client->dev,
-				"%s: frame length override failed\n", __func__);
-
-		control.id = TEGRA_CAMERA_CID_COARSE_TIME;
-		err = v4l2_g_ctrl(&priv->ctrl_handler, &control);
-		err |= imx214_set_coarse_time(priv, control.value);
+	if (pdata->use_cam_gpio) {
+		err = cam_gpio_register(dev, pw->pwdn_gpio);
 		if (err)
-			dev_dbg(&client->dev,
-				"%s: coarse time override failed\n", __func__);
-
-		control.id = TEGRA_CAMERA_CID_COARSE_TIME_SHORT;
-		err = v4l2_g_ctrl(&priv->ctrl_handler, &control);
-		err |= imx214_set_coarse_time_short(priv, control.value);
-		if (err)
-			dev_dbg(&client->dev,
-				"%s: warning coarse time short override failed\n",
-				__func__);
+			dev_err(dev, "%s ERR can't register cam gpio %u!\n",
+				 __func__, pw->pwdn_gpio);
+	} else {
+		if (gpio_is_valid(pw->pwdn_gpio)) {
+			ret = gpio_request(pw->pwdn_gpio, "cam_pwdn_gpio");
+			if (ret < 0) {
+				dev_dbg(dev, "%s can't request pwdn_gpio %d\n",
+					__func__, ret);
+			}
+			gpio_direction_output(pw->pwdn_gpio, 1);
+		}
+		if (gpio_is_valid(pw->reset_gpio)) {
+			ret = gpio_request(pw->reset_gpio, "cam_reset_gpio");
+			if (ret < 0)
+				dev_dbg(dev, "%s can't request reset_gpio %d\n",
+					__func__, ret);
+			gpio_direction_output(pw->reset_gpio, 1);
+        }
 	}
-
-	err = imx214_write_table(priv, mode_table[IMX214_MODE_START_STREAM]);
-	if (err)
-		goto exit;
-
-	if (test_mode)
-		err = imx214_write_table(priv,
-			mode_table[IMX214_MODE_TEST_PATTERN]);
-
-	return 0;
-exit:
-	dev_dbg(&client->dev, "%s: error setting stream\n", __func__);
+    pw->state = SWITCH_OFF;
 	return err;
 }
 
-static struct v4l2_subdev_video_ops imx214_subdev_video_ops = {
-	.s_stream	= imx214_s_stream,
-	.s_mbus_fmt	= camera_common_s_fmt,
-	.g_mbus_fmt	= camera_common_g_fmt,
-	.try_mbus_fmt	= camera_common_try_fmt,
-	.enum_mbus_fmt	= camera_common_enum_fmt,
-	.g_mbus_config	= camera_common_g_mbus_config,
-};
-
-static struct v4l2_subdev_core_ops imx214_subdev_core_ops = {
-	.s_power	= camera_common_s_power,
-};
-
-static struct v4l2_subdev_pad_ops imx214_subdev_pad_ops = {
-	.enum_mbus_code = camera_common_enum_mbus_code,
-};
-
-static struct v4l2_subdev_ops imx214_subdev_ops = {
-	.core	= &imx214_subdev_core_ops,
-	.video	= &imx214_subdev_video_ops,
-	.pad	= &imx214_subdev_pad_ops,
-};
+static int imx214_set_gain(struct tegracam_device *tc_dev, s64 val);
+static int imx214_set_frame_rate(struct tegracam_device *tc_dev, s64 val);
+static int imx214_set_exposure(struct tegracam_device *tc_dev, s64 val);
+static int imx214_set_exposure_short(struct tegracam_device *tc_dev, s64 val);
 
-static struct of_device_id imx214_of_match[] = {
-	{ .compatible = "nvidia,imx214", },
+static const struct of_device_id imx214_of_match[] = {
+	{
+		.compatible = "nvidia,imx214",
+	},
 	{ },
 };
 
-static struct camera_common_sensor_ops imx214_common_ops = {
-	.power_on = imx214_power_on,
-	.power_off = imx214_power_off,
-	.write_reg = imx214_write_reg,
-	.read_reg = imx214_read_reg,
-};
-
-static int imx214_set_group_hold(struct imx214 *priv)
+static int imx214_set_group_hold(struct tegracam_device *tc_dev, bool val)
 {
-	struct device *dev = &priv->i2c_client->dev;
 	int err;
+	struct imx214 *priv = tc_dev->priv;
 	int gh_prev = switch_ctrl_qmenu[priv->group_hold_prev];
+	struct device *dev = tc_dev->dev;
 
 	if (priv->group_hold_en == true && gh_prev == SWITCH_OFF) {
+		camera_common_i2c_aggregate(&priv->i2c_dev, true);
+		/* enter group hold */
 		err = imx214_write_reg(priv->s_data,
-				       IMX214_GROUP_HOLD_ADDR, 0x1);
+				       IMX214_GROUP_HOLD_ADDR, val);
 		if (err)
 			goto fail;
+
 		priv->group_hold_prev = 1;
+
+		dev_dbg(dev, "%s: enter group hold\n", __func__);
 	} else if (priv->group_hold_en == false && gh_prev == SWITCH_ON) {
+		/* leave group hold */
 		err = imx214_write_reg(priv->s_data,
 				       IMX214_GROUP_HOLD_ADDR, 0x0);
 		if (err)
 			goto fail;
+
+		err = imx214_write_reg(priv->s_data,
+				       IMX214_GROUP_HOLD_ADDR, 0x1);
+		if (err)
+			goto fail;
+
+		camera_common_i2c_aggregate(&priv->i2c_dev, false);
+
 		priv->group_hold_prev = 0;
+
+		dev_dbg(dev, "%s: leave group hold\n", __func__);
 	}
 
 	return 0;
@@ -542,57 +433,34 @@ static int imx214_set_group_hold(struct imx214 *priv)
 	return err;
 }
 
-static int imx214_calculate_gain(u32 rep, int shift)
-{
-	int gain;
-	int gain_int;
-	int gain_dec;
-	int min_int = (1 << shift);
-	int denom;
-
-	/* shift indicates number of least significant bits
-	 * used for decimal representation of gain */
-	gain_int = (int)(rep >> shift);
-	gain_dec = (int)(rep & ~(0xffff << shift));
-
-	denom = gain_int * min_int + gain_dec;
-	gain = 512 - ((512 * min_int + (denom - 1)) / denom);
-
-	return gain;
-}
-
-static int imx214_set_gain(struct imx214 *priv, s32 val)
+static int imx214_set_gain(struct tegracam_device *tc_dev, s64 val)
 {
-	struct device *dev = &priv->i2c_client->dev;
+	struct camera_common_data *s_data = tc_dev->s_data;
+	struct imx214 *priv = (struct imx214 *)tc_dev->priv;
+	struct device *dev = tc_dev->dev;
+	const struct sensor_mode_properties *mode =
+		&s_data->sensor_props.sensor_modes[s_data->mode_prop_idx];
 	imx214_reg reg_list[2];
-	imx214_reg reg_list_short[2];
 	int err;
 	u16 gain;
-	int i = 0;
-
-	/* translate value */
-	gain = (u16)imx214_calculate_gain(val, IMX214_GAIN_SHIFT);
+	int i;
 
-	dev_dbg(dev, "%s: val: %d\n", __func__, gain);
+	if (!priv->group_hold_prev)
+		imx214_set_group_hold(tc_dev, 1);
 
+	/* translate value */
+	gain = (u16) (((val * 16) +
+			(mode->control_properties.gain_factor / 2)) /
+			mode->control_properties.gain_factor);
 	imx214_get_gain_regs(reg_list, gain);
-	imx214_get_gain_short_reg(reg_list_short, gain);
-	imx214_set_group_hold(priv);
+	dev_dbg(dev, "%s: gain %d val: %lld\n", __func__, gain, val);
 
-	/* writing long gain */
 	for (i = 0; i < 2; i++) {
-		err = imx214_write_reg(priv->s_data, reg_list[i].addr,
+		err = imx214_write_reg(s_data, reg_list[i].addr,
 			 reg_list[i].val);
 		if (err)
 			goto fail;
 	}
-	/* writing short gain */
-	for (i = 0; i < 2; i++) {
-		err = imx214_write_reg(priv->s_data, reg_list_short[i].addr,
-			 reg_list_short[i].val);
-		if (err)
-			goto fail;
-	}
 
 	return 0;
 
@@ -601,28 +469,37 @@ static int imx214_set_gain(struct imx214 *priv, s32 val)
 	return err;
 }
 
-static int imx214_set_frame_length(struct imx214 *priv, s32 val)
+static int imx214_set_frame_rate(struct tegracam_device *tc_dev, s64 val)
 {
-	struct device *dev = &priv->i2c_client->dev;
+	struct camera_common_data *s_data = tc_dev->s_data;
+	struct device *dev = tc_dev->dev;
+	struct imx214 *priv = tc_dev->priv;
+	const struct sensor_mode_properties *mode =
+		&s_data->sensor_props.sensor_modes[s_data->mode_prop_idx];
 	imx214_reg reg_list[2];
 	int err;
-	u16 frame_length;
-	int i = 0;
+	u32 frame_length;
+	int i;
 
-	frame_length = (u16)val;
+	if (!priv->group_hold_prev)
+		imx214_set_group_hold(tc_dev, 1);
 
-	dev_dbg(dev, "%s: val: %d\n", __func__, frame_length);
+	frame_length =  mode->signal_properties.pixel_clock.val *
+		mode->control_properties.framerate_factor /
+		mode->image_properties.line_length / val;
 
 	imx214_get_frame_length_regs(reg_list, frame_length);
-	imx214_set_group_hold(priv);
+	dev_dbg(dev, "%s: val: %d\n", __func__, frame_length);
 
 	for (i = 0; i < 2; i++) {
-		err = imx214_write_reg(priv->s_data, reg_list[i].addr,
+		err = imx214_write_reg(s_data, reg_list[i].addr,
 			 reg_list[i].val);
 		if (err)
 			goto fail;
 	}
 
+	priv->frame_length = frame_length;
+
 	return 0;
 
 fail:
@@ -630,23 +507,34 @@ static int imx214_set_frame_length(struct imx214 *priv, s32 val)
 	return err;
 }
 
-static int imx214_set_coarse_time(struct imx214 *priv, s32 val)
+static int imx214_set_exposure(struct tegracam_device *tc_dev, s64 val)
 {
-	struct device *dev = &priv->i2c_client->dev;
-	imx214_reg reg_list[2];
+	struct camera_common_data *s_data = tc_dev->s_data;
+	struct device *dev = tc_dev->dev;
+	struct imx214 *priv = tc_dev->priv;
+	const s32 max_coarse_time = priv->frame_length - IMX214_MAX_COARSE_DIFF;
+	const struct sensor_mode_properties *mode =
+		&s_data->sensor_props.sensor_modes[s_data->mode_prop_idx];
+	imx214_reg reg_list[3];
 	int err;
-	u16 coarse_time;
-	int i = 0;
-
-	coarse_time = (u16)val;
+	u32 coarse_time;
+	int i;
 
-	dev_dbg(dev, "%s: val: %d\n", __func__, coarse_time);
+	if (!priv->group_hold_prev)
+		imx214_set_group_hold(tc_dev, 1);
 
+	coarse_time = (u32)(((mode->signal_properties.pixel_clock.val*val)
+			/mode->image_properties.line_length)/
+			mode->control_properties.exposure_factor);
+	if (coarse_time < IMX214_MIN_EXPOSURE_COARSE)
+		coarse_time = IMX214_MIN_EXPOSURE_COARSE;
+	else if (coarse_time > max_coarse_time)
+		coarse_time = max_coarse_time;
 	imx214_get_coarse_time_regs(reg_list, coarse_time);
-	imx214_set_group_hold(priv);
+	dev_dbg(dev, "%s: val: %d\n", __func__, coarse_time);
 
-	for (i = 0; i < 2; i++) {
-		err = imx214_write_reg(priv->s_data, reg_list[i].addr,
+	for (i = 0; i < 3; i++) {
+		err = imx214_write_reg(s_data, reg_list[i].addr,
 			 reg_list[i].val);
 		if (err)
 			goto fail;
@@ -659,20 +547,26 @@ static int imx214_set_coarse_time(struct imx214 *priv, s32 val)
 	return err;
 }
 
-static int imx214_set_coarse_time_short(struct imx214 *priv, s32 val)
+static int imx214_set_exposure_short(struct tegracam_device *tc_dev, s64 val)
 {
-	struct device *dev = &priv->i2c_client->dev;
-	imx214_reg reg_list[2];
+	struct camera_common_data *s_data = tc_dev->s_data;
+	struct device *dev = tc_dev->dev;
+	struct imx214 *priv = tc_dev->priv;
+	const struct sensor_mode_properties *mode =
+		&s_data->sensor_props.sensor_modes[s_data->mode_prop_idx];
+	imx214_reg reg_list[3];
 	int err;
 	struct v4l2_control hdr_control;
 	int hdr_en;
-	u16 coarse_time_short;
-	int i = 0;
+	u32 coarse_time_short;
+	int i;
+	if (!priv->group_hold_prev)
+		imx214_set_group_hold(tc_dev, 1);
 
 	/* check hdr enable ctrl */
 	hdr_control.id = TEGRA_CAMERA_CID_HDR_EN;
 
-	err = camera_common_g_ctrl(priv->s_data, &hdr_control);
+	err = camera_common_g_ctrl(s_data, &hdr_control);
 	if (err < 0) {
 		dev_err(dev, "could not find device ctrl.\n");
 		return err;
@@ -682,15 +576,15 @@ static int imx214_set_coarse_time_short(struct imx214 *priv, s32 val)
 	if (hdr_en == SWITCH_OFF)
 		return 0;
 
-	coarse_time_short = (u16)val;
-
-	dev_dbg(dev, "%s: val: %d\n", __func__, coarse_time_short);
+	coarse_time_short = (u32)(((mode->signal_properties.pixel_clock.val*val)
+				/mode->image_properties.line_length)
+				/mode->control_properties.exposure_factor);
 
 	imx214_get_coarse_time_short_regs(reg_list, coarse_time_short);
-	imx214_set_group_hold(priv);
+	dev_dbg(dev, "%s: val: %d\n", __func__, coarse_time_short);
 
-	for (i = 0; i < 2; i++) {
-		err  = imx214_write_reg(priv->s_data, reg_list[i].addr,
+	for (i = 0; i < 3; i++) {
+		err = imx214_write_reg(s_data, reg_list[i].addr,
 			 reg_list[i].val);
 		if (err)
 			goto fail;
@@ -703,6 +597,36 @@ static int imx214_set_coarse_time_short(struct imx214 *priv, s32 val)
 	return err;
 }
 
+static int imx214_fill_string_ctrl(struct tegracam_device *tc_dev,
+				struct v4l2_ctrl *ctrl)
+{
+	struct imx214 *priv = tc_dev->priv;
+	int i;
+
+	switch (ctrl->id) {
+	case TEGRA_CAMERA_CID_EEPROM_DATA:
+		for (i = 0; i < IMX214_EEPROM_SIZE; i++)
+			sprintf(&ctrl->p_new.p_char[i*2], "%02x",
+				priv->eeprom_buf[i]);
+		break;
+	case TEGRA_CAMERA_CID_OTP_DATA:
+		for (i = 0; i < IMX214_OTP_SIZE; i++)
+			sprintf(&ctrl->p_new.p_char[i*2], "%02x",
+				priv->otp_buf[i]);
+		break;
+	case TEGRA_CAMERA_CID_FUSE_ID:
+		for (i = 0; i < IMX214_FUSE_ID_SIZE; i++)
+			sprintf(&ctrl->p_new.p_char[i*2], "%02x",
+				priv->fuse_id[i]);
+		break;
+	default:
+		dev_dbg(tc_dev->dev, "%s: Invalid ctrl -> id\n", __func__);
+		return -EINVAL;
+	}
+	ctrl->p_cur.p_char = ctrl->p_new.p_char;
+	return 0;
+}
+
 static int imx214_eeprom_device_release(struct imx214 *priv)
 {
 	int i;
@@ -719,7 +643,7 @@ static int imx214_eeprom_device_release(struct imx214 *priv)
 
 static int imx214_eeprom_device_init(struct imx214 *priv)
 {
-	struct device *dev = &priv->i2c_client->dev;
+	struct camera_common_pdata *pdata =  priv->s_data->pdata;
 	char *dev_name = "eeprom_imx214";
 	static struct regmap_config eeprom_regmap_config = {
 		.reg_bits = 8,
@@ -727,14 +651,9 @@ static int imx214_eeprom_device_init(struct imx214 *priv)
 	};
 	int i;
 	int err;
-	struct v4l2_ctrl *ctrl;
 
-	ctrl = v4l2_ctrl_find(&priv->ctrl_handler,
-			TEGRA_CAMERA_CID_EEPROM_DATA);
-	if (!ctrl) {
-		dev_err(dev, "could not find device ctrl.\n");
+	if (!pdata->has_eeprom)
 		return -EINVAL;
-	}
 
 	for (i = 0; i < IMX214_EEPROM_NUM_BLOCKS; i++) {
 		priv->eeprom[i].adap = i2c_get_adapter(
@@ -751,7 +670,6 @@ static int imx214_eeprom_device_init(struct imx214 *priv)
 		if (IS_ERR(priv->eeprom[i].regmap)) {
 			err = PTR_ERR(priv->eeprom[i].regmap);
 			imx214_eeprom_device_release(priv);
-			ctrl->flags = V4L2_CTRL_FLAG_DISABLED;
 			return err;
 		}
 	}
@@ -759,8 +677,7 @@ static int imx214_eeprom_device_init(struct imx214 *priv)
 	return 0;
 }
 
-static int imx214_read_eeprom(struct imx214 *priv,
-				struct v4l2_ctrl *ctrl)
+static int imx214_read_eeprom(struct imx214 *priv)
 {
 	int err, i;
 
@@ -771,74 +688,51 @@ static int imx214_read_eeprom(struct imx214 *priv,
 		if (err)
 			return err;
 	}
-
-	for (i = 0; i < IMX214_EEPROM_SIZE; i++)
-		sprintf(&ctrl->string[i*2], "%02x",
-			priv->eeprom_buf[i]);
 	return 0;
 }
 
-static int imx214_write_eeprom(struct imx214 *priv,
-				char *string)
+static int imx214_read_otp_bank(struct imx214 *priv,
+				u8 *buf, int bank, u16 addr, int size)
 {
-	struct device *dev = &priv->i2c_client->dev;
 	int err;
-	int i;
-	u8 curr[3];
-	unsigned long data;
-
-	for (i = 0; i < IMX214_EEPROM_SIZE; i++) {
-		curr[0] = string[i*2];
-		curr[1] = string[i*2+1];
-		curr[2] = '\0';
 
-		err = kstrtol(curr, 16, &data);
-		if (err) {
-			dev_err(dev, "invalid eeprom string\n");
-			return -EINVAL;
-		}
+	/* sleeps calls in the sequence below are for internal device
+	 * signal propagation as specified by sensor vendor */
 
-		priv->eeprom_buf[i] = (u8)data;
-		err = regmap_write(priv->eeprom[i >> 8].regmap,
-				   i & 0xFF, (u8)data);
-		if (err)
-			return err;
-		msleep(20);
+	usleep_range(10000, 11000);
+	mutex_lock(&priv->streaming_lock);
+	err = imx214_write_table(priv, mode_table[IMX214_MODE_START_STREAM]);
+	if (err) {
+		mutex_unlock(&priv->streaming_lock);
+		return err;
+	} else {
+		priv->streaming = true;
+		mutex_unlock(&priv->streaming_lock);
 	}
-	return 0;
-}
-
-static int imx214_read_otp_page(struct imx214 *priv,
-				u8 *buf, int page, u16 addr, int size)
-{
-	struct device *dev = &priv->i2c_client->dev;
-	u8 status;
-	int err;
 
-	err = imx214_write_reg(priv->s_data, IMX214_OTP_PAGE_NUM_ADDR, page);
+	err = imx214_write_reg(priv->s_data, IMX214_OTP_BANK_SELECT_ADDR,
+			       0xC0 | bank);
 	if (err)
 		return err;
-	err = imx214_write_reg(priv->s_data, IMX214_OTP_CTRL_ADDR, 0x01);
-	if (err)
-		return err;
-	err = imx214_read_reg(priv->s_data, IMX214_OTP_STATUS_ADDR, &status);
-	if (err)
-		return err;
-	if (status == IMX214_OTP_STATUS_IN_PROGRESS) {
-		dev_err(dev, "another OTP read in progress\n");
-		return err;
-	}
 
-	err = regmap_bulk_read(priv->regmap, addr, buf, size);
+	err = imx214_write_reg(priv->s_data, IMX214_OTP_LOAD_CTRL_ADDR, 0x01);
 	if (err)
 		return err;
 
-	err = imx214_read_reg(priv->s_data, IMX214_OTP_STATUS_ADDR, &status);
+	usleep_range(10000, 11000);
+	err = regmap_bulk_read(priv->s_data->regmap, addr, buf, size);
+
 	if (err)
 		return err;
-	if (status == IMX214_OTP_STATUS_READ_FAIL) {
-		dev_err(dev, "fuse id read error\n");
+
+	mutex_lock(&priv->streaming_lock);
+	err = imx214_write_table(priv, mode_table[IMX214_MODE_STOP_STREAM]);
+	if (err) {
+		mutex_unlock(&priv->streaming_lock);
 		return err;
+	} else {
+		priv->streaming = false;
+		mutex_unlock(&priv->streaming_lock);
 	}
 
 	return 0;
@@ -846,261 +740,378 @@ static int imx214_read_otp_page(struct imx214 *priv,
 
 static int imx214_otp_setup(struct imx214 *priv)
 {
-	struct device *dev = &priv->i2c_client->dev;
-	int err;
+	struct device *dev = priv->s_data->dev;
+	int err = 0;
 	int i;
-	struct v4l2_ctrl *ctrl;
-	u8 otp_buf[IMX214_OTP_SIZE];
 
-	err = camera_common_s_power(priv->subdev, true);
-	if (err)
-		return -ENODEV;
+	for (i = 0; i < IMX214_OTP_NUM_BANKS; i++) {
+		err = imx214_read_otp_bank(priv,
+					&priv->otp_buf[i
+					* IMX214_OTP_BANK_SIZE],
+					i,
+					IMX214_OTP_BANK_START_ADDR,
+					IMX214_OTP_BANK_SIZE);
+		if (err) {
+			dev_err(dev, "could not read otp bank\n");
+			goto ret;
+		}
+	}
+
+ret:
+	return err;
+}
+
+MODULE_DEVICE_TABLE(of, imx214_of_match);
+
+static struct camera_common_pdata *imx214_parse_dt(struct tegracam_device
+							*tc_dev)
+{
+	struct device *dev = tc_dev->dev;
+	struct device_node *node = dev->of_node;
+	struct camera_common_pdata *board_priv_pdata;
+	const struct of_device_id *match;
+	int gpio;
+	int err;
+	struct camera_common_pdata *ret = NULL;
 
-	for (i = 0; i < IMX214_OTP_NUM_PAGES; i++) {
-		imx214_read_otp_page(priv,
-				   &otp_buf[i * IMX214_OTP_PAGE_SIZE],
-				   i,
-				   IMX214_OTP_PAGE_START_ADDR,
-				   IMX214_OTP_PAGE_SIZE);
+	if (!node)
+		return NULL;
+
+	match = of_match_device(imx214_of_match, dev);
+	if (!match) {
+		dev_err(dev, "Failed to find matching dt id\n");
+		return NULL;
 	}
 
-	ctrl = v4l2_ctrl_find(&priv->ctrl_handler, TEGRA_CAMERA_CID_OTP_DATA);
-	if (!ctrl) {
-		dev_err(dev, "could not find device ctrl.\n");
-		return -EINVAL;
+	board_priv_pdata = devm_kzalloc(dev,
+			   sizeof(*board_priv_pdata), GFP_KERNEL);
+	if (!board_priv_pdata)
+		return NULL;
+
+	err = camera_common_parse_clocks(dev,
+					 board_priv_pdata);
+	if (err) {
+		dev_err(dev, "Failed to find clocks\n");
+		goto error;
 	}
 
-	for (i = 0; i < IMX214_OTP_SIZE; i++)
-		sprintf(&ctrl->string[i*2], "%02x",
-			otp_buf[i]);
-	ctrl->cur.string = ctrl->string;
+	gpio = of_get_named_gpio(node, "pwdn-gpios", 0);
+	if (gpio < 0) {
+		if (gpio == -EPROBE_DEFER) {
+			ret = ERR_PTR(-EPROBE_DEFER);
+			goto error;
+		}
+		gpio = 0;
+	}
+	board_priv_pdata->pwdn_gpio = (unsigned int)gpio;
+
+	gpio = of_get_named_gpio(node, "reset-gpios", 0);
+	if (gpio < 0) {
+		/* reset-gpio is not absolutely needed */
+		if (gpio == -EPROBE_DEFER) {
+			ret = ERR_PTR(-EPROBE_DEFER);
+			goto error;
+		}
+		dev_dbg(dev, "reset gpios not in DT\n");
+		gpio = 0;
+	}
+	board_priv_pdata->reset_gpio = (unsigned int)gpio;
 
-	err = camera_common_s_power(priv->subdev, false);
-	if (err)
-		return -ENODEV;
+	board_priv_pdata->use_cam_gpio =
+		of_property_read_bool(node, "cam,use-cam-gpio");
 
-	return 0;
+	err = of_property_read_string(node, "avdd-reg",
+			&board_priv_pdata->regulators.avdd);
+	if (err) {
+		dev_err(dev, "avdd-reg not in DT\n");
+		goto error;
+	}
+	err = of_property_read_string(node, "dvdd-reg",
+			&board_priv_pdata->regulators.dvdd);
+	if (err) {
+		dev_err(dev, "dvdd-reg not in DT\n");
+		goto error;
+	}
+
+	board_priv_pdata->has_eeprom =
+		of_property_read_bool(node, "has-eeprom");
+	board_priv_pdata->v_flip = of_property_read_bool(node, "vertical-flip");
+	board_priv_pdata->h_mirror = of_property_read_bool(node,
+							 "horizontal-mirror");
+
+	return board_priv_pdata;
+
+error:
+	devm_kfree(dev, board_priv_pdata);
+	return ret;
 }
 
-static int imx214_fuse_id_setup(struct imx214 *priv)
+static int imx214_set_mode(struct tegracam_device *tc_dev)
 {
-	struct device *dev = &priv->i2c_client->dev;
+	struct imx214 *priv = (struct imx214 *)tegracam_get_privdata(tc_dev);
+	struct camera_common_data *s_data = tc_dev->s_data;
 	int err;
-	int i;
-	struct v4l2_ctrl *ctrl;
-	u8 fuse_id[IMX214_FUSE_ID_SIZE];
 
-	err = camera_common_s_power(priv->subdev, true);
+	err = imx214_write_table(priv, mode_table[s_data->mode_prop_idx]);
 	if (err)
-		return -ENODEV;
+		return err;
 
-	imx214_read_otp_page(priv,
-			   &fuse_id[0],
-			   IMX214_FUSE_ID_OTP_PAGE,
-			   IMX214_FUSE_ID_OTP_ROW_ADDR,
-			   IMX214_FUSE_ID_SIZE);
+	return 0;
+}
+static int imx214_stop_streaming(struct tegracam_device *tc_dev)
+{
+	struct camera_common_data *s_data = tc_dev->s_data;
+	struct imx214 *priv = (struct imx214 *)tegracam_get_privdata(tc_dev);
+	struct device *dev = s_data->dev;
+	u32 frame_time;
+	int err;
 
-	ctrl = v4l2_ctrl_find(&priv->ctrl_handler, TEGRA_CAMERA_CID_FUSE_ID);
-	if (!ctrl) {
-		dev_err(dev, "could not find device ctrl.\n");
-		return -EINVAL;
+	mutex_lock(&priv->streaming_lock);
+	err = imx214_write_table(priv,
+		mode_table[IMX214_MODE_STOP_STREAM]);
+	if (err) {
+		mutex_unlock(&priv->streaming_lock);
+		goto exit;
+	} else {
+		priv->streaming = false;
+		mutex_unlock(&priv->streaming_lock);
 	}
 
-	for (i = 0; i < IMX214_FUSE_ID_SIZE; i++)
-		sprintf(&ctrl->string[i*2], "%02x",
-			fuse_id[i]);
-	ctrl->cur.string = ctrl->string;
+	/*
+	 * Wait for one frame to make sure sensor is set to
+	 * software standby in V-blank
+	 *
+	 * frame_time = frame length rows * Tline
+	 * Tline = line length / pixel clock (in MHz)
+	 */
+	frame_time = priv->frame_length *
+		IMX214_DEFAULT_LINE_LENGTH / IMX214_DEFAULT_PIXEL_CLOCK;
 
-	err = camera_common_s_power(priv->subdev, false);
-	if (err)
-		return -ENODEV;
+	usleep_range(frame_time, frame_time + 1000);
 
 	return 0;
-}
 
-static int imx214_g_volatile_ctrl(struct v4l2_ctrl *ctrl)
+exit:
+	dev_err(dev, "%s: error stopping stream\n", __func__);
+	return err;
+};
+
+static int imx214_start_streaming(struct tegracam_device *tc_dev)
 {
-	struct imx214 *priv =
-		container_of(ctrl->handler, struct imx214, ctrl_handler);
-	struct device *dev = &priv->i2c_client->dev;
-	int err = 0;
+	struct imx214 *priv = (struct imx214 *)tegracam_get_privdata(tc_dev);
+	struct camera_common_data *s_data = tc_dev->s_data;
+	struct camera_common_pdata *pdata = s_data->pdata;
+	struct device *dev = s_data->dev;
+	int err;
+	u8 val;
 
-	if (priv->power.state == SWITCH_OFF)
-		return 0;
 
-	switch (ctrl->id) {
-	case TEGRA_CAMERA_CID_EEPROM_DATA:
-		err = imx214_read_eeprom(priv, ctrl);
-		if (err)
-			return err;
-		break;
-	default:
-			dev_err(dev, "%s: unknown ctrl id.\n", __func__);
-			return -EINVAL;
+    mutex_lock(&priv->streaming_lock);
+
+    err = imx214_write_table(priv, mode_table[IMX214_MODE_START_STREAM]);
+	if (err) {
+		mutex_unlock(&priv->streaming_lock);
+		goto exit;
+	} else {
+		priv->streaming = true;
+		mutex_unlock(&priv->streaming_lock);
+	}
+
+	if (pdata->v_flip) {
+		imx214_read_reg(s_data, IMX214_TIMING_REG20, &val);
+		imx214_write_reg(s_data, IMX214_TIMING_REG20,
+				 val | VERTICAL_FLIP);
+	}
+	if (pdata->h_mirror) {
+		imx214_read_reg(s_data, IMX214_TIMING_REG21, &val);
+		imx214_write_reg(s_data, IMX214_TIMING_REG21,
+				 val | HORIZONTAL_MIRROR_MASK);
+	} else {
+		imx214_read_reg(s_data, IMX214_TIMING_REG21, &val);
+		imx214_write_reg(s_data, IMX214_TIMING_REG21,
+				 val & (~HORIZONTAL_MIRROR_MASK));
 	}
+	if (test_mode)
+		err = imx214_write_table(priv,
+			mode_table[IMX214_MODE_TEST_PATTERN]);
 
+	return 0;
+
+exit:
+	dev_err(dev, "%s: error starting stream\n", __func__);
 	return err;
 }
 
-static int imx214_s_ctrl(struct v4l2_ctrl *ctrl)
+static struct camera_common_sensor_ops imx214_common_ops = {
+	.numfrmfmts = ARRAY_SIZE(imx214_frmfmt),
+	.frmfmt_table = imx214_frmfmt,
+	.power_on = imx214_power_on,
+	.power_off = imx214_power_off,
+	.write_reg = imx214_write_reg,
+	.read_reg = imx214_read_reg,
+	.parse_dt = imx214_parse_dt,
+	.power_get = imx214_power_get,
+	.power_put = imx214_power_put,
+	.set_mode = imx214_set_mode,
+	.start_streaming = imx214_start_streaming,
+	.stop_streaming = imx214_stop_streaming,
+};
+
+static int imx214_debugfs_streaming_show(void *data, u64 *val)
 {
-	struct imx214 *priv =
-		container_of(ctrl->handler, struct imx214, ctrl_handler);
-	struct device *dev = &priv->i2c_client->dev;
-	int err = 0;
+	struct imx214 *priv = data;
 
-	if (priv->power.state == SWITCH_OFF)
-		return 0;
+	mutex_lock(&priv->streaming_lock);
+	*val = priv->streaming;
+	mutex_unlock(&priv->streaming_lock);
 
-	switch (ctrl->id) {
-	case TEGRA_CAMERA_CID_GAIN:
-		err = imx214_set_gain(priv, ctrl->val);
-		break;
-	case TEGRA_CAMERA_CID_FRAME_LENGTH:
-		err = imx214_set_frame_length(priv, ctrl->val);
-		break;
-	case TEGRA_CAMERA_CID_COARSE_TIME:
-		err = imx214_set_coarse_time(priv, ctrl->val);
-		break;
-	case TEGRA_CAMERA_CID_COARSE_TIME_SHORT:
-		err = imx214_set_coarse_time_short(priv, ctrl->val);
-		break;
-	case TEGRA_CAMERA_CID_GROUP_HOLD:
-		if (switch_ctrl_qmenu[ctrl->val] == SWITCH_ON) {
-			priv->group_hold_en = true;
-		} else {
-			priv->group_hold_en = false;
-			err = imx214_set_group_hold(priv);
-		}
-		break;
-	case TEGRA_CAMERA_CID_EEPROM_DATA:
-		if (!ctrl->string[0])
-			break;
-		err = imx214_write_eeprom(priv, ctrl->string);
-		if (err)
-			return err;
-		break;
-	case TEGRA_CAMERA_CID_HDR_EN:
-		break;
-	default:
-		dev_err(dev, "%s: unknown ctrl id.\n", __func__);
-		return -EINVAL;
-	}
-
-	return err;
+	return 0;
 }
 
-static int imx214_ctrls_init(struct imx214 *priv)
+static int imx214_debugfs_streaming_write(void *data, u64 val)
 {
+	int err = 0;
+	struct imx214 *priv = data;
 	struct i2c_client *client = priv->i2c_client;
-	struct device *dev = &client->dev;
-	struct v4l2_ctrl *ctrl;
-	int numctrls;
-	int err;
-	int i;
-
-	dev_dbg(dev, "%s++\n", __func__);
+	bool enable = (val != 0);
+	int mode_index = enable ?
+		(IMX214_MODE_START_STREAM) : (IMX214_MODE_STOP_STREAM);
 
-	numctrls = ARRAY_SIZE(ctrl_config_list);
-	v4l2_ctrl_handler_init(&priv->ctrl_handler, numctrls);
+	dev_info(&client->dev, "%s: %s sensor\n",
+			__func__, (enable ? "enabling" : "disabling"));
 
-	for (i = 0; i < numctrls; i++) {
-		ctrl = v4l2_ctrl_new_custom(&priv->ctrl_handler,
-			&ctrl_config_list[i], NULL);
-		if (ctrl == NULL) {
-			dev_err(dev, "Failed to init %s ctrl\n",
-				ctrl_config_list[i].name);
-			continue;
-		}
+	mutex_lock(&priv->streaming_lock);
 
-		if (ctrl_config_list[i].type == V4L2_CTRL_TYPE_STRING &&
-			ctrl_config_list[i].flags & V4L2_CTRL_FLAG_READ_ONLY) {
-			ctrl->string = devm_kzalloc(&client->dev,
-				ctrl_config_list[i].max + 1, GFP_KERNEL);
-			if (!ctrl->string) {
-				dev_err(dev, "Failed to allocate otp data\n");
-				return -ENOMEM;
-			}
-		}
-		priv->ctrls[i] = ctrl;
+	err = imx214_write_table(priv, mode_table[mode_index]);
+	if (err) {
+		dev_err(&client->dev, "%s: error setting sensor streaming\n",
+			__func__);
+		goto done;
 	}
 
-	priv->numctrls = numctrls;
-	priv->subdev->ctrl_handler = &priv->ctrl_handler;
-	if (priv->ctrl_handler.error) {
-		dev_err(dev, "Error %d adding controls\n",
-			priv->ctrl_handler.error);
-		err = priv->ctrl_handler.error;
-		goto error;
-	}
+	priv->streaming = enable;
 
-	err = v4l2_ctrl_handler_setup(&priv->ctrl_handler);
-	if (err) {
-		dev_err(dev, "Error %d setting default controls\n", err);
-		goto error;
-	}
+done:
+	mutex_unlock(&priv->streaming_lock);
 
-	err = imx214_otp_setup(priv);
+	return err;
+}
+
+DEFINE_SIMPLE_ATTRIBUTE(imx214_debugfs_streaming_fops,
+	imx214_debugfs_streaming_show,
+	imx214_debugfs_streaming_write,
+	"%lld\n");
+
+static void imx214_debugfs_remove(struct imx214 *priv);
+
+static int imx214_debugfs_create(struct imx214 *priv)
+{
+	int err = 0;
+	struct i2c_client *client = priv->i2c_client;
+	const char *devnode;
+	char debugfs_dir[16];
+
+	err = of_property_read_string(client->dev.of_node, "devnode", &devnode);
 	if (err) {
-		dev_err(dev, "Error %d reading otp data\n", err);
-		goto error;
+		dev_err(&client->dev, "devnode not in DT\n");
+		return err;
 	}
+	snprintf(debugfs_dir, sizeof(debugfs_dir), "camera-%s", devnode);
 
-	err = imx214_fuse_id_setup(priv);
-	if (err) {
-		dev_err(dev, "Error %d reading fuse id data\n", err);
+	priv->debugfs_dir = debugfs_create_dir(debugfs_dir, NULL);
+	if (priv->debugfs_dir == NULL)
+		return -ENOMEM;
+
+	if (!debugfs_create_file("streaming", 0644, priv->debugfs_dir, priv,
+			&imx214_debugfs_streaming_fops))
 		goto error;
-	}
 
 	return 0;
 
 error:
-	v4l2_ctrl_handler_free(&priv->ctrl_handler);
-	return err;
+	imx214_debugfs_remove(priv);
+
+	return -ENOMEM;
 }
 
-MODULE_DEVICE_TABLE(of, imx214_of_match);
+static struct tegracam_ctrl_ops imx214_ctrl_ops = {
+	.numctrls = ARRAY_SIZE(ctrl_cid_list),
+	.ctrl_cid_list = ctrl_cid_list,
+	.string_ctrl_size = {IMX214_EEPROM_STR_SIZE,
+				IMX214_FUSE_ID_STR_SIZE,
+				IMX214_OTP_STR_SIZE},
+	.set_gain = imx214_set_gain,
+	.set_exposure = imx214_set_exposure,
+	.set_exposure_short = imx214_set_exposure_short,
+	.set_frame_rate = imx214_set_frame_rate,
+	.set_group_hold = imx214_set_group_hold,
+	.fill_string_ctrl = imx214_fill_string_ctrl,
+};
 
-static struct camera_common_pdata *imx214_parse_dt(struct i2c_client *client)
+static int imx214_board_setup(struct imx214 *priv)
 {
-	struct device_node *np = client->dev.of_node;
-	struct camera_common_pdata *board_priv_pdata;
-	const struct of_device_id *match;
+	struct camera_common_data *s_data = priv->s_data;
+	struct device *dev = s_data->dev;
+	bool eeprom_ctrl = 0;
+	int err = 0;
 
-	match = of_match_device(imx214_of_match, &client->dev);
-	if (!match) {
-		dev_err(&client->dev, "Failed to find matching dt id\n");
-		return NULL;
+	dev_dbg(dev, "%s++\n", __func__);
+
+	/* eeprom interface */
+	err = imx214_eeprom_device_init(priv);
+	if (err && s_data->pdata->has_eeprom)
+		dev_err(dev,
+			"Failed to allocate eeprom reg map: %d\n", err);
+	eeprom_ctrl = !err;
+
+	err = camera_common_mclk_enable(s_data);
+	if (err) {
+		dev_err(dev,
+			"Error %d turning on mclk\n", err);
+		return err;
 	}
 
-	board_priv_pdata = devm_kzalloc(&client->dev,
-			   sizeof(*board_priv_pdata), GFP_KERNEL);
-	if (!board_priv_pdata) {
-		dev_err(&client->dev, "Failed to allocate pdata\n");
-		return NULL;
+	err = imx214_power_on(s_data);
+	if (err) {
+		dev_err(dev,
+			"Error %d during power on sensor\n", err);
+		return err;
 	}
 
-	of_property_read_string(np, "mclk", &board_priv_pdata->mclk_name);
-	board_priv_pdata->pwdn_gpio = of_get_named_gpio(np, "pwdn-gpios", 0);
-	board_priv_pdata->reset_gpio = of_get_named_gpio(np, "reset-gpios", 0);
-	board_priv_pdata->af_gpio = of_get_named_gpio(np, "af-gpios", 0);
+	if (eeprom_ctrl) {
+		err = imx214_read_eeprom(priv);
+		if (err) {
+			dev_err(dev,
+				"Error %d reading eeprom\n", err);
+			goto error;
+		}
+	}
 
-	of_property_read_string(np, "avdd-reg",
-			&board_priv_pdata->regulators.avdd);
-	of_property_read_string(np, "dvdd-reg",
-			&board_priv_pdata->regulators.dvdd);
-	of_property_read_string(np, "iovdd-reg",
-			&board_priv_pdata->regulators.iovdd);
+	err = imx214_otp_setup(priv);
+	if (err) {
+		dev_err(dev,
+			"Error %d reading otp data\n", err);
+		goto error;
+	}
 
-	return board_priv_pdata;
+
+error:
+	imx214_power_off(s_data);
+	camera_common_mclk_disable(s_data);
+	return err;
+}
+
+static void imx214_debugfs_remove(struct imx214 *priv)
+{
+	debugfs_remove_recursive(priv->debugfs_dir);
+	priv->debugfs_dir = NULL;
 }
 
 static int imx214_open(struct v4l2_subdev *sd, struct v4l2_subdev_fh *fh)
 {
 	struct i2c_client *client = v4l2_get_subdevdata(sd);
-	dev_dbg(&client->dev, "%s:\n", __func__);
-
 
+	dev_dbg(&client->dev, "%s:\n", __func__);
 	return 0;
 }
 
@@ -1108,114 +1119,77 @@ static const struct v4l2_subdev_internal_ops imx214_subdev_internal_ops = {
 	.open = imx214_open,
 };
 
-static const struct media_entity_operations imx214_media_ops = {
-	.link_validate = v4l2_subdev_link_validate,
-};
-
 static int imx214_probe(struct i2c_client *client,
 			const struct i2c_device_id *id)
 {
-	struct camera_common_data *common_data;
-	struct device_node *node = client->dev.of_node;
 	struct device *dev = &client->dev;
+	struct device_node *node = client->dev.of_node;
+	struct tegracam_device *tc_dev;
 	struct imx214 *priv;
 	int err;
+	const struct of_device_id *match;
 
 	dev_info(dev, "probing v4l2 sensor.\n");
 
+	match = of_match_device(imx214_of_match, dev);
+	if (!match) {
+		dev_err(dev, "No device match found\n");
+		return -ENODEV;
+	}
+
 	if (!IS_ENABLED(CONFIG_OF) || !node)
 		return -EINVAL;
 
-	common_data = devm_kzalloc(dev, sizeof(*common_data), GFP_KERNEL);
-	if (!common_data)
+	priv = devm_kzalloc(dev,
+			    sizeof(struct imx214), GFP_KERNEL);
+	if (!priv)
 		return -ENOMEM;
 
-	priv = devm_kzalloc(&client->dev,
-			    sizeof(struct imx214) + sizeof(struct v4l2_ctrl *) *
-			    ARRAY_SIZE(ctrl_config_list),
-			    GFP_KERNEL);
-	if (!priv) {
-		dev_err(dev, "unable to allocate memory!\n");
+	tc_dev = devm_kzalloc(dev,
+			    sizeof(struct tegracam_device), GFP_KERNEL);
+	if (!tc_dev)
 		return -ENOMEM;
-	}
-
-	priv->regmap = devm_regmap_init_i2c(client, &sensor_regmap_config);
-	if (IS_ERR(priv->regmap)) {
-		dev_err(dev, "regmap init failed %ld\n", PTR_ERR(priv->regmap));
-		return -ENODEV;
-	}
-
-	priv->pdata = imx214_parse_dt(client);
-	if (!priv->pdata) {
-		dev_err(dev, "unable to get platform data\n");
-		return -EFAULT;
-	}
 
-	common_data->ops		= &imx214_common_ops;
-	common_data->ctrl_handler	= &priv->ctrl_handler;
-	common_data->i2c_client		= client;
-	common_data->frmfmt		= &imx214_frmfmt[0];
-	common_data->colorfmt		= camera_common_find_datafmt(
-					  IMX214_DEFAULT_DATAFMT);
-	common_data->ctrls		= priv->ctrls;
-	common_data->power		= &priv->power;
-	common_data->priv		= (void *)priv;
-	common_data->numctrls		= ARRAY_SIZE(ctrl_config_list);
-	common_data->numfmts		= ARRAY_SIZE(imx214_frmfmt);
-	common_data->def_mode		= IMX214_DEFAULT_MODE;
-	common_data->def_width		= IMX214_DEFAULT_WIDTH;
-	common_data->def_height		= IMX214_DEFAULT_HEIGHT;
-	common_data->fmt_width		= common_data->def_width;
-	common_data->fmt_height		= common_data->def_height;
-	common_data->def_clk_freq	= IMX214_DEFAULT_CLK_FREQ;
-
-	priv->i2c_client		= client;
-	priv->s_data			= common_data;
-	priv->subdev			= &common_data->subdev;
-	priv->subdev->dev		= &client->dev;
-	priv->s_data->dev		= &client->dev;
-
-	err = imx214_power_get(priv);
-	if (err)
-		return err;
+	priv->i2c_client = tc_dev->client = client;
+	tc_dev->dev = dev;
+	strncpy(tc_dev->name, "imx214", sizeof(tc_dev->name));
+	tc_dev->dev_regmap_config = &imx214_regmap_config;
+	tc_dev->sensor_ops = &imx214_common_ops;
+	tc_dev->v4l2sd_internal_ops = &imx214_subdev_internal_ops;
+	tc_dev->tcctrl_ops = &imx214_ctrl_ops;
 
-	err = camera_common_initialize(common_data, "imx214");
+	err = tegracam_device_register(tc_dev);
 	if (err) {
-		dev_err(dev, "Failed to initialize imx214.\n");
+		dev_err(dev, "tegra camera driver registration failed\n");
 		return err;
 	}
 
-	v4l2_i2c_subdev_init(priv->subdev, client, &imx214_subdev_ops);
+	priv->tc_dev = tc_dev;
+	priv->s_data = tc_dev->s_data;
+	priv->subdev = &tc_dev->s_data->subdev;
+	tegracam_set_privdata(tc_dev, (void *)priv);
+	mutex_init(&priv->streaming_lock);
 
-	err = imx214_ctrls_init(priv);
-	if (err)
-		return err;
-
-	/* eeprom interface */
-	err = imx214_eeprom_device_init(priv);
-	if (err)
-		dev_err(dev, "Failed to alloc eeprom register map: %d\n", err);
-
-	priv->subdev->internal_ops = &imx214_subdev_internal_ops;
-	priv->subdev->flags |= V4L2_SUBDEV_FL_HAS_DEVNODE |
-		     V4L2_SUBDEV_FL_HAS_EVENTS;
+	err = imx214_board_setup(priv);
+		if (err) {
+			dev_err(dev, "board setup failed\n");
+			return err;
+	}
 
-#if defined(CONFIG_MEDIA_CONTROLLER)
-	priv->pad.flags = MEDIA_PAD_FL_SOURCE;
-	priv->subdev->entity.type = MEDIA_ENT_T_V4L2_SUBDEV_SENSOR;
-	priv->subdev->entity.ops = &imx214_media_ops;
-	err = media_entity_init(&priv->subdev->entity, 1, &priv->pad, 0);
-	if (err < 0) {
-		dev_err(&client->dev, "unable to init media entity\n");
+	err = tegracam_v4l2subdev_register(tc_dev, true);
+	if (err) {
+		dev_err(dev, "tegra camera subdev registration failed\n");
 		return err;
 	}
-#endif
 
-	err = v4l2_async_register_subdev(priv->subdev);
-	if (err)
+	err = imx214_debugfs_create(priv);
+	if (err) {
+		dev_err(dev, "error creating debugfs interface");
+		imx214_debugfs_remove(priv);
 		return err;
+	}
 
-	dev_dbg(&client->dev, "Detected IMX214 sensor\n");
+	dev_dbg(dev, "Detected IMX214 sensor\n");
 
 	return 0;
 }
@@ -1223,15 +1197,17 @@ static int imx214_probe(struct i2c_client *client,
 static int
 imx214_remove(struct i2c_client *client)
 {
-	struct camera_common_data *s_data = to_camera_common_data(client);
+	struct camera_common_data *s_data = to_camera_common_data(&client->dev);
 	struct imx214 *priv = (struct imx214 *)s_data->priv;
 
-	v4l2_async_unregister_subdev(priv->subdev);
-#if defined(CONFIG_MEDIA_CONTROLLER)
-	media_entity_cleanup(&priv->subdev->entity);
-#endif
-	v4l2_ctrl_handler_free(&priv->ctrl_handler);
-	camera_common_cleanup(s_data);
+	imx214_debugfs_remove(priv);
+
+	tegracam_v4l2subdev_unregister(priv->tc_dev);
+	imx214_power_put(priv->tc_dev);
+	tegracam_device_unregister(priv->tc_dev);
+	imx214_eeprom_device_release(priv);
+
+	mutex_destroy(&priv->streaming_lock);
 
 	return 0;
 }
@@ -1253,10 +1229,9 @@ static struct i2c_driver imx214_i2c_driver = {
 	.remove = imx214_remove,
 	.id_table = imx214_id,
 };
-
 module_i2c_driver(imx214_i2c_driver);
 
-MODULE_DESCRIPTION("SoC Camera driver for Sony IMX214");
-MODULE_AUTHOR("David Wang <davidw@nvidia.com>");
+MODULE_DESCRIPTION("Media Controller driver for Sony IMX214");
+MODULE_AUTHOR("NVIDIA Corporation");
 MODULE_LICENSE("GPL v2");
 
diff --git a/nvidia/drivers/media/i2c/imx214_mode_tbls.h b/nvidia/drivers/media/i2c/imx214_mode_tbls.h
new file mode 100755
index 000000000000..6bbe36f74b0e
--- /dev/null
+++ b/nvidia/drivers/media/i2c/imx214_mode_tbls.h
@@ -0,0 +1,2956 @@
+/*
+ * imx214_mode_tbls.h - imx214 sensor mode tables
+ *
+ * Copyright (c) 2015-2017, NVIDIA CORPORATION, All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#ifndef __IMX214_TABLES__
+#define __IMX214_TABLES__
+
+#include <media/camera_common.h>
+
+#define IMX214_TABLE_WAIT_MS	0
+#define IMX214_TABLE_END	1
+#define IMX214_MAX_RETRIES	3
+#define IMX214_WAIT_MS		100
+
+#define imx214_reg struct reg_8
+
+static const imx214_reg imx214_start[] = {
+	{0x0100, 0x01}, /* mode select streaming on */
+	{IMX214_TABLE_END, 0x00}
+};
+
+static const imx214_reg imx214_stop[] = {
+	{0x0100, 0x00}, /* mode select streaming on */
+	{IMX214_TABLE_END, 0x00}
+};
+
+static const imx214_reg tp_colorbars[] = {
+	{0x0600, 0xff},
+	{0x0601, 0xff},
+
+	{IMX214_TABLE_WAIT_MS, IMX214_WAIT_MS},
+	{IMX214_TABLE_END, 0x00}
+};
+
+static const imx214_reg mode_table_common[] = {
+	/* software reset */
+
+	/* software standby settings */
+	{0x0100, 0x00},
+
+	/* ATR setting */
+	{0x9300, 0x02},
+
+	/* external clock setting */
+	{0x0136, 0x18},
+	{0x0137, 0x00},
+
+	/* global setting */
+	/* basic config */
+	{0x0101, 0x00},
+	{0x0105, 0x01},
+	{0x0106, 0x01},
+	{0x4550, 0x02},
+	{0x4601, 0x00},
+	{0x4642, 0x05},
+	{0x6227, 0x11},
+	{0x6276, 0x00},
+	{0x900E, 0x06},
+	{0xA802, 0x90},
+	{0xA803, 0x11},
+	{0xA804, 0x62},
+	{0xA805, 0x77},
+	{0xA806, 0xAE},
+	{0xA807, 0x34},
+	{0xA808, 0xAE},
+	{0xA809, 0x35},
+	{0xA80A, 0x62},
+	{0xA80B, 0x83},
+	{0xAE33, 0x00},
+
+  /* analog setting */
+	{0x4174, 0x00},
+	{0x4175, 0x11},
+	{0x4612, 0x29},
+	{0x461B, 0x12},
+	{0x461F, 0x06},
+	{0x4635, 0x07},
+	{0x4637, 0x30},
+	{0x463F, 0x18},
+	{0x4641, 0x0D},
+	{0x465B, 0x12},
+	{0x465F, 0x11},
+	{0x4663, 0x11},
+	{0x4667, 0x0F},
+	{0x466F, 0x0F},
+	{0x470E, 0x09},
+	{0x4909, 0xAB},
+	{0x490B, 0x95},
+	{0x4915, 0x5D},
+	{0x4A5F, 0xFF},
+	{0x4A61, 0xFF},
+	{0x4A73, 0x62},
+	{0x4A85, 0x00},
+	{0x4A87, 0xFF},
+
+	/* embedded data */
+	{0x5041, 0x04},
+	{0x583C, 0x04},
+	{0x620E, 0x04},
+	{0x6EB2, 0x01},
+	{0x6EB3, 0x00},
+	{0x9300, 0x02},
+
+	/* imagequality */
+	/* HDR setting */
+	{0x3001, 0x07},
+	{0x6D12, 0x3F},
+	{0x6D13, 0xFF},
+	{0x9344, 0x03},
+	{0x9706, 0x10},
+	{0x9707, 0x03},
+	{0x9708, 0x03},
+	{0x9E04, 0x01},
+	{0x9E05, 0x00},
+	{0x9E0C, 0x01},
+	{0x9E0D, 0x02},
+	{0x9E24, 0x00},
+	{0x9E25, 0x8C},
+	{0x9E26, 0x00},
+	{0x9E27, 0x94},
+	{0x9E28, 0x00},
+	{0x9E29, 0x96},
+
+	/* CNR parameter setting */
+	{0x69DB, 0x01},
+
+	/* Moire reduction */
+	{0x6957, 0x01},
+
+	/* image enhancment */
+	{0x6987, 0x17},
+	{0x698A, 0x03},
+	{0x698B, 0x03},
+
+	/* white balanace */
+	{0x0B8E, 0x01},
+	{0x0B8F, 0x00},
+	{0x0B90, 0x01},
+	{0x0B91, 0x00},
+	{0x0B92, 0x01},
+	{0x0B93, 0x00},
+	{0x0B94, 0x01},
+	{0x0B95, 0x00},
+
+	/* ATR setting */
+	{0x6E50, 0x00},
+	{0x6E51, 0x32},
+	{0x9340, 0x00},
+	{0x9341, 0x3C},
+	{0x9342, 0x03},
+	{0x9343, 0xFF},
+	{IMX214_TABLE_END, 0x00}
+};
+
+static const imx214_reg imx214_pll_1080mbps[] = {
+	{IMX214_TABLE_WAIT_MS, IMX214_WAIT_MS},
+	{ 0x0301, 0x05 }, // vt pixel clock divider = 5
+	{ 0x0303, 0x02 }, // vt system clock divider = 2
+	{ 0x0305, 0x03 }, // pre pll clock divider = 3
+	{ 0x0306, 0x00 }, // pll mult 10:8 = 0
+	{ 0x0307, 0x87 }, // pll mult 0:7 = 135
+	{ 0x0309, 0x0a }, // output pixel clock divider = 10
+	{ 0x030B, 0x01 }, // output system clock div = 1 .. OPCLK = 24 / 3(pre_vt) * 135(mpy_vt) / 1(op_sys_div) / 10(op_x_div) = 108MHz
+	{ 0x0310, 0x00 }, // PLL multiple driver = 0 -> 1 PLL control
+	{ 0x0820, 0x10 }, // target freq 31:24 = 16
+	{ 0x0821, 0xe0 }, // 23:16 = 224
+	{ 0x0822, 0x66 }, // 15:8 = 102
+	{ 0x0823, 0x66 }, // 7:0 = 102 ... target freq = 283141734
+	{ 0x3A03, 0x09 },
+	{ 0x3A04, 0x40 },
+	{ 0x3A05, 0x01 },
+	{IMX214_TABLE_END, 0x00}
+};
+
+static const imx214_reg imx214_pll_1200mbps[] = {
+	{IMX214_TABLE_WAIT_MS, IMX214_WAIT_MS},
+	{ 0x0301, 0x05 }, // vt pixel clock divider = 5
+	{ 0x0303, 0x02 }, // vt system clock divider = 2
+	{ 0x0305, 0x03 }, // pre pll clock divider = 3
+	{ 0x0306, 0x00 }, // pll mult 10:8 = 0
+	{ 0x0307, 0x96 }, // pll mult 0:7 = 150
+	{ 0x0309, 0x0a }, // output pixel clock divider = 10
+	{ 0x030B, 0x01 }, // output system clock div = 1 .. OPCLK = 24 / 3(pre_vt) * 150(mpy_vt) / 1(op_sys_div) / 10(op_x_div) = 120MHz
+	{ 0x0310, 0x00 }, // PLL multiple driver = 0 -> 1 PLL control
+	{ 0x0820, 0x12 }, // target freq 31:24 = 18
+	{ 0x0821, 0xc0 }, // 23:16 = 192
+	{ 0x0822, 0x66 }, // 15:8 = 102
+	{ 0x0823, 0x66 }, // 7:0 = 102 ... target freq = 314599014
+	{ 0x3A03, 0x09 },
+	{ 0x3A04, 0x40 },
+	{ 0x3A05, 0x01 },
+	{IMX214_TABLE_END, 0x00}
+};
+
+static const imx214_reg mode_4096x2304[] = {
+    {IMX214_TABLE_WAIT_MS, IMX214_WAIT_MS},
+    { 0x0301, 0x05 }, // vt pixel clock divider = 5
+    { 0x0303, 0x02 }, // vt system clock divider = 2
+    { 0x0305, 0x03 }, // pre pll clock divider = 3
+    { 0x0306, 0x00 }, // pll mult 10:8 = 0
+    { 0x0307, 0x96 }, // pll mult 0:7 = 150
+    { 0x0309, 0x0a }, // output pixel clock divider = 10
+    { 0x030B, 0x01 }, // output system clock div = 1 .. OPCLK = 24 / 3(pre_vt) * 150(mpy_vt) / 1(op_sys_div) / 10(op_x_div) = 120MHz
+    { 0x0310, 0x00 }, // PLL multiple driver = 0 -> 1 PLL control
+    { 0x0820, 0x12 }, // target freq 31:24 = 18
+    { 0x0821, 0xc0 }, // 23:16 = 192
+    { 0x0822, 0x66 }, // 15:8 = 102
+    { 0x0823, 0x66 }, // 7:0 = 102 ... target freq = 314599014
+    { 0x3A03, 0x09 },
+    { 0x3A04, 0x40 },
+    { 0x3A05, 0x01 },
+
+	{0x0114, 0x03},
+	{0x0220, 0x00},
+	{0x0221, 0x11},
+	{0x0222, 0x01},
+	{0x0340, 0x0C},
+	{0x0341, 0x7A},
+	{0x0342, 0x13},
+	{0x0343, 0x90},
+	{0x0344, 0x00},
+	{0x0345, 0x38},
+	{0x0346, 0x01},
+	{0x0347, 0x98},
+	{0x0348, 0x10},
+	{0x0349, 0x37},
+	{0x034A, 0x0A},
+	{0x034B, 0x97},
+	{0x0381, 0x01},
+	{0x0383, 0x01},
+	{0x0385, 0x01},
+	{0x0387, 0x01},
+	{0x0900, 0x00},
+	{0x0901, 0x00},
+	{0x0902, 0x00},
+	{0x3000, 0x35},
+	{0x3054, 0x01},
+	{0x305C, 0x11},
+
+	{0x0112, 0x0A},
+	{0x0113, 0x0A},
+	{0x034C, 0x10},
+	{0x034D, 0x00},
+	{0x034E, 0x09},
+	{0x034F, 0x00},
+	{0x0401, 0x00},
+	{0x0404, 0x00},
+	{0x0405, 0x10},
+	{0x0408, 0x00},
+	{0x0409, 0x00},
+	{0x040A, 0x00},
+	{0x040B, 0x00},
+	{0x040C, 0x10},
+	{0x040D, 0x00},
+	{0x040E, 0x09},
+	{0x040F, 0x00},
+
+	{0x0301, 0x05},
+	{0x0303, 0x02},
+	{0x0305, 0x03},
+	{0x0306, 0x00},
+	{0x0307, 0x96},
+	{0x0309, 0x0A},
+	{0x030B, 0x01},
+	{0x0310, 0x00},
+
+	{0x0820, 0x12},
+	{0x0821, 0xC0},
+	{0x0822, 0x00},
+	{0x0823, 0x00},
+
+	{0x3A03, 0x09},
+	{0x3A04, 0x50},
+	{0x3A05, 0x01},
+
+	{0x0B06, 0x01},
+	{0x30A2, 0x00},
+
+	{0x30B4, 0x00},
+
+	{0x3A02, 0xFF},
+
+	{0x3011, 0x00},
+	{0x3013, 0x01},
+
+	{0x0202, 0x0C},
+	{0x0203, 0x70},
+	{0x0224, 0x01},
+	{0x0225, 0xF4},
+
+	{0x0204, 0x00},
+	{0x0205, 0x00},
+	{0x020E, 0x01},
+	{0x020F, 0x00},
+	{0x0210, 0x01},
+	{0x0211, 0x00},
+	{0x0212, 0x01},
+	{0x0213, 0x00},
+	{0x0214, 0x01},
+	{0x0215, 0x00},
+	{0x0216, 0x00},
+	{0x0217, 0x00},
+
+	{0x4170, 0x00},
+	{0x4171, 0x10},
+	{0x4176, 0x00},
+	{0x4177, 0x3C},
+	{0xAE20, 0x04},
+	{0xAE21, 0x5C},
+
+	{IMX214_TABLE_WAIT_MS, 10},
+	{0x0138, 0x01},
+
+	/* stream on */
+	{0x0100, 0x01},
+	{IMX214_TABLE_END, 0x00}
+};
+
+//	{ 0x0103, 0x01 },
+static const imx214_reg mode_4208x3120[] = {
+    {IMX214_TABLE_WAIT_MS, IMX214_WAIT_MS},
+	{ 0x0301, 0x05 }, // vt pixel clock divider = 5
+	{ 0x0303, 0x02 }, // vt system clock divider = 2
+	{ 0x0305, 0x03 }, // pre pll clock divider = 3
+	{ 0x0306, 0x00 }, // pll mult 10:8 = 0
+	{ 0x0307, 0x96 }, // pll mult 0:7 = 150
+	{ 0x0309, 0x0a }, // output pixel clock divider = 10
+	{ 0x030B, 0x01 }, // output system clock div = 1 .. OPCLK = 24 / 3(pre_vt) * 150(mpy_vt) / 1(op_sys_div) / 10(op_x_div) = 120MHz
+	{ 0x0310, 0x00 }, // PLL multiple driver = 0 -> 1 PLL control
+	{ 0x0820, 0x12 }, // target freq 31:24 = 18
+	{ 0x0821, 0xc0 }, // 23:16 = 192
+	{ 0x0822, 0x66 }, // 15:8 = 102
+	{ 0x0823, 0x66 }, // 7:0 = 102 ... target freq = 314599014
+	{ 0x3A03, 0x09 },
+	{ 0x3A04, 0x40 },
+	{ 0x3A05, 0x01 },
+    { 0x0100, 0x00 },
+	{ 0x0114, 0x03 },
+	{ 0x0220, 0x00 },
+	{ 0x0221, 0x11 },
+	{ 0x0222, 0x01 },
+	{ 0x0344, 0x00 },
+	{ 0x0345, 0x00 },
+	{ 0x0346, 0x00 },
+	{ 0x0347, 0x00 },
+	{ 0x0348, 0x10 },
+	{ 0x0349, 0x6F },
+	{ 0x034A, 0x0C },
+	{ 0x034B, 0x2F },
+	{ 0x0381, 0x01 },
+	{ 0x0383, 0x01 },
+	{ 0x0385, 0x01 },
+	{ 0x0387, 0x01 },
+	{ 0x0900, 0x00 },
+	{ 0x0901, 0x00 },
+	{ 0x0902, 0x00 },
+	{ 0x3000, 0x35 },
+	{ 0x3054, 0x01 },
+	{ 0x305C, 0x11 },
+	{ 0x034C, 0x10 },
+	{ 0x034D, 0x70 },
+	{ 0x034E, 0x0C },
+	{ 0x034F, 0x30 },
+	{ 0x0401, 0x00 },
+	{ 0x0404, 0x00 },
+	{ 0x0405, 0x10 },
+	{ 0x0408, 0x00 },
+	{ 0x0409, 0x00 },
+	{ 0x040A, 0x00 },
+	{ 0x040B, 0x00 },
+	{ 0x040C, 0x10 },
+	{ 0x040D, 0x70 },
+	{ 0x040E, 0x0C },
+	{ 0x040F, 0x30 },
+	{ 0x3A03, 0x09 },
+	{ 0x3A04, 0x40 },
+	{ 0x3A05, 0x01 },
+	{ 0x0B06, 0x01 },
+	{ 0x30A2, 0x00 },
+	{ 0x30B4, 0x00 },
+	{ 0x3A02, 0xFF },
+	{ 0x3011, 0x00 },
+	{ 0x3013, 0x01 },
+	{ 0x0224, 0x01 },
+	{ 0x0225, 0xF4 },
+	{ 0x020E, 0x01 },
+	{ 0x020F, 0x00 },
+	{ 0x0210, 0x01 },
+	{ 0x0211, 0x00 },
+	{ 0x0212, 0x01 },
+	{ 0x0213, 0x00 },
+	{ 0x0214, 0x01 },
+	{ 0x0215, 0x00 },
+	{ 0x0216, 0x00 },
+	{ 0x0217, 0x00 },
+	{ 0x4170, 0x00 },
+	{ 0x4171, 0x10 },
+	{ 0x4176, 0x00 },
+	{ 0x4177, 0x3C },
+	{ 0xAE20, 0x04 },
+	{ 0xAE21, 0x5C },
+	{ 0x0138, 0x01 },
+	{IMX214_TABLE_END, 0x00}
+};
+
+static const imx214_reg mode_2104x1560[] = {
+    {IMX214_TABLE_WAIT_MS, IMX214_WAIT_MS},
+	{ 0x0301, 0x05 }, // vt pixel clock divider = 5
+	{ 0x0303, 0x02 }, // vt system clock divider = 2
+	{ 0x0305, 0x03 }, // pre pll clock divider = 3
+	{ 0x0306, 0x00 }, // pll mult 10:8 = 0
+	{ 0x0307, 0x96 }, // pll mult 0:7 = 150
+	{ 0x0309, 0x0a }, // output pixel clock divider = 10
+	{ 0x030B, 0x01 }, // output system clock div = 1 .. OPCLK = 24 / 3(pre_vt) * 150(mpy_vt) / 1(op_sys_div) / 10(op_x_div) = 120MHz
+	{ 0x0310, 0x00 }, // PLL multiple driver = 0 -> 1 PLL control
+	{ 0x0820, 0x12 }, // target freq 31:24 = 18
+	{ 0x0821, 0xc0 }, // 23:16 = 192
+	{ 0x0822, 0x66 }, // 15:8 = 102
+	{ 0x0823, 0x66 }, // 7:0 = 102 ... target freq = 314599014
+	{ 0x3A03, 0x09 },
+	{ 0x3A04, 0x40 },
+	{ 0x3A05, 0x01 },
+	{ 0x0100, 0x00 },
+	{ 0x0136, 0x18 }, /*24Mhz*/
+	{ 0x0137, 0x00 },
+	{ 0x0101, 0x00 },
+	{ 0x0105, 0x01 }, // switched from 0x01 to 0x00
+	{ 0x5041, 0x04 }, // no EMD
+	{ 0x0138, 0x01 },
+	{ 0x0106, 0x01 },
+	{ 0x4550, 0x02 },
+	{ 0x4601, 0x00 },
+	{ 0x4642, 0x05 },
+	{ 0x6227, 0x11 },
+	{ 0x6276, 0x00 },
+	{ 0x900E, 0x06 },
+	{ 0xA802, 0x90 },
+	{ 0xA803, 0x11 },
+	{ 0xA804, 0x62 },
+	{ 0xA805, 0x77 },
+	{ 0xA806, 0xAE },
+	{ 0xA807, 0x34 },
+	{ 0xA808, 0xAE },
+	{ 0xA809, 0x35 },
+	{ 0xA80A, 0x62 },
+	{ 0xA80B, 0x83 },
+	{ 0xAE33, 0x00 },
+	{ 0x4174, 0x00 },
+	{ 0x4175, 0x11 },
+	{ 0x4612, 0x29 },
+	{ 0x461B, 0x12 },
+	{ 0x461F, 0x06 },
+	{ 0x4635, 0x07 },
+	{ 0x4637, 0x30 },
+	{ 0x463F, 0x18 },
+	{ 0x4641, 0x0D },
+	{ 0x465B, 0x12 },
+	{ 0x465F, 0x11 },
+	{ 0x4663, 0x11 },
+	{ 0x4667, 0x0F },
+	{ 0x466F, 0x0F },
+	{ 0x470E, 0x09 },
+	{ 0x4909, 0xAB },
+	{ 0x490B, 0x95 },
+	{ 0x4915, 0x5D },
+	{ 0x4A5F, 0xFF },
+	{ 0x4A61, 0xFF },
+	{ 0x4A73, 0x62 },
+	{ 0x4A85, 0x00 },
+	{ 0x4A87, 0xFF },
+	{ 0x583C, 0x04 },
+	{ 0x620E, 0x04 },
+	{ 0x6EB2, 0x01 },
+	{ 0x6EB3, 0x00 },
+	{ 0x9300, 0x02 }, // end of power up
+	{ 0x0114, 0x03 },
+	{ 0x0220, 0x00 },
+	{ 0x0221, 0x11 },
+	{ 0x0222, 0x01 },
+	{ 0x0344, 0x00 },
+	{ 0x0345, 0x00 },
+	{ 0x0346, 0x00 },
+	{ 0x0347, 0x00 },
+	{ 0x0348, 0x10 },
+	{ 0x0349, 0x6F },
+	{ 0x034A, 0x0C },
+	{ 0x034B, 0x2F },
+	{ 0x0381, 0x01 },
+	{ 0x0383, 0x01 },
+	{ 0x0385, 0x01 },
+	{ 0x0387, 0x01 },
+	{ 0x0900, 0x01 },
+	{ 0x0901, 0x22 },
+	{ 0x0902, 0x02 },
+	{ 0x3000, 0x35 },
+	{ 0x3054, 0x01 },
+	{ 0x305C, 0x11 },
+	{ 0x034C, 0x08 },
+	{ 0x034D, 0x38 },
+	{ 0x034E, 0x06 },
+	{ 0x034F, 0x18 },
+	{ 0x0401, 0x00 },
+	{ 0x0404, 0x00 },
+	{ 0x0405, 0x10 },
+	{ 0x0408, 0x00 },
+	{ 0x0409, 0x00 },
+	{ 0x040A, 0x00 },
+	{ 0x040B, 0x00 },
+	{ 0x040C, 0x08 },
+	{ 0x040D, 0x38 },
+	{ 0x040E, 0x06 },
+	{ 0x040F, 0x18 },
+	{ 0x0B06, 0x01 },
+	{ 0x30A2, 0x00 },
+	{ 0x30B4, 0x00 },
+	{ 0x3A02, 0xFF },
+	{ 0x3011, 0x00 },
+	{ 0x3013, 0x01 },
+	{ 0x0224, 0x01 },
+	{ 0x0225, 0xF4 },
+	{ 0x020E, 0x01 },
+	{ 0x020F, 0x00 },
+	{ 0x0210, 0x01 },
+	{ 0x0211, 0x00 },
+	{ 0x0212, 0x01 },
+	{ 0x0213, 0x00 },
+	{ 0x0214, 0x01 },
+	{ 0x0215, 0x00 },
+	{ 0x0216, 0x00 },
+	{ 0x0217, 0x00 },
+	{ 0x4170, 0x00 },
+	{ 0x4171, 0x10 },
+	{ 0x4176, 0x00 },
+	{ 0x4177, 0x3C },
+	{ 0xAE20, 0x04 },
+	{ 0xAE21, 0x5C },
+	{ 0x0138, 0x01 },
+	{IMX214_TABLE_END, 0x00}
+};
+
+static const imx214_reg mode_1920x1080[] = {
+    {IMX214_TABLE_WAIT_MS, IMX214_WAIT_MS},
+	{ 0x0301, 0x05 }, // vt pixel clock divider = 5
+	{ 0x0303, 0x02 }, // vt system clock divider = 2
+	{ 0x0305, 0x03 }, // pre pll clock divider = 3
+	{ 0x0306, 0x00 }, // pll mult 10:8 = 0
+	{ 0x0307, 0x96 }, // pll mult 0:7 = 150
+	{ 0x0309, 0x0a }, // output pixel clock divider = 10
+	{ 0x030B, 0x01 }, // output system clock div = 1 .. OPCLK = 24 / 3(pre_vt) * 150(mpy_vt) / 1(op_sys_div) / 10(op_x_div) = 120MHz
+	{ 0x0310, 0x00 }, // PLL multiple driver = 0 -> 1 PLL control
+	{ 0x0820, 0x12 }, // target freq 31:24 = 18
+	{ 0x0821, 0xc0 }, // 23:16 = 192
+	{ 0x0822, 0x66 }, // 15:8 = 102
+	{ 0x0823, 0x66 }, // 7:0 = 102 ... target freq = 314599014
+	{ 0x3A03, 0x09 },
+	{ 0x3A04, 0x40 },
+	{ 0x3A05, 0x01 },
+	{ 0x0100, 0x00 },
+	{ 0x0136, 0x18 }, /*24Mhz*/
+	{ 0x0137, 0x00 },
+	{ 0x0101, 0x00 },
+	{ 0x0105, 0x01 }, // switched from 0x01 to 0x00
+	{ 0x5041, 0x04 }, // no EMD
+	{ 0x0138, 0x01 },
+	{ 0x0106, 0x01 },
+	{ 0x4550, 0x02 },
+	{ 0x4601, 0x00 },
+	{ 0x4642, 0x05 },
+	{ 0x6227, 0x11 },
+	{ 0x6276, 0x00 },
+	{ 0x900E, 0x06 },
+	{ 0xA802, 0x90 },
+	{ 0xA803, 0x11 },
+	{ 0xA804, 0x62 },
+	{ 0xA805, 0x77 },
+	{ 0xA806, 0xAE },
+	{ 0xA807, 0x34 },
+	{ 0xA808, 0xAE },
+	{ 0xA809, 0x35 },
+	{ 0xA80A, 0x62 },
+	{ 0xA80B, 0x83 },
+	{ 0xAE33, 0x00 },
+	{ 0x4174, 0x00 },
+	{ 0x4175, 0x11 },
+	{ 0x4612, 0x29 },
+	{ 0x461B, 0x12 },
+	{ 0x461F, 0x06 },
+	{ 0x4635, 0x07 },
+	{ 0x4637, 0x30 },
+	{ 0x463F, 0x18 },
+	{ 0x4641, 0x0D },
+	{ 0x465B, 0x12 },
+	{ 0x465F, 0x11 },
+	{ 0x4663, 0x11 },
+	{ 0x4667, 0x0F },
+	{ 0x466F, 0x0F },
+	{ 0x470E, 0x09 },
+	{ 0x4909, 0xAB },
+	{ 0x490B, 0x95 },
+	{ 0x4915, 0x5D },
+	{ 0x4A5F, 0xFF },
+	{ 0x4A61, 0xFF },
+	{ 0x4A73, 0x62 },
+	{ 0x4A85, 0x00 },
+	{ 0x4A87, 0xFF },
+	{ 0x583C, 0x04 },
+	{ 0x620E, 0x04 },
+	{ 0x6EB2, 0x01 },
+	{ 0x6EB3, 0x00 },
+	{ 0x9300, 0x02 }, // end of power up
+	{ 0x0114, 0x03 },
+	{ 0x0220, 0x00 },
+	{ 0x0221, 0x11 },
+	{ 0x0222, 0x01 },
+	{ 0x0344, 0x00 }, // image size
+	{ 0x0345, 0xB8 },
+	{ 0x0346, 0x01 },
+	{ 0x0347, 0xE0 },
+	{ 0x0348, 0x0F },
+	{ 0x0349, 0xB7 },
+	{ 0x034A, 0x0A },
+	{ 0x034B, 0x4F },
+	{ 0x0381, 0x01 },
+	{ 0x0383, 0x01 },
+	{ 0x0385, 0x01 },
+	{ 0x0387, 0x01 },
+	{ 0x0900, 0x01 }, // 2x2 binning
+	{ 0x0901, 0x22 },
+	{ 0x0902, 0x02 },
+	{ 0x3000, 0x35 },
+	{ 0x3054, 0x01 },
+	{ 0x305C, 0x11 },
+	{ 0x034C, 0x07 },
+	{ 0x034D, 0x80 },
+	{ 0x034E, 0x04 },
+	{ 0x034F, 0x38 },
+	{ 0x0401, 0x00 },
+	{ 0x0404, 0x00 },
+	{ 0x0405, 0x10 },
+	{ 0x0408, 0x00 },
+	{ 0x0409, 0x00 },
+	{ 0x040A, 0x00 },
+	{ 0x040B, 0x00 },
+	{ 0x040C, 0x07 },
+	{ 0x040D, 0x80 },
+	{ 0x040E, 0x04 },
+	{ 0x040F, 0x38 },
+	{ 0x3A03, 0x08 },
+	{ 0x3A04, 0x68 },
+	{ 0x3A05, 0x01 },
+	{ 0x0B06, 0x01 },
+	{ 0x30A2, 0x00 },
+	{ 0x30B4, 0x00 },
+	{ 0x3A02, 0xFF },
+	{ 0x3011, 0x00 },
+	{ 0x3013, 0x01 },
+	{ 0x0224, 0x01 },
+	{ 0x0225, 0xF4 },
+	{ 0x020E, 0x01 },
+	{ 0x020F, 0x00 },
+	{ 0x0210, 0x01 },
+	{ 0x0211, 0x00 },
+	{ 0x0212, 0x01 },
+	{ 0x0213, 0x00 },
+	{ 0x0214, 0x01 },
+	{ 0x0215, 0x00 },
+	{ 0x0216, 0x00 },
+	{ 0x0217, 0x00 },
+	{ 0x4170, 0x00 },
+	{ 0x4171, 0x10 },
+	{ 0x4176, 0x00 },
+	{ 0x4177, 0x3C },
+	{ 0xAE20, 0x04 },
+	{ 0xAE21, 0x5C },
+	{ 0x0138, 0x01 },
+	{IMX214_TABLE_END, 0x00}
+};
+
+static const imx214_reg mode_1280x720[] = {
+    {IMX214_TABLE_WAIT_MS, IMX214_WAIT_MS},
+    { 0x0301, 0x05 }, // vt pixel clock divider = 5
+    { 0x0303, 0x02 }, // vt system clock divider = 2
+    { 0x0305, 0x03 }, // pre pll clock divider = 3
+    { 0x0306, 0x00 }, // pll mult 10:8 = 0
+    { 0x0307, 0x96 }, // pll mult 0:7 = 150
+    { 0x0309, 0x0a }, // output pixel clock divider = 10
+    { 0x030B, 0x01 }, // output system clock div = 1 .. OPCLK = 24 / 3(pre_vt) * 150(mpy_vt) / 1(op_sys_div) / 10(op_x_div) = 120MHz
+    { 0x0310, 0x00 }, // PLL multiple driver = 0 -> 1 PLL control
+    { 0x0820, 0x12 }, // target freq 31:24 = 18
+    { 0x0821, 0xc0 }, // 23:16 = 192
+    { 0x0822, 0x66 }, // 15:8 = 102
+    { 0x0823, 0x66 }, // 7:0 = 102 ... target freq = 314599014
+    { 0x3A03, 0x09 },
+    { 0x3A04, 0x40 },
+    { 0x3A05, 0x01 },
+	{ 0x0100, 0x00 },
+	{ 0x0136, 0x18 }, /*24Mhz*/
+	{ 0x0137, 0x00 },
+	{ 0x0101, 0x00 },
+	{ 0x0105, 0x01 }, // switched from 0x01 to 0x00
+	{ 0x5041, 0x04 }, // no EMD
+	{ 0x0138, 0x01 },
+	{ 0x0106, 0x01 },
+	{ 0x4550, 0x02 },
+	{ 0x4601, 0x00 },
+	{ 0x4642, 0x05 },
+	{ 0x6227, 0x11 },
+	{ 0x6276, 0x00 },
+	{ 0x900E, 0x06 },
+	{ 0xA802, 0x90 },
+	{ 0xA803, 0x11 },
+	{ 0xA804, 0x62 },
+	{ 0xA805, 0x77 },
+	{ 0xA806, 0xAE },
+	{ 0xA807, 0x34 },
+	{ 0xA808, 0xAE },
+	{ 0xA809, 0x35 },
+	{ 0xA80A, 0x62 },
+	{ 0xA80B, 0x83 },
+	{ 0xAE33, 0x00 },
+	{ 0x4174, 0x00 },
+	{ 0x4175, 0x11 },
+	{ 0x4612, 0x29 },
+	{ 0x461B, 0x12 },
+	{ 0x461F, 0x06 },
+	{ 0x4635, 0x07 },
+	{ 0x4637, 0x30 },
+	{ 0x463F, 0x18 },
+	{ 0x4641, 0x0D },
+	{ 0x465B, 0x12 },
+	{ 0x465F, 0x11 },
+	{ 0x4663, 0x11 },
+	{ 0x4667, 0x0F },
+	{ 0x466F, 0x0F },
+	{ 0x470E, 0x09 },
+	{ 0x4909, 0xAB },
+	{ 0x490B, 0x95 },
+	{ 0x4915, 0x5D },
+	{ 0x4A5F, 0xFF },
+	{ 0x4A61, 0xFF },
+	{ 0x4A73, 0x62 },
+	{ 0x4A85, 0x00 },
+	{ 0x4A87, 0xFF },
+	{ 0x583C, 0x04 },
+	{ 0x620E, 0x04 },
+	{ 0x6EB2, 0x01 },
+	{ 0x6EB3, 0x00 },
+	{ 0x9300, 0x02 }, // end of power up
+	{ 0x0114, 0x03 },
+	{ 0x0220, 0x00 },
+	{ 0x0221, 0x11 },
+	{ 0x0222, 0x01 },
+    { 0x0344, 0x05 }, // image size
+	{ 0x0345, 0xB8 },
+	{ 0x0346, 0x04 },
+	{ 0x0347, 0xB0 },
+	{ 0x0348, 0x0A },
+	{ 0x0349, 0xB7 },
+	{ 0x034A, 0x07 },
+	{ 0x034B, 0x7F },
+	{ 0x0381, 0x01 },
+	{ 0x0383, 0x01 },
+	{ 0x0385, 0x01 },
+	{ 0x0387, 0x01 },
+	{ 0x0900, 0x00 }, // no binning
+	{ 0x0901, 0x00 },
+	{ 0x0902, 0x00 },
+	{ 0x3000, 0x35 },
+	{ 0x3054, 0x01 },
+	{ 0x305C, 0x11 },
+	{ 0x034C, 0x05 },
+	{ 0x034D, 0x00 },
+	{ 0x034E, 0x02 },
+	{ 0x034F, 0xD0 },
+	{ 0x0401, 0x00 },
+	{ 0x0404, 0x00 },
+	{ 0x0405, 0x10 },
+	{ 0x0408, 0x00 },
+	{ 0x0409, 0x00 },
+	{ 0x040A, 0x00 },
+	{ 0x040B, 0x00 },
+	{ 0x040C, 0x05 },
+	{ 0x040D, 0x00 },
+	{ 0x040E, 0x02 },
+	{ 0x040F, 0xD0 },
+	{ 0x3A03, 0x02 },
+	{ 0x3A04, 0xF8 },
+	{ 0x3A05, 0x00 },
+	{ 0x0B06, 0x01 },
+	{ 0x30A2, 0x00 },
+	{ 0x30B4, 0x00 },
+	{ 0x3A02, 0xFF },
+	{ 0x3011, 0x00 },
+	{ 0x3013, 0x01 },
+	{ 0x0224, 0x01 },
+	{ 0x0225, 0xF4 },
+	{ 0x020E, 0x01 },
+	{ 0x020F, 0x00 },
+	{ 0x0210, 0x01 },
+	{ 0x0211, 0x00 },
+	{ 0x0212, 0x01 },
+	{ 0x0213, 0x00 },
+	{ 0x0214, 0x01 },
+	{ 0x0215, 0x00 },
+	{ 0x0216, 0x00 },
+	{ 0x0217, 0x00 },
+	{ 0x4170, 0x00 },
+	{ 0x4171, 0x10 },
+	{ 0x4176, 0x00 },
+	{ 0x4177, 0x3C },
+	{ 0xAE20, 0x04 },
+	{ 0xAE21, 0x5C },
+	{ 0x0138, 0x01 },
+	{IMX214_TABLE_END, 0x00},
+};
+
+static const imx214_reg mode_2592x1944[] = {
+    {IMX214_TABLE_WAIT_MS, IMX214_WAIT_MS},
+	{ 0x0301, 0x05 }, // vt pixel clock divider = 5
+	{ 0x0303, 0x02 }, // vt system clock divider = 2
+	{ 0x0305, 0x03 }, // pre pll clock divider = 3
+	{ 0x0306, 0x00 }, // pll mult 10:8 = 0
+	{ 0x0307, 0x96 }, // pll mult 0:7 = 150
+	{ 0x0309, 0x0a }, // output pixel clock divider = 10
+	{ 0x030B, 0x01 }, // output system clock div = 1 .. OPCLK = 24 / 3(pre_vt) * 150(mpy_vt) / 1(op_sys_div) / 10(op_x_div) = 120MHz
+	{ 0x0310, 0x00 }, // PLL multiple driver = 0 -> 1 PLL control
+	{ 0x0820, 0x12 }, // target freq 31:24 = 18
+	{ 0x0821, 0xc0 }, // 23:16 = 192
+	{ 0x0822, 0x66 }, // 15:8 = 102
+	{ 0x0823, 0x66 }, // 7:0 = 102 ... target freq = 314599014
+	{ 0x3A03, 0x09 },
+	{ 0x3A04, 0x40 },
+	{ 0x3A05, 0x01 },
+	{0x0100, 0x00},/* Including sw reset */
+	{0x3001, 0x0a},
+	{0x3002, 0x80},
+	{0x3006, 0x00},
+	{0x3011, 0x21},
+	{0x3012, 0x09},
+	{0x3013, 0x10},
+	{0x3014, 0x00},
+	{0x3015, 0x08},
+	{0x3016, 0xf0},
+	{0x3017, 0xf0},
+	{0x3018, 0xf0},
+	{0x301b, 0xb4},
+	{0x301d, 0x02},
+	{0x3021, 0x00},
+	{0x3022, 0x01},
+	{0x3028, 0x44},
+	{0x3090, 0x02},
+	{0x3091, 0x0e},
+	{0x3092, 0x00},
+	{0x3093, 0x00},
+	{0x3098, 0x03},
+	{0x3099, 0x1e},
+	{0x309a, 0x02},
+	{0x309b, 0x01},
+	{0x309c, 0x00},
+	{0x30a0, 0xd2},
+	{0x30a2, 0x01},
+	{0x30b2, 0x00},
+	{0x30b3, 0x68},
+	{0x30b4, 0x03},
+	{0x30b5, 0x04},
+	{0x30b6, 0x01},
+	{0x3104, 0x21},
+	{0x3106, 0x00},
+	{0x3406, 0x01},
+	{0x3500, 0x00},
+	{0x3501, 0x7b},
+	{0x3502, 0x00},
+	{0x3503, 0x07},
+	{0x3504, 0x00},
+	{0x3505, 0x00},
+	{0x3506, 0x00},
+	{0x3507, 0x02},
+	{0x3508, 0x00},
+	{0x3509, 0x10},
+	{0x350a, 0x00},
+	{0x350b, 0x40},
+	{0x3601, 0x0a},
+	{0x3602, 0x18},
+	{0x3612, 0x80},
+	{0x3620, 0x54},
+	{0x3621, 0xc7},
+	{0x3622, 0x0f},
+	{0x3625, 0x10},
+	{0x3630, 0x55},
+	{0x3631, 0xf4},
+	{0x3632, 0x00},
+	{0x3633, 0x34},
+	{0x3634, 0x02},
+	{0x364d, 0x0d},
+	{0x364f, 0xdd},
+	{0x3660, 0x04},
+	{0x3662, 0x10},
+	{0x3663, 0xf1},
+	{0x3665, 0x00},
+	{0x3666, 0x20},
+	{0x3667, 0x00},
+	{0x366a, 0x80},
+	{0x3680, 0xe0},
+	{0x3681, 0x00},
+	{0x3700, 0x42},
+	{0x3701, 0x14},
+	{0x3702, 0xa0},
+	{0x3703, 0xd8},
+	{0x3704, 0x78},
+	{0x3705, 0x02},
+	{0x3708, 0xe2},
+	{0x3709, 0xc3},
+	{0x370a, 0x00},
+	{0x370b, 0x20},
+	{0x370c, 0x0c},
+	{0x370d, 0x11},
+	{0x370e, 0x00},
+	{0x370f, 0x40},
+	{0x3710, 0x00},
+	{0x371a, 0x1c},
+	{0x371b, 0x05},
+	{0x371c, 0x01},
+	{0x371e, 0xa1},
+	{0x371f, 0x0c},
+	{0x3721, 0x00},
+	{0x3724, 0x10},
+	{0x3726, 0x00},
+	{0x372a, 0x01},
+	{0x3730, 0x10},
+	{0x3738, 0x22},
+	{0x3739, 0xe5},
+	{0x373a, 0x50},
+	{0x373b, 0x02},
+	{0x373c, 0x41},
+	{0x373f, 0x02},
+	{0x3740, 0x42},
+	{0x3741, 0x02},
+	{0x3742, 0x18},
+	{0x3743, 0x01},
+	{0x3744, 0x02},
+	{0x3747, 0x10},
+	{0x374c, 0x04},
+	{0x3751, 0xf0},
+	{0x3752, 0x00},
+	{0x3753, 0x00},
+	{0x3754, 0xc0},
+	{0x3755, 0x00},
+	{0x3756, 0x1a},
+	{0x3758, 0x00},
+	{0x3759, 0x0f},
+	{0x376b, 0x44},
+	{0x375c, 0x04},
+	{0x3776, 0x00},
+	{0x377f, 0x08},
+	{0x3780, 0x22},
+	{0x3781, 0x0c},
+	{0x3784, 0x2c},
+	{0x3785, 0x1e},
+	{0x378f, 0xf5},
+	{0x3791, 0xb0},
+	{0x3795, 0x00},
+	{0x3796, 0x64},
+	{0x3797, 0x11},
+	{0x3798, 0x30},
+	{0x3799, 0x41},
+	{0x379a, 0x07},
+	{0x379b, 0xb0},
+	{0x379c, 0x0c},
+	{0x37c5, 0x00},
+	{0x37c6, 0x00},
+	{0x37c7, 0x00},
+	{0x37c9, 0x00},
+	{0x37ca, 0x00},
+	{0x37cb, 0x00},
+	{0x37de, 0x00},
+	{0x37df, 0x00},
+	{0x3800, 0x00},
+	{0x3801, 0x02},
+	{0x3802, 0x00},
+	{0x3803, 0x02},
+	{0x3804, 0x0a},
+	{0x3805, 0x41},
+	{0x3806, 0x07},
+	{0x3807, 0xa5},
+	{0x3808, 0x0a},
+	{0x3809, 0x20},
+	{0x380a, 0x07},
+	{0x380b, 0x98},
+	{0x380c, 0x0a},
+	{0x380d, 0x80},
+	{0x380e, 0x07},
+	{0x380f, 0xc0},
+	{0x3810, 0x00},
+	{0x3811, 0x02},
+	{0x3812, 0x00},
+	{0x3813, 0x02},
+	{0x3814, 0x11},
+	{0x3815, 0x11},
+	{0x3820, 0x00},
+	{0x3821, 0x1e},
+	{0x3823, 0x00},
+	{0x3824, 0x00},
+	{0x3825, 0x00},
+	{0x3826, 0x00},
+	{0x3827, 0x00},
+	{0x382a, 0x04},
+	{0x3a04, 0x06},
+	{0x3a05, 0x14},
+	{0x3a06, 0x00},
+	{0x3a07, 0xfe},
+	{0x3b00, 0x00},
+	{0x3b02, 0x00},
+	{0x3b03, 0x00},
+	{0x3b04, 0x00},
+	{0x3b05, 0x00},
+	{0x3d00, 0x00},
+	{0x3d01, 0x00},
+	{0x3d02, 0x00},
+	{0x3d03, 0x00},
+	{0x3d04, 0x00},
+	{0x3d05, 0x00},
+	{0x3d06, 0x00},
+	{0x3d07, 0x00},
+	{0x3d08, 0x00},
+	{0x3d09, 0x00},
+	{0x3d0a, 0x00},
+	{0x3d0b, 0x00},
+	{0x3d0c, 0x00},
+	{0x3d0d, 0x00},
+	{0x3d0e, 0x00},
+	{0x3d0f, 0x00},
+	{0x3d80, 0x00},
+	{0x3d81, 0x00},
+	{0x3d84, 0x00},
+	{0x3e07, 0x20},
+	{0x4000, 0x08},
+	{0x4001, 0x04},
+	{0x4002, 0x45},
+	{0x4004, 0x08},
+	{0x4005, 0x18},
+	{0x4006, 0x20},
+	{0x4008, 0x24},
+	{0x4009, 0x10},
+	{0x400c, 0x00},
+	{0x400d, 0x00},
+	{0x4058, 0x00},
+	{0x4101, 0xb2},
+	{0x4303, 0x00},
+	{0x4304, 0x08},
+	{0x4307, 0x30},
+	{0x4311, 0x04},
+	{0x4315, 0x01},
+	{0x4511, 0x05},
+	{0x4512, 0x01},
+	{0x4800, 0x20}, /* dis-continuous */
+	{0x4806, 0x00},
+	{0x4816, 0x52},
+	{0x481f, 0x30},
+	{0x4826, 0x32},
+	{0x4831, 0x6a},
+	{0x4d00, 0x04},
+	{0x4d01, 0x71},
+	{0x4d02, 0xfd},
+	{0x4d03, 0xf5},
+	{0x4d04, 0x0c},
+	{0x4d05, 0xcc},
+	{0x4837, 0x0a},
+	{0x5000, 0x06},
+	{0x5001, 0x01},
+	{0x5002, 0x00},
+	{0x5003, 0x20},
+	{0x5046, 0x0a},
+	{0x5013, 0x00},
+	{0x5046, 0x0a},
+	{0x5780, 0x1c},
+	{0x5786, 0x20},
+	{0x5787, 0x10},
+	{0x5788, 0x18},
+	{0x578a, 0x04},
+	{0x578b, 0x02},
+	{0x578c, 0x02},
+	{0x578e, 0x06},
+	{0x578f, 0x02},
+	{0x5790, 0x02},
+	{0x5791, 0xff},
+	{0x5842, 0x01},
+	{0x5843, 0x2b},
+	{0x5844, 0x01},
+	{0x5845, 0x92},
+	{0x5846, 0x01},
+	{0x5847, 0x8f},
+	{0x5848, 0x01},
+	{0x5849, 0x0c},
+	{0x5e00, 0x00},
+	{0x5e10, 0x0c},
+	{IMX214_TABLE_END, 0x0000}
+};
+
+static const imx214_reg mode_2592x1458[] = {
+    {IMX214_TABLE_WAIT_MS, IMX214_WAIT_MS},
+	{ 0x0301, 0x05 }, // vt pixel clock divider = 5
+	{ 0x0303, 0x02 }, // vt system clock divider = 2
+	{ 0x0305, 0x03 }, // pre pll clock divider = 3
+	{ 0x0306, 0x00 }, // pll mult 10:8 = 0
+	{ 0x0307, 0x96 }, // pll mult 0:7 = 150
+	{ 0x0309, 0x0a }, // output pixel clock divider = 10
+	{ 0x030B, 0x01 }, // output system clock div = 1 .. OPCLK = 24 / 3(pre_vt) * 150(mpy_vt) / 1(op_sys_div) / 10(op_x_div) = 120MHz
+	{ 0x0310, 0x00 }, // PLL multiple driver = 0 -> 1 PLL control
+	{ 0x0820, 0x12 }, // target freq 31:24 = 18
+	{ 0x0821, 0xc0 }, // 23:16 = 192
+	{ 0x0822, 0x66 }, // 15:8 = 102
+	{ 0x0823, 0x66 }, // 7:0 = 102 ... target freq = 314599014
+	{ 0x3A03, 0x09 },
+	{ 0x3A04, 0x40 },
+	{ 0x3A05, 0x01 },
+	{0x0100, 0x00},/* Including sw reset */
+	{0x3001, 0x0a},
+	{0x3002, 0x80},
+	{0x3006, 0x00},
+	{0x3011, 0x21},
+	{0x3012, 0x09},
+	{0x3013, 0x10},
+	{0x3014, 0x00},
+	{0x3015, 0x08},
+	{0x3016, 0xf0},
+	{0x3017, 0xf0},
+	{0x3018, 0xf0},
+	{0x301b, 0xb4},
+	{0x301d, 0x02},
+	{0x3021, 0x00},
+	{0x3022, 0x01},
+	{0x3028, 0x44},
+	{0x3098, 0x03},
+	{0x3099, 0x1e},
+	{0x309a, 0x02},
+	{0x309b, 0x01},
+	{0x309c, 0x00},
+	{0x30a0, 0xd2},
+	{0x30a2, 0x01},
+	{0x30b2, 0x00},
+	{0x30b3, 0x68},
+	{0x30b4, 0x03},
+	{0x30b5, 0x04},
+	{0x30b6, 0x01},
+	{0x3104, 0x21},
+	{0x3106, 0x00},
+	{0x3400, 0x04},
+	{0x3401, 0x00},
+	{0x3402, 0x04},
+	{0x3403, 0x00},
+	{0x3404, 0x04},
+	{0x3405, 0x00},
+	{0x3406, 0x01},
+	{0x3500, 0x00},
+	{0x3501, 0x7b},
+	{0x3502, 0x00},
+	{0x3503, 0x07},
+	{0x3504, 0x00},
+	{0x3505, 0x00},
+	{0x3506, 0x00},
+	{0x3507, 0x02},
+	{0x3508, 0x00},
+	{0x3509, 0x10},
+	{0x350a, 0x00},
+	{0x350b, 0x40},
+	{0x3600, 0xbc},
+	{0x3601, 0x0a},
+	{0x3602, 0x38},
+	{0x3612, 0x80},
+	{0x3620, 0x44},
+	{0x3621, 0xb5},
+	{0x3622, 0x0c},
+	{0x3625, 0x10},
+	{0x3630, 0x55},
+	{0x3631, 0xf4},
+	{0x3632, 0x00},
+	{0x3633, 0x34},
+	{0x3634, 0x02},
+	{0x364d, 0x0d},
+	{0x364f, 0xdd},
+	{0x3660, 0x04},
+	{0x3662, 0x10},
+	{0x3663, 0xf1},
+	{0x3665, 0x00},
+	{0x3666, 0x20},
+	{0x3667, 0x00},
+	{0x366a, 0x80},
+	{0x3680, 0xe0},
+	{0x3681, 0x00},
+	{0x3700, 0x42},
+	{0x3701, 0x14},
+	{0x3702, 0xa0},
+	{0x3703, 0xd8},
+	{0x3704, 0x78},
+	{0x3705, 0x02},
+	{0x3708, 0xe2},
+	{0x3709, 0xc3},
+	{0x370a, 0x00},
+	{0x370b, 0x20},
+	{0x370c, 0x0c},
+	{0x370d, 0x11},
+	{0x370e, 0x00},
+	{0x370f, 0x40},
+	{0x3710, 0x00},
+	{0x371a, 0x1c},
+	{0x371b, 0x05},
+	{0x371c, 0x01},
+	{0x371e, 0xa1},
+	{0x371f, 0x0c},
+	{0x3721, 0x00},
+	{0x3724, 0x10},
+	{0x3726, 0x00},
+	{0x372a, 0x01},
+	{0x3730, 0x10},
+	{0x3738, 0x22},
+	{0x3739, 0xe5},
+	{0x373a, 0x50},
+	{0x373b, 0x02},
+	{0x373c, 0x41},
+	{0x373f, 0x02},
+	{0x3740, 0x42},
+	{0x3741, 0x02},
+	{0x3742, 0x18},
+	{0x3743, 0x01},
+	{0x3744, 0x02},
+	{0x3747, 0x10},
+	{0x374c, 0x04},
+	{0x3751, 0xf0},
+	{0x3752, 0x00},
+	{0x3753, 0x00},
+	{0x3754, 0xc0},
+	{0x3755, 0x00},
+	{0x3756, 0x1a},
+	{0x3758, 0x00},
+	{0x3759, 0x0f},
+	{0x376b, 0x44},
+	{0x375c, 0x04},
+	{0x3774, 0x10},
+	{0x3776, 0x00},
+	{0x377f, 0x08},
+	{0x3780, 0x22},
+	{0x3781, 0x0c},
+	{0x3784, 0x2c},
+	{0x3785, 0x1e},
+	{0x378f, 0xf5},
+	{0x3791, 0xb0},
+	{0x3795, 0x00},
+	{0x3796, 0x64},
+	{0x3797, 0x11},
+	{0x3798, 0x30},
+	{0x3799, 0x41},
+	{0x379a, 0x07},
+	{0x379b, 0xb0},
+	{0x379c, 0x0c},
+	{0x37c5, 0x00},
+	{0x37c6, 0x00},
+	{0x37c7, 0x00},
+	{0x37c9, 0x00},
+	{0x37ca, 0x00},
+	{0x37cb, 0x00},
+	{0x37de, 0x00},
+	{0x37df, 0x00},
+	{0x3800, 0x00},
+	{0x3801, 0x00},
+	{0x3802, 0x00},
+	{0x3803, 0xf4},
+	{0x3804, 0x0a},
+	{0x3805, 0x3f},
+	{0x3806, 0x06},
+	{0x3807, 0xb1},
+	{0x3808, 0x0a},
+	{0x3809, 0x20},
+	{0x380a, 0x05},
+	{0x380b, 0xb2},
+	{0x380c, 0x0a},
+	{0x380d, 0x80},
+	{0x380e, 0x07},
+	{0x380f, 0xc0},
+	{0x3810, 0x00},
+	{0x3811, 0x10},
+	{0x3812, 0x00},
+	{0x3813, 0x06},
+	{0x3814, 0x11},
+	{0x3815, 0x11},
+	{0x3820, 0x00},
+	{0x3821, 0x1e},
+	{0x3823, 0x00},
+	{0x3824, 0x00},
+	{0x3825, 0x00},
+	{0x3826, 0x00},
+	{0x3827, 0x00},
+	{0x382a, 0x04},
+	{0x3a04, 0x06},
+	{0x3a05, 0x14},
+	{0x3a06, 0x00},
+	{0x3a07, 0xfe},
+	{0x3b00, 0x00},
+	{0x3b02, 0x00},
+	{0x3b03, 0x00},
+	{0x3b04, 0x00},
+	{0x3b05, 0x00},
+	{0x3e07, 0x20},
+	{0x4000, 0x08},
+	{0x4001, 0x04},
+	{0x4002, 0x45},
+	{0x4004, 0x08},
+	{0x4005, 0x18},
+	{0x4006, 0x20},
+	{0x4008, 0x24},
+	{0x4009, 0x10},
+	{0x400c, 0x00},
+	{0x400d, 0x00},
+	{0x4058, 0x00},
+	{0x404e, 0x37},
+	{0x404f, 0x8f},
+	{0x4058, 0x00},
+	{0x4101, 0xb2},
+	{0x4303, 0x00},
+	{0x4304, 0x08},
+	{0x4307, 0x30},
+	{0x4311, 0x04},
+	{0x4315, 0x01},
+	{0x4511, 0x05},
+	{0x4512, 0x01},
+	{0x4800, 0x20}, /* dis-continuous */
+	{0x4806, 0x00},
+	{0x4816, 0x52},
+	{0x481f, 0x30},
+	{0x4826, 0x32},
+	{0x4831, 0x6a},
+	{0x4d00, 0x04},
+	{0x4d01, 0x71},
+	{0x4d02, 0xfd},
+	{0x4d03, 0xf5},
+	{0x4d04, 0x0c},
+	{0x4d05, 0xcc},
+	{0x4837, 0x0a},
+	{0x5000, 0x06},
+	{0x5001, 0x01},
+	{0x5002, 0x00},
+	{0x5003, 0x20},
+	{0x5046, 0x0a},
+	{0x5013, 0x00},
+	{0x5046, 0x0a},
+	{0x5780, 0xfc},
+	{0x5781, 0x13},
+	{0x5782, 0x03},
+	{0x5786, 0x20},
+	{0x5787, 0x40},
+	{0x5788, 0x08},
+	{0x5789, 0x08},
+	{0x578a, 0x02},
+	{0x578b, 0x01},
+	{0x578c, 0x01},
+	{0x578d, 0x0c},
+	{0x578e, 0x02},
+	{0x578f, 0x01},
+	{0x5790, 0x01},
+	{0x5791, 0xff},
+	{0x5842, 0x01},
+	{0x5843, 0x2b},
+	{0x5844, 0x01},
+	{0x5845, 0x92},
+	{0x5846, 0x01},
+	{0x5847, 0x8f},
+	{0x5848, 0x01},
+	{0x5849, 0x0c},
+	{0x5e00, 0x00},
+	{0x5e10, 0x0c},
+	{IMX214_TABLE_END, 0x0000}
+};
+
+static const imx214_reg mode_1920x1080_old[] = {
+    {IMX214_TABLE_WAIT_MS, IMX214_WAIT_MS},
+	{ 0x0301, 0x05 }, // vt pixel clock divider = 5
+	{ 0x0303, 0x02 }, // vt system clock divider = 2
+	{ 0x0305, 0x03 }, // pre pll clock divider = 3
+	{ 0x0306, 0x00 }, // pll mult 10:8 = 0
+	{ 0x0307, 0x96 }, // pll mult 0:7 = 150
+	{ 0x0309, 0x0a }, // output pixel clock divider = 10
+	{ 0x030B, 0x01 }, // output system clock div = 1 .. OPCLK = 24 / 3(pre_vt) * 150(mpy_vt) / 1(op_sys_div) / 10(op_x_div) = 120MHz
+	{ 0x0310, 0x00 }, // PLL multiple driver = 0 -> 1 PLL control
+	{ 0x0820, 0x12 }, // target freq 31:24 = 18
+	{ 0x0821, 0xc0 }, // 23:16 = 192
+	{ 0x0822, 0x66 }, // 15:8 = 102
+	{ 0x0823, 0x66 }, // 7:0 = 102 ... target freq = 314599014
+	{ 0x3A03, 0x09 },
+	{ 0x3A04, 0x40 },
+	{ 0x3A05, 0x01 },
+	{0x0100, 0x00},/*Including, sw, reset, */
+	{0x3001, 0x0a},
+	{0x3002, 0x80},
+	{0x3006, 0x00},
+	{0x3011, 0x21},
+	{0x3012, 0x09},
+	{0x3013, 0x10},
+	{0x3014, 0x00},
+	{0x3015, 0x08},
+	{0x3016, 0xf0},
+	{0x3017, 0xf0},
+	{0x3018, 0xf0},
+	{0x301b, 0xb4},
+	{0x301d, 0x02},
+	{0x3021, 0x00},
+	{0x3022, 0x01},
+	{0x3028, 0x44},
+	{0x3098, 0x03},
+	{0x3099, 0x1e},
+	{0x309a, 0x02},
+	{0x309b, 0x01},
+	{0x309c, 0x00},
+	{0x30a0, 0xd2},
+	{0x30a2, 0x01},
+	{0x30b2, 0x00},
+	{0x30b3, 0x68},
+	{0x30b4, 0x03},
+	{0x30b5, 0x04},
+	{0x30b6, 0x01},
+	{0x3104, 0x21},
+	{0x3106, 0x00},
+	{0x3406, 0x01},
+	{0x3500, 0x00},
+	{0x3501, 0x7b},
+	{0x3502, 0x00},
+	{0x3503, 0x07},
+	{0x3504, 0x00},
+	{0x3505, 0x00},
+	{0x3506, 0x00},
+	{0x3507, 0x02},
+	{0x3508, 0x00},
+	{0x3509, 0x10},
+	{0x350a, 0x00},
+	{0x350b, 0x40},
+	{0x3601, 0x0a},
+	{0x3602, 0x38},
+	{0x3612, 0x80},
+	{0x3620, 0x54},
+	{0x3621, 0xc7},
+	{0x3622, 0x0f},
+	{0x3625, 0x10},
+	{0x3630, 0x55},
+	{0x3631, 0xf4},
+	{0x3632, 0x00},
+	{0x3633, 0x34},
+	{0x3634, 0x02},
+	{0x364d, 0x0d},
+	{0x364f, 0xdd},
+	{0x3660, 0x04},
+	{0x3662, 0x10},
+	{0x3663, 0xf1},
+	{0x3665, 0x00},
+	{0x3666, 0x20},
+	{0x3667, 0x00},
+	{0x366a, 0x80},
+	{0x3680, 0xe0},
+	{0x3681, 0x00},
+	{0x3700, 0x42},
+	{0x3701, 0x14},
+	{0x3702, 0xa0},
+	{0x3703, 0xd8},
+	{0x3704, 0x78},
+	{0x3705, 0x02},
+	{0x3708, 0xe2},
+	{0x3709, 0xc3},
+	{0x370a, 0x00},
+	{0x370b, 0x20},
+	{0x370c, 0x0c},
+	{0x370d, 0x11},
+	{0x370e, 0x00},
+	{0x370f, 0x40},
+	{0x3710, 0x00},
+	{0x371a, 0x1c},
+	{0x371b, 0x05},
+	{0x371c, 0x01},
+	{0x371e, 0xa1},
+	{0x371f, 0x0c},
+	{0x3721, 0x00},
+	{0x3724, 0x10},
+	{0x3726, 0x00},
+	{0x372a, 0x01},
+	{0x3730, 0x10},
+	{0x3738, 0x22},
+	{0x3739, 0xe5},
+	{0x373a, 0x50},
+	{0x373b, 0x02},
+	{0x373c, 0x41},
+	{0x373f, 0x02},
+	{0x3740, 0x42},
+	{0x3741, 0x02},
+	{0x3742, 0x18},
+	{0x3743, 0x01},
+	{0x3744, 0x02},
+	{0x3747, 0x10},
+	{0x374c, 0x04},
+	{0x3751, 0xf0},
+	{0x3752, 0x00},
+	{0x3753, 0x00},
+	{0x3754, 0xc0},
+	{0x3755, 0x00},
+	{0x3756, 0x1a},
+	{0x3758, 0x00},
+	{0x3759, 0x0f},
+	{0x376b, 0x44},
+	{0x375c, 0x04},
+	{0x3774, 0x10},
+	{0x3776, 0x00},
+	{0x377f, 0x08},
+	{0x3780, 0x22},
+	{0x3781, 0x0c},
+	{0x3784, 0x2c},
+	{0x3785, 0x1e},
+	{0x378f, 0xf5},
+	{0x3791, 0xb0},
+	{0x3795, 0x00},
+	{0x3796, 0x64},
+	{0x3797, 0x11},
+	{0x3798, 0x30},
+	{0x3799, 0x41},
+	{0x379a, 0x07},
+	{0x379b, 0xb0},
+	{0x379c, 0x0c},
+	{0x37c5, 0x00},
+	{0x37c6, 0x00},
+	{0x37c7, 0x00},
+	{0x37c9, 0x00},
+	{0x37ca, 0x00},
+	{0x37cb, 0x00},
+	{0x37de, 0x00},
+	{0x37df, 0x00},
+	{0x3800, 0x00},
+	{0x3801, 0x00},
+	{0x3802, 0x00},
+	{0x3803, 0xf8},
+	{0x3804, 0x0a},
+	{0x3805, 0x3f},
+	{0x3806, 0x06},
+	{0x3807, 0xab},
+	{0x3808, 0x07},
+	{0x3809, 0x80},
+	{0x380a, 0x04},
+	{0x380b, 0x38},
+	{0x380c, 0x0a},
+	{0x380d, 0x80},
+	{0x380e, 0x07},
+	{0x380f, 0xc0},
+	{0x3810, 0x00},
+	{0x3811, 0x02},
+	{0x3812, 0x00},
+	{0x3813, 0x02},
+	{0x3814, 0x11},
+	{0x3815, 0x11},
+	{0x3820, 0x00},
+	{0x3821, 0x1e},
+	{0x3823, 0x00},
+	{0x3824, 0x00},
+	{0x3825, 0x00},
+	{0x3826, 0x00},
+	{0x3827, 0x00},
+	{0x382a, 0x04},
+	{0x3a04, 0x06},
+	{0x3a05, 0x14},
+	{0x3a06, 0x00},
+	{0x3a07, 0xfe},
+	{0x3b00, 0x00},
+	{0x3b02, 0x00},
+	{0x3b03, 0x00},
+	{0x3b04, 0x00},
+	{0x3b05, 0x00},
+	{0x3e07, 0x20},
+	{0x4000, 0x08},
+	{0x4001, 0x04},
+	{0x4002, 0x45},
+	{0x4004, 0x08},
+	{0x4005, 0x18},
+	{0x4006, 0x20},
+	{0x4008, 0x24},
+	{0x4009, 0x10},
+	{0x400c, 0x00},
+	{0x400d, 0x00},
+	{0x4058, 0x00},
+	{0x404e, 0x37},
+	{0x404f, 0x8f},
+	{0x4058, 0x00},
+	{0x4101, 0xb2},
+	{0x4303, 0x00},
+	{0x4304, 0x08},
+	{0x4307, 0x30},
+	{0x4311, 0x04},
+	{0x4315, 0x01},
+	{0x4511, 0x05},
+	{0x4512, 0x01},
+	{0x4800, 0x20}, /* dis-continuous */
+	{0x4806, 0x00},
+	{0x4816, 0x52},
+	{0x481f, 0x30},
+	{0x4826, 0x32},
+	{0x4831, 0x6a},
+	{0x4d00, 0x04},
+	{0x4d01, 0x71},
+	{0x4d02, 0xfd},
+	{0x4d03, 0xf5},
+	{0x4d04, 0x0c},
+	{0x4d05, 0xcc},
+	{0x4837, 0x0a},
+	{0x5000, 0x06},
+	{0x5001, 0x01},
+	{0x5002, 0x80},
+	{0x5003, 0x20},
+	{0x5046, 0x0a},
+	{0x5013, 0x00},
+	{0x5046, 0x0a},
+	{0x5780, 0x1c},
+	{0x5786, 0x20},
+	{0x5787, 0x10},
+	{0x5788, 0x18},
+	{0x578a, 0x04},
+	{0x578b, 0x02},
+	{0x578c, 0x02},
+	{0x578e, 0x06},
+	{0x578f, 0x02},
+	{0x5790, 0x02},
+	{0x5791, 0xff},
+	{0x5842, 0x01},
+	{0x5843, 0x2b},
+	{0x5844, 0x01},
+	{0x5845, 0x92},
+	{0x5846, 0x01},
+	{0x5847, 0x8f},
+	{0x5848, 0x01},
+	{0x5849, 0x0c},
+	{0x5e00, 0x00},
+	{0x5e10, 0x0c},
+	{IMX214_TABLE_END, 0x0000}
+};
+
+static const imx214_reg mode_1280x720_120fps[] = {
+	{IMX214_TABLE_WAIT_MS, IMX214_WAIT_MS},
+	{0x0100, 0x00},/* Including sw reset */
+	{0x3001, 0x0a},
+	{0x3002, 0x80},
+	{0x3006, 0x00},
+	{0x3011, 0x21},
+	{0x3012, 0x09},
+	{0x3013, 0x10},
+	{0x3014, 0x00},
+	{0x3015, 0x08},
+	{0x3016, 0xf0},
+	{0x3017, 0xf0},
+	{0x3018, 0xf0},
+	{0x301b, 0xb4},
+	{0x301d, 0x02},
+	{0x3021, 0x00},
+	{0x3022, 0x01},
+	{0x3028, 0x44},
+	{0x3098, 0x03},
+	{0x3099, 0x1e},
+	{0x309a, 0x02},
+	{0x309b, 0x01},
+	{0x309c, 0x00},
+	{0x30a0, 0xd2},
+	{0x30a2, 0x01},
+	{0x30b2, 0x00},
+	{0x30b3, 0x68},
+	{0x30b4, 0x03},
+	{0x30b5, 0x04},
+	{0x30b6, 0x01},
+	{0x3104, 0x21},
+	{0x3106, 0x00},
+	{0x3406, 0x01},
+	{0x3500, 0x00},
+	{0x3501, 0x2e},
+	{0x3502, 0x80},
+	{0x3503, 0x07},
+	{0x3504, 0x00},
+	{0x3505, 0x00},
+	{0x3506, 0x00},
+	{0x3507, 0x02},
+	{0x3508, 0x00},
+	{0x3509, 0x10},
+	{0x350a, 0x00},
+	{0x350b, 0x40},
+	{0x3601, 0x0a},
+	{0x3602, 0x38},
+	{0x3612, 0x80},
+	{0x3620, 0x54},
+	{0x3621, 0xc7},
+	{0x3622, 0x0f},
+	{0x3625, 0x10},
+	{0x3630, 0x55},
+	{0x3631, 0xf4},
+	{0x3632, 0x00},
+	{0x3633, 0x34},
+	{0x3634, 0x02},
+	{0x364d, 0x0d},
+	{0x364f, 0xdd},
+	{0x3660, 0x04},
+	{0x3662, 0x10},
+	{0x3663, 0xf1},
+	{0x3665, 0x00},
+	{0x3666, 0x20},
+	{0x3667, 0x00},
+	{0x366a, 0x80},
+	{0x3680, 0xe0},
+	{0x3681, 0x00},
+	{0x3700, 0x42},
+	{0x3701, 0x14},
+	{0x3702, 0xa0},
+	{0x3703, 0xd8},
+	{0x3704, 0x78},
+	{0x3705, 0x02},
+	{0x3708, 0xe6},
+	{0x3709, 0xc7},
+	{0x370a, 0x00},
+	{0x370b, 0x20},
+	{0x370c, 0x0c},
+	{0x370d, 0x11},
+	{0x370e, 0x00},
+	{0x370f, 0x40},
+	{0x3710, 0x00},
+	{0x371a, 0x1c},
+	{0x371b, 0x05},
+	{0x371c, 0x01},
+	{0x371e, 0xa1},
+	{0x371f, 0x0c},
+	{0x3721, 0x00},
+	{0x3724, 0x10},
+	{0x3726, 0x00},
+	{0x372a, 0x01},
+	{0x3730, 0x10},
+	{0x3738, 0x22},
+	{0x3739, 0xe5},
+	{0x373a, 0x50},
+	{0x373b, 0x02},
+	{0x373c, 0x41},
+	{0x373f, 0x02},
+	{0x3740, 0x42},
+	{0x3741, 0x02},
+	{0x3742, 0x18},
+	{0x3743, 0x01},
+	{0x3744, 0x02},
+	{0x3747, 0x10},
+	{0x374c, 0x04},
+	{0x3751, 0xf0},
+	{0x3752, 0x00},
+	{0x3753, 0x00},
+	{0x3754, 0xc0},
+	{0x3755, 0x00},
+	{0x3756, 0x1a},
+	{0x3758, 0x00},
+	{0x3759, 0x0f},
+	{0x376b, 0x44},
+	{0x375c, 0x04},
+	{0x3774, 0x10},
+	{0x3776, 0x00},
+	{0x377f, 0x08},
+	{0x3780, 0x22},
+	{0x3781, 0x0c},
+	{0x3784, 0x2c},
+	{0x3785, 0x1e},
+	{0x378f, 0xf5},
+	{0x3791, 0xb0},
+	{0x3795, 0x00},
+	{0x3796, 0x64},
+	{0x3797, 0x11},
+	{0x3798, 0x30},
+	{0x3799, 0x41},
+	{0x379a, 0x07},
+	{0x379b, 0xb0},
+	{0x379c, 0x0c},
+	{0x37c5, 0x00},
+	{0x37c6, 0x00},
+	{0x37c7, 0x00},
+	{0x37c9, 0x00},
+	{0x37ca, 0x00},
+	{0x37cb, 0x00},
+	{0x37de, 0x00},
+	{0x37df, 0x00},
+	{0x3800, 0x00},
+	{0x3801, 0x00},
+	{0x3802, 0x00},
+	{0x3803, 0xf4},
+	{0x3804, 0x0a},
+	{0x3805, 0x3f},
+	{0x3806, 0x06},
+	{0x3807, 0xab},
+	{0x3808, 0x05},
+	{0x3809, 0x00},
+	{0x380a, 0x02},
+	{0x380b, 0xd0},
+	{0x380c, 0x06},
+	{0x380d, 0xd8},
+	{0x380e, 0x02},
+	{0x380f, 0xf8},
+	{0x3810, 0x00},
+	{0x3811, 0x02},
+	{0x3812, 0x00},
+	{0x3813, 0x02},
+	{0x3814, 0x31},
+	{0x3815, 0x31},
+	{0x3820, 0x04},
+	{0x3821, 0x1f},
+	{0x3823, 0x00},
+	{0x3824, 0x00},
+	{0x3825, 0x00},
+	{0x3826, 0x00},
+	{0x3827, 0x00},
+	{0x382a, 0x04},
+	{0x3a04, 0x06},
+	{0x3a05, 0x14},
+	{0x3a06, 0x00},
+	{0x3a07, 0xfe},
+	{0x3b00, 0x00},
+	{0x3b02, 0x00},
+	{0x3b03, 0x00},
+	{0x3b04, 0x00},
+	{0x3b05, 0x00},
+	{0x3e07, 0x20},
+	{0x4000, 0x08},
+	{0x4001, 0x04},
+	{0x4002, 0x45},
+	{0x4004, 0x08},
+	{0x4005, 0x18},
+	{0x4006, 0x20},
+	{0x4008, 0x24},
+	{0x4009, 0x10},
+	{0x400c, 0x00},
+	{0x400d, 0x00},
+	{0x4058, 0x00},
+	{0x404e, 0x37},
+	{0x404f, 0x8f},
+	{0x4058, 0x00},
+	{0x4101, 0xb2},
+	{0x4303, 0x00},
+	{0x4304, 0x08},
+	{0x4307, 0x30},
+	{0x4311, 0x04},
+	{0x4315, 0x01},
+	{0x4511, 0x05},
+	{0x4512, 0x00},
+	{0x4800, 0x20}, /* dis-continuous */
+	{0x4806, 0x00},
+	{0x4816, 0x52},
+	{0x481f, 0x30},
+	{0x4826, 0x32},
+	{0x4831, 0x6a},
+	{0x4d00, 0x04},
+	{0x4d01, 0x71},
+	{0x4d02, 0xfd},
+	{0x4d03, 0xf5},
+	{0x4d04, 0x0c},
+	{0x4d05, 0xcc},
+	{0x4837, 0x0a},
+	{0x5000, 0x06},
+	{0x5001, 0x01},
+	{0x5002, 0x00},
+	{0x5003, 0x20},
+	{0x5046, 0x0a},
+	{0x5013, 0x00},
+	{0x5046, 0x0a},
+	{0x5780, 0x1c},
+	{0x5786, 0x20},
+	{0x5787, 0x10},
+	{0x5788, 0x18},
+	{0x578a, 0x04},
+	{0x578b, 0x02},
+	{0x578c, 0x02},
+	{0x578e, 0x06},
+	{0x578f, 0x02},
+	{0x5790, 0x02},
+	{0x5791, 0xff},
+	{0x5842, 0x01},
+	{0x5843, 0x2b},
+	{0x5844, 0x01},
+	{0x5845, 0x92},
+	{0x5846, 0x01},
+	{0x5847, 0x8f},
+	{0x5848, 0x01},
+	{0x5849, 0x0c},
+	{0x5e00, 0x00},
+	{0x5e10, 0x0c},
+	{IMX214_TABLE_END, 0x0000}
+};
+
+static const imx214_reg mode_2592x1944_HDR_24fps[] = {
+	{IMX214_TABLE_WAIT_MS, IMX214_WAIT_MS},
+	{0x0100, 0x00},/* Including sw reset */
+	{0x0103, 0x01},
+	{0x3001, 0x0a},
+	{0x3002, 0x80},
+	{0x3006, 0x00},
+	{0x3011, 0x21},
+	{0x3012, 0x09},
+	{0x3013, 0x10},
+	{0x3014, 0x00},
+	{0x3015, 0x08},
+	{0x3016, 0xf0},
+	{0x3017, 0xf0},
+	{0x3018, 0xf0},
+	{0x301b, 0xb4},
+	{0x301d, 0x02},
+	{0x3021, 0x00},
+	{0x3022, 0x01},
+	{0x3028, 0x44},
+	{0x3098, 0x02},
+	{0x3099, 0x16},
+	{0x309a, 0x02},
+	{0x309b, 0x01},
+	{0x309c, 0x00},
+	{0x30b2, 0x00},
+	{0x30b3, 0x6e},
+	{0x30b4, 0x03},
+	{0x30a0, 0xd2},
+	{0x30a2, 0x01},
+	{0x30b5, 0x04},
+	{0x30b6, 0x01},
+	{0x3104, 0x21},
+	{0x3106, 0x00},
+	{0x3406, 0x01},
+	{0x3500, 0x00},
+	{0x3501, 0x7b},
+	{0x3502, 0x80},
+	{0x3503, 0x07},
+	{0x3504, 0x00},
+	{0x3505, 0x00},
+	{0x3506, 0x00},
+	{0x3507, 0x01},
+	{0x3508, 0x80},
+	{0x3509, 0x10},
+	{0x350a, 0x00},
+	{0x350b, 0x40},
+	{0x3601, 0x0a},
+	{0x3602, 0x38},
+	{0x3612, 0x80},
+	{0x3620, 0x54},
+	{0x3621, 0xc7},
+	{0x3622, 0x05},
+	{0x3625, 0x10},
+	{0x3630, 0x55},
+	{0x3631, 0xf4},
+	{0x3632, 0x00},
+	{0x3633, 0x34},
+	{0x3634, 0x02},
+	{0x364d, 0x0d},
+	{0x364f, 0xdd},
+	{0x3660, 0x04},
+	{0x3662, 0x10},
+	{0x3663, 0xf1},
+	{0x3665, 0x00},
+	{0x3666, 0x20},
+	{0x3667, 0x00},
+	{0x366a, 0x80},
+	{0x3680, 0xe0},
+	{0x3681, 0x00},
+	{0x3700, 0x42},
+	{0x3701, 0x14},
+	{0x3702, 0xa0},
+	{0x3703, 0xa8},
+	{0x3704, 0x78},
+	{0x3705, 0x02},
+	{0x3708, 0xe2},
+	{0x3709, 0xc3},
+	{0x370a, 0x00},
+	{0x370b, 0x20},
+	{0x370c, 0x0c},
+	{0x370d, 0x11},
+	{0x370e, 0x00},
+	{0x370f, 0x40},
+	{0x3710, 0x00},
+	{0x371a, 0x0c},
+	{0x371b, 0x05},
+	{0x371c, 0x01},
+	{0x371e, 0xa1},
+	{0x371f, 0x0c},
+	{0x3721, 0x00},
+	{0x3724, 0x10},
+	{0x3726, 0x00},
+	{0x372a, 0x01},
+	{0x3730, 0x10},
+	{0x3738, 0x22},
+	{0x3739, 0xe5},
+	{0x373a, 0x50},
+	{0x373b, 0x02},
+	{0x373c, 0x41},
+	{0x373f, 0x02},
+	{0x3740, 0x42},
+	{0x3741, 0x02},
+	{0x3742, 0x18},
+	{0x3743, 0x01},
+	{0x3744, 0x02},
+	{0x3747, 0x10},
+	{0x374c, 0x04},
+	{0x3751, 0xf0},
+	{0x3752, 0x00},
+	{0x3753, 0x00},
+	{0x3754, 0xc0},
+	{0x3755, 0x00},
+	{0x3756, 0x1a},
+	{0x3758, 0x00},
+	{0x3759, 0x0f},
+	{0x376b, 0x44},
+	{0x375c, 0x04},
+	{0x3774, 0x10},
+	{0x3776, 0x00},
+	{0x377f, 0x08},
+	{0x3780, 0x22},
+	{0x3781, 0x0c},
+	{0x3784, 0x2c},
+	{0x3785, 0x1e},
+	{0x378f, 0xf5},
+	{0x3791, 0xb0},
+	{0x3795, 0x00},
+	{0x3796, 0x64},
+	{0x3797, 0x11},
+	{0x3798, 0x30},
+	{0x3799, 0x41},
+	{0x379a, 0x07},
+	{0x379b, 0xb0},
+	{0x379c, 0x0c},
+	{0x37c5, 0x00},
+	{0x37c6, 0x00},
+	{0x37c7, 0x00},
+	{0x37c9, 0x00},
+	{0x37ca, 0x00},
+	{0x37cb, 0x00},
+	{0x37de, 0x00},
+	{0x37df, 0x00},
+	{0x3800, 0x00},
+	{0x3801, 0x02},
+	{0x3802, 0x00},
+	{0x3803, 0x06},
+	{0x3804, 0x0a},
+	{0x3805, 0x41},
+	{0x3806, 0x07},
+	{0x3807, 0xa1},
+	{0x3808, 0x0a},
+	{0x3809, 0x20},
+	{0x380a, 0x07},
+	{0x380b, 0x98},
+	{0x380c, 0x0e},
+	{0x380d, 0x70},
+	{0x380e, 0x07},
+	{0x380f, 0xc0},
+	{0x3810, 0x00},
+	{0x3811, 0x10},
+	{0x3812, 0x00},
+	{0x3813, 0x02},
+	{0x3814, 0x11},
+	{0x3815, 0x11},
+	{0x3820, 0x00},
+	{0x3821, 0x9e},
+	{0x3823, 0x00},
+	{0x3824, 0x00},
+	{0x3825, 0x00},
+	{0x3826, 0x00},
+	{0x3827, 0x00},
+	{0x382a, 0x04},
+	{0x3a04, 0x09},
+	{0x3a05, 0xa9},
+	{0x3a06, 0x00},
+	{0x3a07, 0xfe},
+	{0x3b00, 0x00},
+	{0x3b02, 0x00},
+	{0x3b03, 0x00},
+	{0x3b04, 0x00},
+	{0x3b05, 0x00},
+	{0x3e07, 0x20},
+	{0x4000, 0x08},
+	{0x4001, 0x04},
+	{0x4002, 0x45},
+	{0x4004, 0x08},
+	{0x4005, 0x18},
+	{0x4006, 0x20},
+	{0x4008, 0x24},
+	{0x4009, 0x10},
+	{0x400c, 0x00},
+	{0x400d, 0x00},
+	{0x4058, 0x00},
+	{0x404e, 0x37},
+	{0x404f, 0x8f},
+	{0x4058, 0x00},
+	{0x4101, 0xb2},
+	{0x4303, 0x00},
+	{0x4304, 0x08},
+	{0x4307, 0x30},
+	{0x4311, 0x04},
+	{0x4315, 0x01},
+	{0x4511, 0x05},
+	{0x4512, 0x01},
+	{0x4800, 0x20}, /* dis-continuous */
+	{0x4806, 0x00},
+	{0x4816, 0x52},
+	{0x481f, 0x30},
+	{0x4826, 0x32},
+	{0x4831, 0x6a},
+	{0x4d00, 0x04},
+	{0x4d01, 0x71},
+	{0x4d02, 0xfd},
+	{0x4d03, 0xf5},
+	{0x4d04, 0x0c},
+	{0x4d05, 0xcc},
+	{0x4837, 0x0a},
+	{0x5000, 0x06},
+	{0x5001, 0x01},
+	{0x5002, 0x00},
+	{0x5003, 0x20},
+	{0x5046, 0x0a},
+	{0x5013, 0x00},
+	{0x5046, 0x0a},
+	{0x5780, 0x1c},
+	{0x5786, 0x20},
+	{0x5787, 0x10},
+	{0x5788, 0x18},
+	{0x578a, 0x04},
+	{0x578b, 0x02},
+	{0x578c, 0x02},
+	{0x578e, 0x06},
+	{0x578f, 0x02},
+	{0x5790, 0x02},
+	{0x5791, 0xff},
+	{0x5842, 0x01},
+	{0x5843, 0x2b},
+	{0x5844, 0x01},
+	{0x5845, 0x92},
+	{0x5846, 0x01},
+	{0x5847, 0x8f},
+	{0x5848, 0x01},
+	{0x5849, 0x0c},
+	{0x5e00, 0x00},
+	{0x5e10, 0x0c},
+	{IMX214_TABLE_END, 0x0000}
+};
+
+static const imx214_reg mode_1920x1080_HDR_30fps[] = {
+	{IMX214_TABLE_WAIT_MS, IMX214_WAIT_MS},
+	{0x0100, 0x00},/* Including sw reset */
+	{0x0103, 0x01},
+	{0x3001, 0x0a},
+	{0x3002, 0x80},
+	{0x3006, 0x00},
+	{0x3011, 0x21},
+	{0x3012, 0x09},
+	{0x3013, 0x10},
+	{0x3014, 0x00},
+	{0x3015, 0x08},
+	{0x3016, 0xf0},
+	{0x3017, 0xf0},
+	{0x3018, 0xf0},
+	{0x301b, 0xb4},
+	{0x301d, 0x02},
+	{0x3021, 0x00},
+	{0x3022, 0x01},
+	{0x3028, 0x44},
+	{0x3098, 0x03},
+	{0x3099, 0x1e},
+	{0x309a, 0x02},
+	{0x309b, 0x01},
+	{0x309c, 0x00},
+	{0x30a0, 0xd2},
+	{0x30a2, 0x01},
+	{0x30b2, 0x00},
+	{0x30b3, 0x68},
+	{0x30b4, 0x03},
+	{0x30b5, 0x04},
+	{0x30b6, 0x01},
+	{0x3104, 0x21},
+	{0x3106, 0x00},
+	{0x3406, 0x01},
+	{0x3500, 0x00},
+	{0x3501, 0x72},
+	{0x3502, 0x00},
+	{0x3503, 0x07},
+	{0x3504, 0x00},
+	{0x3505, 0x00},
+	{0x3506, 0x00},
+	{0x3507, 0x01},
+	{0x3508, 0x80},
+	{0x3509, 0x10},
+	{0x350a, 0x00},
+	{0x350b, 0x40},
+	{0x3601, 0x0a},
+	{0x3602, 0x38},
+	{0x3612, 0x80},
+	{0x3620, 0x54},
+	{0x3621, 0xc7},
+	{0x3622, 0x0f},
+	{0x3625, 0x10},
+	{0x3630, 0x55},
+	{0x3631, 0xf4},
+	{0x3632, 0x00},
+	{0x3633, 0x34},
+	{0x3634, 0x02},
+	{0x364d, 0x0d},
+	{0x364f, 0xdd},
+	{0x3660, 0x04},
+	{0x3662, 0x10},
+	{0x3663, 0xf1},
+	{0x3665, 0x00},
+	{0x3666, 0x20},
+	{0x3667, 0x00},
+	{0x366a, 0x80},
+	{0x3680, 0xe0},
+	{0x3681, 0x00},
+	{0x3700, 0x42},
+	{0x3701, 0x14},
+	{0x3702, 0xa0},
+	{0x3703, 0xd8},
+	{0x3704, 0x78},
+	{0x3705, 0x02},
+	{0x3708, 0xe2},
+	{0x3709, 0xc3},
+	{0x370a, 0x00},
+	{0x370b, 0x20},
+	{0x370c, 0x0c},
+	{0x370d, 0x11},
+	{0x370e, 0x00},
+	{0x370f, 0x40},
+	{0x3710, 0x00},
+	{0x371a, 0x1c},
+	{0x371b, 0x05},
+	{0x371c, 0x01},
+	{0x371e, 0xa1},
+	{0x371f, 0x0c},
+	{0x3721, 0x00},
+	{0x3724, 0x10},
+	{0x3726, 0x00},
+	{0x372a, 0x01},
+	{0x3730, 0x10},
+	{0x3738, 0x22},
+	{0x3739, 0xe5},
+	{0x373a, 0x50},
+	{0x373b, 0x02},
+	{0x373c, 0x41},
+	{0x373f, 0x02},
+	{0x3740, 0x42},
+	{0x3741, 0x02},
+	{0x3742, 0x18},
+	{0x3743, 0x01},
+	{0x3744, 0x02},
+	{0x3747, 0x10},
+	{0x374c, 0x04},
+	{0x3751, 0xf0},
+	{0x3752, 0x00},
+	{0x3753, 0x00},
+	{0x3754, 0xc0},
+	{0x3755, 0x00},
+	{0x3756, 0x1a},
+	{0x3758, 0x00},
+	{0x3759, 0x0f},
+	{0x376b, 0x44},
+	{0x375c, 0x04},
+	{0x3774, 0x10},
+	{0x3776, 0x00},
+	{0x377f, 0x08},
+	{0x3780, 0x22},
+	{0x3781, 0x0c},
+	{0x3784, 0x2c},
+	{0x3785, 0x1e},
+	{0x378f, 0xf5},
+	{0x3791, 0xb0},
+	{0x3795, 0x00},
+	{0x3796, 0x64},
+	{0x3797, 0x11},
+	{0x3798, 0x30},
+	{0x3799, 0x41},
+	{0x379a, 0x07},
+	{0x379b, 0xb0},
+	{0x379c, 0x0c},
+	{0x37c5, 0x00},
+	{0x37c6, 0x00},
+	{0x37c7, 0x00},
+	{0x37c9, 0x00},
+	{0x37ca, 0x00},
+	{0x37cb, 0x00},
+	{0x37de, 0x00},
+	{0x37df, 0x00},
+	{0x3800, 0x01},
+	{0x3801, 0x70},
+	{0x3802, 0x01},
+	{0x3803, 0xbc},
+	{0x3804, 0x09},
+	{0x3805, 0x0f},
+	{0x3806, 0x05},
+	{0x3807, 0xff},
+	{0x3808, 0x07},
+	{0x3809, 0x80},
+	{0x380a, 0x04},
+	{0x380b, 0x38},
+	{0x380c, 0x0b},
+	{0x380d, 0x40},
+	{0x380e, 0x07},
+	{0x380f, 0x3a},
+	{0x3810, 0x00},
+	{0x3811, 0x02},
+	{0x3812, 0x00},
+	{0x3813, 0x02},
+	{0x3814, 0x11},
+	{0x3815, 0x11},
+	{0x3820, 0x00},
+	{0x3821, 0x9e},
+	{0x3823, 0x00},
+	{0x3824, 0x00},
+	{0x3825, 0x00},
+	{0x3826, 0x00},
+	{0x3827, 0x00},
+	{0x382a, 0x04},
+	{0x3a04, 0x09},
+	{0x3a05, 0xa9},
+	{0x3a06, 0x00},
+	{0x3a07, 0xfe},
+	{0x3b00, 0x00},
+	{0x3b02, 0x00},
+	{0x3b03, 0x00},
+	{0x3b04, 0x00},
+	{0x3b05, 0x00},
+	{0x3e07, 0x20},
+	{0x4000, 0x08},
+	{0x4001, 0x04},
+	{0x4002, 0x45},
+	{0x4004, 0x08},
+	{0x4005, 0x18},
+	{0x4006, 0x20},
+	{0x4008, 0x24},
+	{0x4009, 0x10},
+	{0x400c, 0x00},
+	{0x400d, 0x00},
+	{0x4058, 0x00},
+	{0x404e, 0x37},
+	{0x404f, 0x8f},
+	{0x4058, 0x00},
+	{0x4101, 0xb2},
+	{0x4303, 0x00},
+	{0x4304, 0x08},
+	{0x4307, 0x30},
+	{0x4311, 0x04},
+	{0x4315, 0x01},
+	{0x4511, 0x05},
+	{0x4512, 0x01},
+	{0x4800, 0x20}, /* dis-continuous */
+	{0x4806, 0x00},
+	{0x4816, 0x52},
+	{0x481f, 0x30},
+	{0x4826, 0x32},
+	{0x4831, 0x6a},
+	{0x4d00, 0x04},
+	{0x4d01, 0x71},
+	{0x4d02, 0xfd},
+	{0x4d03, 0xf5},
+	{0x4d04, 0x0c},
+	{0x4d05, 0xcc},
+	{0x4837, 0x0a},
+	{0x5000, 0x06},
+	{0x5001, 0x01},
+	{0x5002, 0x00},
+	{0x5003, 0x20},
+	{0x5046, 0x0a},
+	{0x5013, 0x00},
+	{0x5046, 0x0a},
+	{0x5780, 0x1c},
+	{0x5786, 0x20},
+	{0x5787, 0x10},
+	{0x5788, 0x18},
+	{0x578a, 0x04},
+	{0x578b, 0x02},
+	{0x578c, 0x02},
+	{0x578e, 0x06},
+	{0x578f, 0x02},
+	{0x5790, 0x02},
+	{0x5791, 0xff},
+	{0x5842, 0x01},
+	{0x5843, 0x2b},
+	{0x5844, 0x01},
+	{0x5845, 0x92},
+	{0x5846, 0x01},
+	{0x5847, 0x8f},
+	{0x5848, 0x01},
+	{0x5849, 0x0c},
+	{0x5e00, 0x00},
+	{0x5e10, 0x0c},
+	{IMX214_TABLE_END, 0x0000}
+};
+
+static const imx214_reg mode_1280x720_HDR_60fps[] = {
+	{IMX214_TABLE_WAIT_MS, IMX214_WAIT_MS},
+	{0x0100, 0x00},/* Including sw reset */
+	{0x0103, 0x01},
+	{0x3001, 0x0a},
+	{0x3002, 0x80},
+	{0x3006, 0x00},
+	{0x3011, 0x21},
+	{0x3012, 0x09},
+	{0x3013, 0x10},
+	{0x3014, 0x00},
+	{0x3015, 0x08},
+	{0x3016, 0xf0},
+	{0x3017, 0xf0},
+	{0x3018, 0xf0},
+	{0x301b, 0xb4},
+	{0x301d, 0x02},
+	{0x3021, 0x00},
+	{0x3022, 0x01},
+	{0x3028, 0x44},
+	{0x3098, 0x03},
+	{0x3099, 0x1e},
+	{0x309a, 0x02},
+	{0x309b, 0x01},
+	{0x309c, 0x00},
+	{0x30a0, 0xd2},
+	{0x30a2, 0x01},
+	{0x30b2, 0x00},
+	{0x30b3, 0x68},
+	{0x30b4, 0x03},
+	{0x30b5, 0x04},
+	{0x30b6, 0x01},
+	{0x3104, 0x21},
+	{0x3106, 0x00},
+	{0x3406, 0x01},
+	{0x3500, 0x00},
+	{0x3501, 0x39},
+	{0x3502, 0x00},
+	{0x3503, 0x07},
+	{0x3504, 0x00},
+	{0x3505, 0x00},
+	{0x3506, 0x00},
+	{0x3507, 0x01},
+	{0x3508, 0x80},
+	{0x3509, 0x10},
+	{0x350a, 0x00},
+	{0x350b, 0x40},
+	{0x3601, 0x0a},
+	{0x3602, 0x38},
+	{0x3612, 0x80},
+	{0x3620, 0x54},
+	{0x3621, 0xc7},
+	{0x3622, 0x0f},
+	{0x3625, 0x10},
+	{0x3630, 0x55},
+	{0x3631, 0xf4},
+	{0x3632, 0x00},
+	{0x3633, 0x34},
+	{0x3634, 0x02},
+	{0x364d, 0x0d},
+	{0x364f, 0xdd},
+	{0x3660, 0x04},
+	{0x3662, 0x10},
+	{0x3663, 0xf1},
+	{0x3665, 0x00},
+	{0x3666, 0x20},
+	{0x3667, 0x00},
+	{0x366a, 0x80},
+	{0x3680, 0xe0},
+	{0x3681, 0x00},
+	{0x3700, 0x42},
+	{0x3701, 0x14},
+	{0x3702, 0xa0},
+	{0x3703, 0xd8},
+	{0x3704, 0x78},
+	{0x3705, 0x02},
+	{0x3708, 0xe2},
+	{0x3709, 0xc3},
+	{0x370a, 0x00},
+	{0x370b, 0x20},
+	{0x370c, 0x0c},
+	{0x370d, 0x11},
+	{0x370e, 0x00},
+	{0x370f, 0x40},
+	{0x3710, 0x00},
+	{0x371a, 0x1c},
+	{0x371b, 0x05},
+	{0x371c, 0x01},
+	{0x371e, 0xa1},
+	{0x371f, 0x0c},
+	{0x3721, 0x00},
+	{0x3724, 0x10},
+	{0x3726, 0x00},
+	{0x372a, 0x01},
+	{0x3730, 0x10},
+	{0x3738, 0x22},
+	{0x3739, 0xe5},
+	{0x373a, 0x50},
+	{0x373b, 0x02},
+	{0x373c, 0x41},
+	{0x373f, 0x02},
+	{0x3740, 0x42},
+	{0x3741, 0x02},
+	{0x3742, 0x18},
+	{0x3743, 0x01},
+	{0x3744, 0x02},
+	{0x3747, 0x10},
+	{0x374c, 0x04},
+	{0x3751, 0xf0},
+	{0x3752, 0x00},
+	{0x3753, 0x00},
+	{0x3754, 0xc0},
+	{0x3755, 0x00},
+	{0x3756, 0x1a},
+	{0x3758, 0x00},
+	{0x3759, 0x0f},
+	{0x376b, 0x44},
+	{0x375c, 0x04},
+	{0x3774, 0x10},
+	{0x3776, 0x00},
+	{0x377f, 0x08},
+	{0x3780, 0x22},
+	{0x3781, 0x0c},
+	{0x3784, 0x2c},
+	{0x3785, 0x1e},
+	{0x378f, 0xf5},
+	{0x3791, 0xb0},
+	{0x3795, 0x00},
+	{0x3796, 0x64},
+	{0x3797, 0x11},
+	{0x3798, 0x30},
+	{0x3799, 0x41},
+	{0x379a, 0x07},
+	{0x379b, 0xb0},
+	{0x379c, 0x0c},
+	{0x37c5, 0x00},
+	{0x37c6, 0x00},
+	{0x37c7, 0x00},
+	{0x37c9, 0x00},
+	{0x37ca, 0x00},
+	{0x37cb, 0x00},
+	{0x37de, 0x00},
+	{0x37df, 0x00},
+	{0x3800, 0x02},
+	{0x3801, 0xa8},
+	{0x3802, 0x02},
+	{0x3803, 0x68},
+	{0x3804, 0x07},
+	{0x3805, 0xb7},
+	{0x3806, 0x05},
+	{0x3807, 0x3b},
+	{0x3808, 0x05},
+	{0x3809, 0x00},
+	{0x380a, 0x02},
+	{0x380b, 0xd0},
+	{0x380c, 0x0b},
+	{0x380d, 0x40},
+	{0x380e, 0x03},
+	{0x380f, 0x9e},
+	{0x3810, 0x00},
+	{0x3811, 0x02},
+	{0x3812, 0x00},
+	{0x3813, 0x02},
+	{0x3814, 0x11},
+	{0x3815, 0x11},
+	{0x3820, 0x00},
+	{0x3821, 0x9e},
+	{0x3823, 0x00},
+	{0x3824, 0x00},
+	{0x3825, 0x00},
+	{0x3826, 0x00},
+	{0x3827, 0x00},
+	{0x382a, 0x04},
+	{0x3a04, 0x09},
+	{0x3a05, 0xa9},
+	{0x3a06, 0x00},
+	{0x3a07, 0xfe},
+	{0x3b00, 0x00},
+	{0x3b02, 0x00},
+	{0x3b03, 0x00},
+	{0x3b04, 0x00},
+	{0x3b05, 0x00},
+	{0x3e07, 0x20},
+	{0x4000, 0x08},
+	{0x4001, 0x04},
+	{0x4002, 0x45},
+	{0x4004, 0x08},
+	{0x4005, 0x18},
+	{0x4006, 0x20},
+	{0x4008, 0x24},
+	{0x4009, 0x10},
+	{0x400c, 0x00},
+	{0x400d, 0x00},
+	{0x4058, 0x00},
+	{0x404e, 0x37},
+	{0x404f, 0x8f},
+	{0x4058, 0x00},
+	{0x4101, 0xb2},
+	{0x4303, 0x00},
+	{0x4304, 0x08},
+	{0x4307, 0x30},
+	{0x4311, 0x04},
+	{0x4315, 0x01},
+	{0x4511, 0x05},
+	{0x4512, 0x01},
+	{0x4800, 0x20}, /* dis-continuous */
+	{0x4806, 0x00},
+	{0x4816, 0x52},
+	{0x481f, 0x30},
+	{0x4826, 0x32},
+	{0x4831, 0x6a},
+	{0x4d00, 0x04},
+	{0x4d01, 0x71},
+	{0x4d02, 0xfd},
+	{0x4d03, 0xf5},
+	{0x4d04, 0x0c},
+	{0x4d05, 0xcc},
+	{0x4837, 0x0a},
+	{0x5000, 0x06},
+	{0x5001, 0x01},
+	{0x5002, 0x00},
+	{0x5003, 0x20},
+	{0x5046, 0x0a},
+	{0x5013, 0x00},
+	{0x5046, 0x0a},
+	{0x5780, 0x1c},
+	{0x5786, 0x20},
+	{0x5787, 0x10},
+	{0x5788, 0x18},
+	{0x578a, 0x04},
+	{0x578b, 0x02},
+	{0x578c, 0x02},
+	{0x578e, 0x06},
+	{0x578f, 0x02},
+	{0x5790, 0x02},
+	{0x5791, 0xff},
+	{0x5842, 0x01},
+	{0x5843, 0x2b},
+	{0x5844, 0x01},
+	{0x5845, 0x92},
+	{0x5846, 0x01},
+	{0x5847, 0x8f},
+	{0x5848, 0x01},
+	{0x5849, 0x0c},
+	{0x5e00, 0x00},
+	{0x5e10, 0x0c},
+	{IMX214_TABLE_END, 0x0000}
+};
+
+static const imx214_reg mode_2592x1944_one_lane_15fps[] = {
+	{0x0100, 0x00},/* Including sw reset */
+	{0x0103, 0x01},
+	{0x3001, 0x0a},
+	{0x3002, 0x80},
+	{0x3006, 0x00},
+	{0x3011, 0x11},
+	{0x3012, 0x09},
+	{0x3013, 0x10},
+	{0x3014, 0x00},
+	{0x3015, 0x28},
+	{0x3016, 0xf0},
+	{0x3017, 0xf0},
+	{0x3018, 0xf0},
+	{0x301b, 0xb4},
+	{0x301d, 0x02},
+	{0x3021, 0x00},
+	{0x3022, 0x01},
+	{0x3028, 0x44},
+	{0x3098, 0x03},
+	{0x3099, 0x1e},
+	{0x309a, 0x05},
+	{0x309b, 0x01},
+	{0x309c, 0x00},
+	{0x30a0, 0xd2},
+	{0x30a2, 0x01},
+	{0x30b2, 0x00},
+	{0x30b3, 0x64},
+	{0x30b4, 0x03},
+	{0x30b5, 0x04},
+	{0x30b6, 0x01},
+	{0x3104, 0x21},
+	{0x3106, 0x00},
+	{0x3400, 0x04},
+	{0x3401, 0x00},
+	{0x3402, 0x04},
+	{0x3403, 0x00},
+	{0x3404, 0x04},
+	{0x3405, 0x00},
+	{0x3406, 0x01},
+	{0x3500, 0x00},
+	{0x3501, 0x7b},
+	{0x3502, 0x00},
+	{0x3503, 0x07},
+	{0x3504, 0x00},
+	{0x3505, 0x00},
+	{0x3506, 0x00},
+	{0x3507, 0x02},
+	{0x3508, 0x00},
+	{0x3509, 0x10},
+	{0x350a, 0x00},
+	{0x350b, 0x20},
+	{0x3600, 0xbc},
+	{0x3601, 0x0a},
+	{0x3602, 0x38},
+	{0x3612, 0x80},
+	{0x3620, 0x44},
+	{0x3621, 0xb5},
+	{0x3622, 0x0c},
+	{0x3625, 0x10},
+	{0x3630, 0x55},
+	{0x3631, 0xf4},
+	{0x3632, 0x00},
+	{0x3633, 0x34},
+	{0x3634, 0x02},
+	{0x364d, 0x0d},
+	{0x364f, 0xdd},
+	{0x3660, 0x04},
+	{0x3662, 0x10},
+	{0x3663, 0xf1},
+	{0x3665, 0x00},
+	{0x3666, 0x20},
+	{0x3667, 0x00},
+	{0x366a, 0x80},
+	{0x3680, 0xe0},
+	{0x3681, 0x00},
+	{0x3700, 0x42},
+	{0x3701, 0x14},
+	{0x3702, 0xa0},
+	{0x3703, 0xd8},
+	{0x3704, 0x78},
+	{0x3705, 0x02},
+	{0x3708, 0xe2},
+	{0x3709, 0xc3},
+	{0x370a, 0x00},
+	{0x370b, 0x20},
+	{0x370c, 0x0c},
+	{0x370d, 0x11},
+	{0x370e, 0x00},
+	{0x370f, 0x40},
+	{0x3710, 0x00},
+	{0x371a, 0x1c},
+	{0x371b, 0x05},
+	{0x371c, 0x01},
+	{0x371e, 0xa1},
+	{0x371f, 0x0c},
+	{0x3721, 0x00},
+	{0x3724, 0x10},
+	{0x3726, 0x00},
+	{0x372a, 0x01},
+	{0x3730, 0x10},
+	{0x3738, 0x22},
+	{0x3739, 0xe5},
+	{0x373a, 0x50},
+	{0x373b, 0x02},
+	{0x373c, 0x41},
+	{0x373f, 0x02},
+	{0x3740, 0x42},
+	{0x3741, 0x02},
+	{0x3742, 0x18},
+	{0x3743, 0x01},
+	{0x3744, 0x02},
+	{0x3747, 0x10},
+	{0x374c, 0x04},
+	{0x3751, 0xf0},
+	{0x3752, 0x00},
+	{0x3753, 0x00},
+	{0x3754, 0xc0},
+	{0x3755, 0x00},
+	{0x3756, 0x1a},
+	{0x3758, 0x00},
+	{0x3759, 0x0f},
+	{0x376b, 0x44},
+	{0x375c, 0x04},
+	{0x3774, 0x10},
+	{0x3776, 0x00},
+	{0x377f, 0x08},
+	{0x3780, 0x22},
+	{0x3781, 0x0c},
+	{0x3784, 0x2c},
+	{0x3785, 0x1e},
+	{0x378f, 0xf5},
+	{0x3791, 0xb0},
+	{0x3795, 0x00},
+	{0x3796, 0x64},
+	{0x3797, 0x11},
+	{0x3798, 0x30},
+	{0x3799, 0x41},
+	{0x379a, 0x07},
+	{0x379b, 0xb0},
+	{0x379c, 0x0c},
+	{0x37c5, 0x00},
+	{0x37c6, 0x00},
+	{0x37c7, 0x00},
+	{0x37c9, 0x00},
+	{0x37ca, 0x00},
+	{0x37cb, 0x00},
+	{0x37de, 0x00},
+	{0x37df, 0x00},
+	{0x3800, 0x00},
+	{0x3801, 0x00},
+	{0x3802, 0x00},
+	{0x3803, 0x00},
+	{0x3804, 0x0a},
+	{0x3805, 0x3f},
+	{0x3806, 0x07},
+	{0x3807, 0xa3},
+	{0x3808, 0x0a},
+	{0x3809, 0x20},
+	{0x380a, 0x07},
+	{0x380b, 0x98},
+	{0x380c, 0x0a},
+	{0x380d, 0x80},
+	{0x380e, 0x07},
+	{0x380f, 0xc0},
+	{0x3810, 0x00},
+	{0x3811, 0x02},
+	{0x3812, 0x00},
+	{0x3813, 0x02},
+	{0x3814, 0x11},
+	{0x3815, 0x11},
+	{0x3820, 0x00},
+	{0x3821, 0x1e},
+	{0x3823, 0x00},
+	{0x3824, 0x00},
+	{0x3825, 0x00},
+	{0x3826, 0x00},
+	{0x3827, 0x00},
+	{0x382a, 0x04},
+	{0x3a04, 0x06},
+	{0x3a05, 0x14},
+	{0x3a06, 0x00},
+	{0x3a07, 0xfe},
+	{0x3b00, 0x00},
+	{0x3b02, 0x00},
+	{0x3b03, 0x00},
+	{0x3b04, 0x00},
+	{0x3b05, 0x00},
+	{0x3e07, 0x20},
+	{0x4000, 0x08},
+	{0x4001, 0x04},
+	{0x4002, 0x45},
+	{0x4004, 0x08},
+	{0x4005, 0x18},
+	{0x4006, 0x20},
+	{0x4008, 0x24},
+	{0x4009, 0x10},
+	{0x400c, 0x00},
+	{0x400d, 0x00},
+	{0x4058, 0x00},
+	{0x404e, 0x37},
+	{0x404f, 0x8f},
+	{0x4058, 0x00},
+	{0x4101, 0xb2},
+	{0x4303, 0x00},
+	{0x4304, 0x08},
+	{0x4307, 0x30},
+	{0x4311, 0x04},
+	{0x4315, 0x01},
+	{0x4511, 0x05},
+	{0x4512, 0x01},
+	{0x4806, 0x00},
+	{0x4816, 0x52},
+	{0x481f, 0x30},
+	{0x4826, 0x2c},
+	{0x4831, 0x64},
+	{0x4d00, 0x04},
+	{0x4d01, 0x71},
+	{0x4d02, 0xfd},
+	{0x4d03, 0xf5},
+	{0x4d04, 0x0c},
+	{0x4d05, 0xcc},
+	{0x4837, 0x0a},
+	{0x5000, 0x06},
+	{0x5001, 0x01},
+	{0x5002, 0x00},
+	{0x5003, 0x20},
+	{0x5046, 0x0a},
+	{0x5013, 0x00},
+	{0x5046, 0x0a},
+	{0x5780, 0xfc},
+	{0x5781, 0x13},
+	{0x5782, 0x03},
+	{0x5786, 0x20},
+	{0x5787, 0x40},
+	{0x5788, 0x08},
+	{0x5789, 0x08},
+	{0x578a, 0x02},
+	{0x578b, 0x01},
+	{0x578c, 0x01},
+	{0x578d, 0x0c},
+	{0x578e, 0x02},
+	{0x578f, 0x01},
+	{0x5790, 0x01},
+	{0x5791, 0xff},
+	{0x5842, 0x01},
+	{0x5843, 0x2b},
+	{0x5844, 0x01},
+	{0x5845, 0x92},
+	{0x5846, 0x01},
+	{0x5847, 0x8f},
+	{0x5848, 0x01},
+	{0x5849, 0x0c},
+	{0x5e00, 0x00},
+	{0x5e10, 0x0c},
+	{0x0100, 0x01},
+	{0x3810, 0x00},
+	{0x3811, 0x10},
+	{0x3812, 0x00},
+	{0x3813, 0x06},
+	{IMX214_TABLE_END, 0x0000}
+};
+
+enum {
+	IMX214_MODE_4208X3120,
+	IMX214_MODE_2104X1560,
+	IMX214_MODE_1920X1080,
+	IMX214_MODE_1280X720,
+
+	IMX214_MODE_START_STREAM,
+	IMX214_MODE_STOP_STREAM,
+	IMX214_MODE_TEST_PATTERN
+};
+
+static const imx214_reg *mode_table[] = {
+	[IMX214_MODE_4208X3120]			= mode_4208x3120,
+	[IMX214_MODE_2104X1560]			= mode_2104x1560,
+	[IMX214_MODE_1920X1080]			= mode_1920x1080,
+	[IMX214_MODE_1280X720]			= mode_1280x720,
+
+	[IMX214_MODE_START_STREAM]		= imx214_start,
+	[IMX214_MODE_STOP_STREAM]		= imx214_stop,
+	[IMX214_MODE_TEST_PATTERN]		= tp_colorbars,
+};
+
+static const int imx214_15fps[] = {
+	15,
+};
+
+static const int imx214_24fps[] = {
+	24,
+};
+
+static const int imx214_30fps[] = {
+	30,
+};
+
+static const int imx214_60fps[] = {
+	60,
+};
+
+static const int imx214_120fps[] = {
+	120,
+};
+
+static const struct camera_common_frmfmt imx214_frmfmt[] = {
+	{{4208, 3120},	imx214_30fps,	1, 0,	IMX214_MODE_4208X3120},
+	{{2104, 1560},	imx214_30fps,	1, 0,	IMX214_MODE_2104X1560},
+	{{1920, 1080},	imx214_60fps,	1, 0,	IMX214_MODE_1920X1080},
+	{{1280, 720},	imx214_30fps,	1, 0,	IMX214_MODE_1280X720},
+};
+#endif  /* __IMX214_TABLES__ */
diff --git a/nvidia/drivers/media/i2c/ov5640.c b/nvidia/drivers/media/i2c/ov5640.c
new file mode 100644
index 000000000000..5173ae8b1170
--- /dev/null
+++ b/nvidia/drivers/media/i2c/ov5640.c
@@ -0,0 +1,1266 @@
+/*
+ * ov5640_v4l2.c - ov5640 sensor driver
+ *
+ * Copyright (c) 2013-2019, NVIDIA CORPORATION.  All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include <linux/slab.h>
+#include <linux/uaccess.h>
+#include <linux/gpio.h>
+#include <linux/module.h>
+#include <linux/debugfs.h>
+
+#include <linux/seq_file.h>
+#include <linux/of.h>
+#include <linux/of_device.h>
+#include <linux/of_gpio.h>
+#include <media/tegra-v4l2-camera.h>
+#include <media/tegracam_core.h>
+#include <media/ov5640.h>
+
+
+#include "../platform/tegra/camera/camera_gpio.h"
+#include "ov5640_mode_tbls.h"
+#define CREATE_TRACE_POINTS
+#include <trace/events/ov5640.h>
+
+#define OV5640_MAX_COARSE_DIFF		6
+#define OV5640_MAX_FRAME_LENGTH	(0x7fff)
+#define OV5640_MIN_EXPOSURE_COARSE	(0x0002)
+#define OV5640_MAX_EXPOSURE_COARSE	\
+	(OV5640_MAX_FRAME_LENGTH-OV5640_MAX_COARSE_DIFF)
+#define OV5640_DEFAULT_LINE_LENGTH	(0x9c4)
+#define OV5640_DEFAULT_PIXEL_CLOCK	(420)
+#define OV5640_DEFAULT_FRAME_LENGTH	(0x0460)
+#define OV5640_DEFAULT_EXPOSURE_COARSE	\
+	(OV5640_DEFAULT_FRAME_LENGTH-OV5640_MAX_COARSE_DIFF)
+
+static const u32 ctrl_cid_list[] = {
+	TEGRA_CAMERA_CID_GAIN,
+	TEGRA_CAMERA_CID_EXPOSURE,
+	TEGRA_CAMERA_CID_EXPOSURE_SHORT,
+	TEGRA_CAMERA_CID_FRAME_RATE,
+	TEGRA_CAMERA_CID_GROUP_HOLD,
+	TEGRA_CAMERA_CID_HDR_EN,
+	TEGRA_CAMERA_CID_EEPROM_DATA,
+	TEGRA_CAMERA_CID_OTP_DATA,
+	TEGRA_CAMERA_CID_FUSE_ID,
+};
+
+struct ov5640 {
+	struct camera_common_eeprom_data eeprom[OV5640_EEPROM_NUM_BLOCKS];
+	u8				eeprom_buf[OV5640_EEPROM_SIZE];
+	u8				otp_buf[OV5640_OTP_SIZE];
+	struct i2c_client		*i2c_client;
+	struct v4l2_subdev		*subdev;
+	u8				fuse_id[OV5640_FUSE_ID_SIZE];
+	const char			*devname;
+	struct dentry			*debugfs_dir;
+	struct mutex			streaming_lock;
+	bool				streaming;
+
+	s32				group_hold_prev;
+	u32				frame_length;
+	bool				group_hold_en;
+	struct camera_common_i2c	i2c_dev;
+	struct camera_common_data	*s_data;
+	struct tegracam_device		*tc_dev;
+};
+
+static struct regmap_config ov5640_regmap_config = {
+	.reg_bits = 16,
+	.val_bits = 8,
+};
+
+static inline void ov5640_get_frame_length_regs(ov5640_reg *regs,
+				u32 frame_length)
+{
+	regs->addr = OV5640_FRAME_LENGTH_ADDR_MSB;
+	regs->val = (frame_length >> 8) & 0xff;
+	(regs + 1)->addr = OV5640_FRAME_LENGTH_ADDR_LSB;
+	(regs + 1)->val = (frame_length) & 0xff;
+}
+
+static inline void ov5640_get_coarse_time_regs(ov5640_reg *regs,
+				u32 coarse_time)
+{
+	regs->addr = OV5640_COARSE_TIME_ADDR_1;
+	regs->val = (coarse_time >> 12) & 0xff;
+	(regs + 1)->addr = OV5640_COARSE_TIME_ADDR_2;
+	(regs + 1)->val = (coarse_time >> 4) & 0xff;
+	(regs + 2)->addr = OV5640_COARSE_TIME_ADDR_3;
+	(regs + 2)->val = (coarse_time & 0xf) << 4;
+}
+
+static inline void ov5640_get_coarse_time_short_regs(ov5640_reg *regs,
+				u32 coarse_time)
+{
+	regs->addr = OV5640_COARSE_TIME_SHORT_ADDR_1;
+	regs->val = (coarse_time >> 12) & 0xff;
+	(regs + 1)->addr = OV5640_COARSE_TIME_SHORT_ADDR_2;
+	(regs + 1)->val = (coarse_time >> 4) & 0xff;
+	(regs + 2)->addr = OV5640_COARSE_TIME_SHORT_ADDR_3;
+	(regs + 2)->val = (coarse_time & 0xf) << 4;
+}
+
+static inline void ov5640_get_gain_regs(ov5640_reg *regs,
+				u16 gain)
+{
+	regs->addr = OV5640_GAIN_ADDR_MSB;
+	regs->val = (gain >> 8) & 0xff;
+
+	(regs + 1)->addr = OV5640_GAIN_ADDR_LSB;
+	(regs + 1)->val = (gain) & 0xff;
+}
+
+static int test_mode;
+module_param(test_mode, int, 0644);
+
+static inline int ov5640_read_reg(struct camera_common_data *s_data,
+				u16 addr, u8 *val)
+{
+	int err = 0;
+	u32 reg_val = 0;
+
+	err = regmap_read(s_data->regmap, addr, &reg_val);
+	*val = reg_val & 0xFF;
+
+	return err;
+}
+
+static int ov5640_write_reg(struct camera_common_data *s_data, u16 addr, u8 val)
+{
+	int err;
+	struct device *dev = s_data->dev;
+
+	err = regmap_write(s_data->regmap, addr, val);
+
+	if (err)
+		dev_err(dev, "%s: i2c write failed, 0x%x = %x\n",
+			__func__, addr, val);
+
+	return err;
+}
+
+static int ov5640_write_table(struct ov5640 *priv,
+			      const ov5640_reg table[])
+{
+	struct camera_common_data *s_data = priv->s_data;
+
+	return regmap_util_write_table_8(s_data->regmap,
+					 table,
+					 NULL, 0,
+					 OV5640_TABLE_WAIT_MS,
+					 OV5640_TABLE_END);
+}
+
+static void ov5640_gpio_set(struct camera_common_data *s_data,
+			    unsigned int gpio, int val)
+{
+	struct camera_common_pdata *pdata = s_data->pdata;
+
+	if (pdata && pdata->use_cam_gpio)
+		cam_gpio_ctrl(s_data->dev, gpio, val, 1);
+	else {
+		if (gpio_cansleep(gpio))
+			gpio_set_value_cansleep(gpio, val);
+		else
+			gpio_set_value(gpio, val);
+	}
+}
+
+static int ov5640_power_on(struct camera_common_data *s_data)
+{
+	int err = 0;
+	struct camera_common_power_rail *pw = s_data->power;
+	struct camera_common_pdata *pdata = s_data->pdata;
+	struct device *dev = s_data->dev;
+	u32 frame_time;
+
+	dev_dbg(dev, "%s: power on\n", __func__);
+
+	if (pdata && pdata->power_on) {
+		err = pdata->power_on(pw);
+		if (err)
+			dev_err(dev, "%s failed.\n", __func__);
+		else
+			pw->state = SWITCH_ON;
+		return err;
+	}
+	/* sleeps calls in the sequence below are for internal device
+	 * signal propagation as specified by sensor vendor
+	 */
+
+	if (pw->avdd)
+		err = regulator_enable(pw->avdd);
+	if (err)
+		goto ov5640_avdd_fail;
+
+	if (pw->dvdd)
+		err = regulator_enable(pw->dvdd);
+	if (err)
+		goto ov5640_dvdd_fail;
+
+	usleep_range(1, 2);
+	if (gpio_is_valid(pw->pwdn_gpio))
+		ov5640_gpio_set(s_data, pw->pwdn_gpio, 0);
+
+/*
+ * datasheet 2.9: reset requires ~2ms settling time
+ * a power on reset is generated after core power becomes stable
+ */
+	usleep_range(2000, 2010);
+
+	if (gpio_is_valid(pw->reset_gpio))
+		ov5640_gpio_set(s_data, pw->reset_gpio, 1);
+
+	/* datasheet fig 2-9: t3 */
+	usleep_range(2000, 2010);
+
+	pw->state = SWITCH_ON;
+
+	ov5640_write_reg(s_data, 0x3008, 0x02);
+	ov5640_write_reg(s_data, 0x3008, 0x42);
+
+	frame_time = OV5640_DEFAULT_FRAME_LENGTH *
+			OV5640_DEFAULT_LINE_LENGTH / OV5640_DEFAULT_PIXEL_CLOCK;
+	usleep_range(frame_time, frame_time + 1000);
+
+	return 0;
+
+ov5640_dvdd_fail:
+	regulator_disable(pw->avdd);
+
+ov5640_avdd_fail:
+	dev_err(dev, "%s failed.\n", __func__);
+	return -ENODEV;
+}
+
+static int ov5640_power_off(struct camera_common_data *s_data)
+{
+	int err = 0;
+	struct camera_common_power_rail *pw = s_data->power;
+	struct device *dev = s_data->dev;
+	struct camera_common_pdata *pdata = s_data->pdata;
+
+	dev_dbg(dev, "%s: power off\n", __func__);
+
+	if (pdata && pdata->power_off) {
+		err = pdata->power_off(pw);
+		if (!err) {
+			goto power_off_done;
+		} else {
+			dev_err(dev, "%s failed.\n", __func__);
+			return err;
+		}
+	}
+
+	/* sleeps calls in the sequence below are for internal device
+	 * signal propagation as specified by sensor vendor
+	 */
+	usleep_range(21, 25);
+	if (gpio_is_valid(pw->pwdn_gpio))
+		ov5640_gpio_set(s_data, pw->pwdn_gpio, 1);
+	usleep_range(1, 2);
+	if (gpio_is_valid(pw->reset_gpio))
+		ov5640_gpio_set(s_data, pw->reset_gpio, 0);
+
+	/* datasheet 2.9: reset requires ~2ms settling time*/
+	usleep_range(2000, 2010);
+
+	if (pw->dvdd)
+		regulator_disable(pw->dvdd);
+	if (pw->avdd)
+		regulator_disable(pw->avdd);
+
+power_off_done:
+	pw->state = SWITCH_OFF;
+	return 0;
+}
+
+static int ov5640_power_put(struct tegracam_device *tc_dev)
+{
+	struct camera_common_data *s_data = tc_dev->s_data;
+	struct camera_common_power_rail *pw = s_data->power;
+	struct camera_common_pdata *pdata = s_data->pdata;
+	struct device *dev = tc_dev->dev;
+
+	if (unlikely(!pw))
+		return -EFAULT;
+
+	if (pdata && pdata->use_cam_gpio)
+		cam_gpio_deregister(dev, pw->pwdn_gpio);
+	else {
+		if (gpio_is_valid(pw->pwdn_gpio))
+			gpio_free(pw->pwdn_gpio);
+		if (gpio_is_valid(pw->reset_gpio))
+			gpio_free(pw->reset_gpio);
+	}
+
+	return 0;
+}
+
+static int ov5640_power_get(struct tegracam_device *tc_dev)
+{
+	struct camera_common_data *s_data = tc_dev->s_data;
+	struct camera_common_power_rail *pw = s_data->power;
+	struct camera_common_pdata *pdata = s_data->pdata;
+	struct device *dev = tc_dev->dev;
+	const char *mclk_name;
+	const char *parentclk_name;
+	struct clk *parent;
+	int err = 0, ret = 0;
+
+	if (!pdata) {
+		dev_err(dev, "pdata missing\n");
+		return -EFAULT;
+	}
+
+	mclk_name = pdata->mclk_name ?
+		    pdata->mclk_name : "cam_mclk1";
+	pw->mclk = devm_clk_get(dev, mclk_name);
+	if (IS_ERR(pw->mclk)) {
+		dev_err(dev, "unable to get clock %s\n", mclk_name);
+		return PTR_ERR(pw->mclk);
+	}
+	parentclk_name = pdata->parentclk_name;
+	if (parentclk_name) {
+		parent = devm_clk_get(dev, parentclk_name);
+		if (IS_ERR(parent)) {
+			dev_err(dev, "unable to get parent clcok %s",
+				parentclk_name);
+		} else
+			clk_set_parent(pw->mclk, parent);
+	}
+
+	/* analog 2.8v */
+	err |= camera_common_regulator_get(dev,
+			&pw->avdd, pdata->regulators.avdd);
+	/* DVDD 1.5v */
+	err |= camera_common_regulator_get(dev,
+			&pw->dvdd, pdata->regulators.dvdd);
+
+	if (!err) {
+		pw->reset_gpio = pdata->reset_gpio;
+		pw->pwdn_gpio = pdata->pwdn_gpio;
+	}
+	if (pdata->use_cam_gpio) {
+		err = cam_gpio_register(dev, pw->pwdn_gpio);
+		if (err)
+			dev_err(dev, "%s ERR can't register cam gpio %u!\n",
+				 __func__, pw->pwdn_gpio);
+	} else {
+		if (gpio_is_valid(pw->pwdn_gpio)) {
+			ret = gpio_request(pw->pwdn_gpio, "cam_pwdn_gpio");
+			if (ret < 0) {
+				dev_dbg(dev, "%s can't request pwdn_gpio %d\n",
+					__func__, ret);
+			}
+			gpio_direction_output(pw->pwdn_gpio, 1);
+		}
+		if (gpio_is_valid(pw->reset_gpio)) {
+			ret = gpio_request(pw->reset_gpio, "cam_reset_gpio");
+			if (ret < 0) {
+				dev_dbg(dev, "%s can't request reset_gpio %d\n",
+					__func__, ret);
+			}
+			gpio_direction_output(pw->reset_gpio, 1);
+		}
+	}
+
+	pw->state = SWITCH_OFF;
+	return err;
+}
+
+static int ov5640_set_gain(struct tegracam_device *tc_dev, s64 val);
+static int ov5640_set_frame_rate(struct tegracam_device *tc_dev, s64 val);
+static int ov5640_set_exposure(struct tegracam_device *tc_dev, s64 val);
+static int ov5640_set_exposure_short(struct tegracam_device *tc_dev, s64 val);
+
+static const struct of_device_id ov5640_of_match[] = {
+	{
+		.compatible = "nvidia,ov5640",
+	},
+	{ },
+};
+
+static int ov5640_set_group_hold(struct tegracam_device *tc_dev, bool val)
+{
+	int err;
+	struct ov5640 *priv = tc_dev->priv;
+	int gh_prev = switch_ctrl_qmenu[priv->group_hold_prev];
+	struct device *dev = tc_dev->dev;
+
+	if (priv->group_hold_en == true && gh_prev == SWITCH_OFF) {
+		camera_common_i2c_aggregate(&priv->i2c_dev, true);
+		/* enter group hold */
+		err = ov5640_write_reg(priv->s_data,
+				       OV5640_GROUP_HOLD_ADDR, val);
+		if (err)
+			goto fail;
+
+		priv->group_hold_prev = 1;
+
+		dev_dbg(dev, "%s: enter group hold\n", __func__);
+	} else if (priv->group_hold_en == false && gh_prev == SWITCH_ON) {
+		/* leave group hold */
+		err = ov5640_write_reg(priv->s_data,
+				       OV5640_GROUP_HOLD_ADDR, 0x11);
+		if (err)
+			goto fail;
+
+		err = ov5640_write_reg(priv->s_data,
+				       OV5640_GROUP_HOLD_ADDR, 0x61);
+		if (err)
+			goto fail;
+
+		camera_common_i2c_aggregate(&priv->i2c_dev, false);
+
+		priv->group_hold_prev = 0;
+
+		dev_dbg(dev, "%s: leave group hold\n", __func__);
+	}
+
+	return 0;
+
+fail:
+	dev_dbg(dev, "%s: Group hold control error\n", __func__);
+	return err;
+}
+
+static int ov5640_set_gain(struct tegracam_device *tc_dev, s64 val)
+{
+	struct camera_common_data *s_data = tc_dev->s_data;
+	struct ov5640 *priv = (struct ov5640 *)tc_dev->priv;
+	struct device *dev = tc_dev->dev;
+	const struct sensor_mode_properties *mode =
+		&s_data->sensor_props.sensor_modes[s_data->mode_prop_idx];
+	ov5640_reg reg_list[2];
+	int err;
+	u16 gain;
+	int i;
+
+	if (!priv->group_hold_prev)
+		ov5640_set_group_hold(tc_dev, 1);
+
+	/* translate value */
+	gain = (u16) (((val * 16) +
+			(mode->control_properties.gain_factor / 2)) /
+			mode->control_properties.gain_factor);
+	ov5640_get_gain_regs(reg_list, gain);
+	dev_dbg(dev, "%s: gain %d val: %lld\n", __func__, gain, val);
+
+	for (i = 0; i < 2; i++) {
+		err = ov5640_write_reg(s_data, reg_list[i].addr,
+			 reg_list[i].val);
+		if (err)
+			goto fail;
+	}
+
+	return 0;
+
+fail:
+	dev_dbg(dev, "%s: GAIN control error\n", __func__);
+	return err;
+}
+
+static int ov5640_set_frame_rate(struct tegracam_device *tc_dev, s64 val)
+{
+	struct camera_common_data *s_data = tc_dev->s_data;
+	struct device *dev = tc_dev->dev;
+	struct ov5640 *priv = tc_dev->priv;
+	const struct sensor_mode_properties *mode =
+		&s_data->sensor_props.sensor_modes[s_data->mode_prop_idx];
+	ov5640_reg reg_list[2];
+	int err;
+	u32 frame_length;
+	int i;
+
+	if (!priv->group_hold_prev)
+		ov5640_set_group_hold(tc_dev, 1);
+
+	frame_length =  mode->signal_properties.pixel_clock.val *
+		mode->control_properties.framerate_factor /
+		mode->image_properties.line_length / val;
+
+	ov5640_get_frame_length_regs(reg_list, frame_length);
+	dev_dbg(dev, "%s: val: %d\n", __func__, frame_length);
+
+	for (i = 0; i < 2; i++) {
+		err = ov5640_write_reg(s_data, reg_list[i].addr,
+			 reg_list[i].val);
+		if (err)
+			goto fail;
+	}
+
+	priv->frame_length = frame_length;
+
+	return 0;
+
+fail:
+	dev_dbg(dev, "%s: FRAME_LENGTH control error\n", __func__);
+	return err;
+}
+
+static int ov5640_set_exposure(struct tegracam_device *tc_dev, s64 val)
+{
+	struct camera_common_data *s_data = tc_dev->s_data;
+	struct device *dev = tc_dev->dev;
+	struct ov5640 *priv = tc_dev->priv;
+	const s32 max_coarse_time = priv->frame_length - OV5640_MAX_COARSE_DIFF;
+	const struct sensor_mode_properties *mode =
+		&s_data->sensor_props.sensor_modes[s_data->mode_prop_idx];
+	ov5640_reg reg_list[3];
+	int err;
+	u32 coarse_time;
+	int i;
+
+	if (!priv->group_hold_prev)
+		ov5640_set_group_hold(tc_dev, 1);
+
+	coarse_time = (u32)(((mode->signal_properties.pixel_clock.val*val)
+			/mode->image_properties.line_length)/
+			mode->control_properties.exposure_factor);
+	if (coarse_time < OV5640_MIN_EXPOSURE_COARSE)
+		coarse_time = OV5640_MIN_EXPOSURE_COARSE;
+	else if (coarse_time > max_coarse_time)
+		coarse_time = max_coarse_time;
+	ov5640_get_coarse_time_regs(reg_list, coarse_time);
+	dev_dbg(dev, "%s: val: %d\n", __func__, coarse_time);
+
+	for (i = 0; i < 3; i++) {
+		err = ov5640_write_reg(s_data, reg_list[i].addr,
+			 reg_list[i].val);
+		if (err)
+			goto fail;
+	}
+
+	return 0;
+
+fail:
+	dev_dbg(dev, "%s: COARSE_TIME control error\n", __func__);
+	return err;
+}
+
+static int ov5640_set_exposure_short(struct tegracam_device *tc_dev, s64 val)
+{
+	struct camera_common_data *s_data = tc_dev->s_data;
+	struct device *dev = tc_dev->dev;
+	struct ov5640 *priv = tc_dev->priv;
+	const struct sensor_mode_properties *mode =
+		&s_data->sensor_props.sensor_modes[s_data->mode_prop_idx];
+	ov5640_reg reg_list[3];
+	int err;
+	struct v4l2_control hdr_control;
+	int hdr_en;
+	u32 coarse_time_short;
+	int i;
+	if (!priv->group_hold_prev)
+		ov5640_set_group_hold(tc_dev, 1);
+
+	/* check hdr enable ctrl */
+	hdr_control.id = TEGRA_CAMERA_CID_HDR_EN;
+
+	err = camera_common_g_ctrl(s_data, &hdr_control);
+	if (err < 0) {
+		dev_err(dev, "could not find device ctrl.\n");
+		return err;
+	}
+
+	hdr_en = switch_ctrl_qmenu[hdr_control.value];
+	if (hdr_en == SWITCH_OFF)
+		return 0;
+
+	coarse_time_short = (u32)(((mode->signal_properties.pixel_clock.val*val)
+				/mode->image_properties.line_length)
+				/mode->control_properties.exposure_factor);
+
+	ov5640_get_coarse_time_short_regs(reg_list, coarse_time_short);
+	dev_dbg(dev, "%s: val: %d\n", __func__, coarse_time_short);
+
+	for (i = 0; i < 3; i++) {
+		err = ov5640_write_reg(s_data, reg_list[i].addr,
+			 reg_list[i].val);
+		if (err)
+			goto fail;
+	}
+
+	return 0;
+
+fail:
+	dev_dbg(dev, "%s: COARSE_TIME_SHORT control error\n", __func__);
+	return err;
+}
+
+static int ov5640_fill_string_ctrl(struct tegracam_device *tc_dev,
+				struct v4l2_ctrl *ctrl)
+{
+	struct ov5640 *priv = tc_dev->priv;
+	int i;
+
+	switch (ctrl->id) {
+	case TEGRA_CAMERA_CID_EEPROM_DATA:
+		for (i = 0; i < OV5640_EEPROM_SIZE; i++)
+			sprintf(&ctrl->p_new.p_char[i*2], "%02x",
+				priv->eeprom_buf[i]);
+		break;
+	case TEGRA_CAMERA_CID_OTP_DATA:
+		for (i = 0; i < OV5640_OTP_SIZE; i++)
+			sprintf(&ctrl->p_new.p_char[i*2], "%02x",
+				priv->otp_buf[i]);
+		break;
+	case TEGRA_CAMERA_CID_FUSE_ID:
+		for (i = 0; i < OV5640_FUSE_ID_SIZE; i++)
+			sprintf(&ctrl->p_new.p_char[i*2], "%02x",
+				priv->fuse_id[i]);
+		break;
+	default:
+		dev_dbg(tc_dev->dev, "%s: Invalid ctrl -> id\n", __func__);
+		return -EINVAL;
+	}
+	ctrl->p_cur.p_char = ctrl->p_new.p_char;
+	return 0;
+}
+
+static int ov5640_eeprom_device_release(struct ov5640 *priv)
+{
+	int i;
+
+	for (i = 0; i < OV5640_EEPROM_NUM_BLOCKS; i++) {
+		if (priv->eeprom[i].i2c_client != NULL) {
+			i2c_unregister_device(priv->eeprom[i].i2c_client);
+			priv->eeprom[i].i2c_client = NULL;
+		}
+	}
+
+	return 0;
+}
+
+static int ov5640_eeprom_device_init(struct ov5640 *priv)
+{
+	struct camera_common_pdata *pdata =  priv->s_data->pdata;
+	char *dev_name = "eeprom_ov5640";
+	static struct regmap_config eeprom_regmap_config = {
+		.reg_bits = 8,
+		.val_bits = 8,
+	};
+	int i;
+	int err;
+
+	if (!pdata->has_eeprom)
+		return -EINVAL;
+
+	for (i = 0; i < OV5640_EEPROM_NUM_BLOCKS; i++) {
+		priv->eeprom[i].adap = i2c_get_adapter(
+				priv->i2c_client->adapter->nr);
+		memset(&priv->eeprom[i].brd, 0, sizeof(priv->eeprom[i].brd));
+		strncpy(priv->eeprom[i].brd.type, dev_name,
+				sizeof(priv->eeprom[i].brd.type));
+		priv->eeprom[i].brd.addr = OV5640_EEPROM_ADDRESS + i;
+		priv->eeprom[i].i2c_client = i2c_new_device(
+				priv->eeprom[i].adap, &priv->eeprom[i].brd);
+
+		priv->eeprom[i].regmap = devm_regmap_init_i2c(
+			priv->eeprom[i].i2c_client, &eeprom_regmap_config);
+		if (IS_ERR(priv->eeprom[i].regmap)) {
+			err = PTR_ERR(priv->eeprom[i].regmap);
+			ov5640_eeprom_device_release(priv);
+			return err;
+		}
+	}
+
+	return 0;
+}
+
+static int ov5640_read_eeprom(struct ov5640 *priv)
+{
+	int err, i;
+
+	for (i = 0; i < OV5640_EEPROM_NUM_BLOCKS; i++) {
+		err = regmap_bulk_read(priv->eeprom[i].regmap, 0,
+			&priv->eeprom_buf[i * OV5640_EEPROM_BLOCK_SIZE],
+			OV5640_EEPROM_BLOCK_SIZE);
+		if (err)
+			return err;
+	}
+	return 0;
+}
+
+static int ov5640_read_otp_bank(struct ov5640 *priv,
+				u8 *buf, int bank, u16 addr, int size)
+{
+	int err;
+
+	/* sleeps calls in the sequence below are for internal device
+	 * signal propagation as specified by sensor vendor */
+
+	usleep_range(10000, 11000);
+	mutex_lock(&priv->streaming_lock);
+	err = ov5640_write_table(priv, mode_table[OV5640_MODE_START_STREAM]);
+	if (err) {
+		mutex_unlock(&priv->streaming_lock);
+		return err;
+	} else {
+		priv->streaming = true;
+		mutex_unlock(&priv->streaming_lock);
+	}
+
+	err = ov5640_write_reg(priv->s_data, OV5640_OTP_BANK_SELECT_ADDR,
+			       0xC0 | bank);
+	if (err)
+		return err;
+
+	err = ov5640_write_reg(priv->s_data, OV5640_OTP_LOAD_CTRL_ADDR, 0x01);
+	if (err)
+		return err;
+
+	usleep_range(10000, 11000);
+	err = regmap_bulk_read(priv->s_data->regmap, addr, buf, size);
+
+	if (err)
+		return err;
+
+	mutex_lock(&priv->streaming_lock);
+	err = ov5640_write_table(priv, mode_table[OV5640_MODE_STOP_STREAM]);
+	if (err) {
+		mutex_unlock(&priv->streaming_lock);
+		return err;
+	} else {
+		priv->streaming = false;
+		mutex_unlock(&priv->streaming_lock);
+	}
+
+	return 0;
+}
+
+static int ov5640_otp_setup(struct ov5640 *priv)
+{
+	struct device *dev = priv->s_data->dev;
+	int err = 0;
+	int i;
+
+	for (i = 0; i < OV5640_OTP_NUM_BANKS; i++) {
+		err = ov5640_read_otp_bank(priv,
+					&priv->otp_buf[i
+					* OV5640_OTP_BANK_SIZE],
+					i,
+					OV5640_OTP_BANK_START_ADDR,
+					OV5640_OTP_BANK_SIZE);
+		if (err) {
+			dev_err(dev, "could not read otp bank\n");
+			goto ret;
+		}
+	}
+
+ret:
+	return err;
+}
+
+static int ov5640_fuse_id_setup(struct ov5640 *priv)
+{
+	struct device *dev = priv->s_data->dev;
+	int err;
+
+	err = ov5640_read_otp_bank(priv,
+				&priv->fuse_id[0],
+				OV5640_FUSE_ID_OTP_BANK,
+				OV5640_FUSE_ID_OTP_START_ADDR,
+				OV5640_FUSE_ID_SIZE);
+	if (err) {
+		dev_err(dev, "could not read otp bank\n");
+		goto ret;
+	}
+
+ret:
+	return err;
+}
+
+MODULE_DEVICE_TABLE(of, ov5640_of_match);
+
+static struct camera_common_pdata *ov5640_parse_dt(struct tegracam_device
+							*tc_dev)
+{
+	struct device *dev = tc_dev->dev;
+	struct device_node *node = dev->of_node;
+	struct camera_common_pdata *board_priv_pdata;
+	const struct of_device_id *match;
+	int gpio;
+	int err;
+	struct camera_common_pdata *ret = NULL;
+
+	if (!node)
+		return NULL;
+
+	match = of_match_device(ov5640_of_match, dev);
+	if (!match) {
+		dev_err(dev, "Failed to find matching dt id\n");
+		return NULL;
+	}
+
+	board_priv_pdata = devm_kzalloc(dev,
+			   sizeof(*board_priv_pdata), GFP_KERNEL);
+	if (!board_priv_pdata)
+		return NULL;
+
+	err = camera_common_parse_clocks(dev,
+					 board_priv_pdata);
+	if (err) {
+		dev_err(dev, "Failed to find clocks\n");
+		goto error;
+	}
+
+	gpio = of_get_named_gpio(node, "pwdn-gpios", 0);
+	if (gpio < 0) {
+		if (gpio == -EPROBE_DEFER) {
+			ret = ERR_PTR(-EPROBE_DEFER);
+			goto error;
+		}
+		gpio = 0;
+	}
+	board_priv_pdata->pwdn_gpio = (unsigned int)gpio;
+
+	gpio = of_get_named_gpio(node, "reset-gpios", 0);
+	if (gpio < 0) {
+		/* reset-gpio is not absolutely needed */
+		if (gpio == -EPROBE_DEFER) {
+			ret = ERR_PTR(-EPROBE_DEFER);
+			goto error;
+		}
+		dev_dbg(dev, "reset gpios not in DT\n");
+		gpio = 0;
+	}
+	board_priv_pdata->reset_gpio = (unsigned int)gpio;
+
+	board_priv_pdata->use_cam_gpio =
+		of_property_read_bool(node, "cam,use-cam-gpio");
+
+	err = of_property_read_string(node, "avdd-reg",
+			&board_priv_pdata->regulators.avdd);
+	if (err) {
+		dev_err(dev, "avdd-reg not in DT\n");
+		goto error;
+	}
+	err = of_property_read_string(node, "dvdd-reg",
+			&board_priv_pdata->regulators.dvdd);
+	if (err) {
+		dev_err(dev, "dvdd-reg not in DT\n");
+		goto error;
+	}
+
+	board_priv_pdata->has_eeprom =
+		of_property_read_bool(node, "has-eeprom");
+	board_priv_pdata->v_flip = of_property_read_bool(node, "vertical-flip");
+	board_priv_pdata->h_mirror = of_property_read_bool(node,
+							 "horizontal-mirror");
+
+	return board_priv_pdata;
+
+error:
+	devm_kfree(dev, board_priv_pdata);
+	return ret;
+}
+
+static int ov5640_set_mode(struct tegracam_device *tc_dev)
+{
+	struct ov5640 *priv = (struct ov5640 *)tegracam_get_privdata(tc_dev);
+	struct camera_common_data *s_data = tc_dev->s_data;
+	int err;
+
+	err = ov5640_write_table(priv, mode_table[s_data->mode_prop_idx]);
+	if (err)
+		return err;
+
+	return 0;
+}
+
+static int ov5640_start_streaming(struct tegracam_device *tc_dev)
+{
+	struct ov5640 *priv = (struct ov5640 *)tegracam_get_privdata(tc_dev);
+	struct camera_common_data *s_data = tc_dev->s_data;
+	struct camera_common_pdata *pdata = s_data->pdata;
+	struct device *dev = s_data->dev;
+	int err;
+	u8 val;
+
+	mutex_lock(&priv->streaming_lock);
+	err = ov5640_write_table(priv, mode_table[OV5640_MODE_START_STREAM]);
+	if (err) {
+		mutex_unlock(&priv->streaming_lock);
+		goto exit;
+	} else {
+		priv->streaming = true;
+		mutex_unlock(&priv->streaming_lock);
+	}
+	if (pdata->v_flip) {
+		ov5640_read_reg(s_data, OV5640_TIMING_REG20, &val);
+		ov5640_write_reg(s_data, OV5640_TIMING_REG20,
+				 val | VERTICAL_FLIP);
+	}
+	if (pdata->h_mirror) {
+		ov5640_read_reg(s_data, OV5640_TIMING_REG21, &val);
+		ov5640_write_reg(s_data, OV5640_TIMING_REG21,
+				 val | HORIZONTAL_MIRROR_MASK);
+	} else {
+		ov5640_read_reg(s_data, OV5640_TIMING_REG21, &val);
+		ov5640_write_reg(s_data, OV5640_TIMING_REG21,
+				 val & (~HORIZONTAL_MIRROR_MASK));
+	}
+	if (test_mode)
+		err = ov5640_write_table(priv,
+			mode_table[OV5640_MODE_TEST_PATTERN]);
+
+	return 0;
+
+exit:
+	dev_err(dev, "%s: error starting stream\n", __func__);
+	return err;
+}
+
+static int ov5640_stop_streaming(struct tegracam_device *tc_dev)
+{
+	struct camera_common_data *s_data = tc_dev->s_data;
+	struct ov5640 *priv = (struct ov5640 *)tegracam_get_privdata(tc_dev);
+	struct device *dev = s_data->dev;
+	u32 frame_time;
+	int err;
+
+	mutex_lock(&priv->streaming_lock);
+	err = ov5640_write_table(priv,
+		mode_table[OV5640_MODE_STOP_STREAM]);
+	if (err) {
+		mutex_unlock(&priv->streaming_lock);
+		goto exit;
+	} else {
+		priv->streaming = false;
+		mutex_unlock(&priv->streaming_lock);
+	}
+
+	/*
+	 * Wait for one frame to make sure sensor is set to
+	 * software standby in V-blank
+	 *
+	 * frame_time = frame length rows * Tline
+	 * Tline = line length / pixel clock (in MHz)
+	 */
+	frame_time = priv->frame_length *
+		OV5640_DEFAULT_LINE_LENGTH / OV5640_DEFAULT_PIXEL_CLOCK;
+
+	usleep_range(frame_time, frame_time + 1000);
+
+	return 0;
+
+exit:
+	dev_err(dev, "%s: error stopping stream\n", __func__);
+	return err;
+}
+
+static struct camera_common_sensor_ops ov5640_common_ops = {
+	.numfrmfmts = ARRAY_SIZE(ov5640_frmfmt),
+	.frmfmt_table = ov5640_frmfmt,
+	.power_on = ov5640_power_on,
+	.power_off = ov5640_power_off,
+	.write_reg = ov5640_write_reg,
+	.read_reg = ov5640_read_reg,
+	.parse_dt = ov5640_parse_dt,
+	.power_get = ov5640_power_get,
+	.power_put = ov5640_power_put,
+	.set_mode = ov5640_set_mode,
+	.start_streaming = ov5640_start_streaming,
+	.stop_streaming = ov5640_stop_streaming,
+};
+
+static int ov5640_debugfs_streaming_show(void *data, u64 *val)
+{
+	struct ov5640 *priv = data;
+
+	mutex_lock(&priv->streaming_lock);
+	*val = priv->streaming;
+	mutex_unlock(&priv->streaming_lock);
+
+	return 0;
+}
+
+static int ov5640_debugfs_streaming_write(void *data, u64 val)
+{
+	int err = 0;
+	struct ov5640 *priv = data;
+	struct i2c_client *client = priv->i2c_client;
+	bool enable = (val != 0);
+	int mode_index = enable ?
+		(OV5640_MODE_START_STREAM) : (OV5640_MODE_STOP_STREAM);
+
+	dev_info(&client->dev, "%s: %s sensor\n",
+			__func__, (enable ? "enabling" : "disabling"));
+
+	mutex_lock(&priv->streaming_lock);
+
+	err = ov5640_write_table(priv, mode_table[mode_index]);
+	if (err) {
+		dev_err(&client->dev, "%s: error setting sensor streaming\n",
+			__func__);
+		goto done;
+	}
+
+	priv->streaming = enable;
+
+done:
+	mutex_unlock(&priv->streaming_lock);
+
+	return err;
+}
+
+DEFINE_SIMPLE_ATTRIBUTE(ov5640_debugfs_streaming_fops,
+	ov5640_debugfs_streaming_show,
+	ov5640_debugfs_streaming_write,
+	"%lld\n");
+
+static void ov5640_debugfs_remove(struct ov5640 *priv);
+
+static int ov5640_debugfs_create(struct ov5640 *priv)
+{
+	int err = 0;
+	struct i2c_client *client = priv->i2c_client;
+	const char *devnode;
+	char debugfs_dir[16];
+
+	err = of_property_read_string(client->dev.of_node, "devnode", &devnode);
+	if (err) {
+		dev_err(&client->dev, "devnode not in DT\n");
+		return err;
+	}
+	snprintf(debugfs_dir, sizeof(debugfs_dir), "camera-%s", devnode);
+
+	priv->debugfs_dir = debugfs_create_dir(debugfs_dir, NULL);
+	if (priv->debugfs_dir == NULL)
+		return -ENOMEM;
+
+	if (!debugfs_create_file("streaming", 0644, priv->debugfs_dir, priv,
+			&ov5640_debugfs_streaming_fops))
+		goto error;
+
+	return 0;
+
+error:
+	ov5640_debugfs_remove(priv);
+
+	return -ENOMEM;
+}
+
+static struct tegracam_ctrl_ops ov5640_ctrl_ops = {
+	.numctrls = ARRAY_SIZE(ctrl_cid_list),
+	.ctrl_cid_list = ctrl_cid_list,
+	.string_ctrl_size = {OV5640_EEPROM_STR_SIZE,
+				OV5640_FUSE_ID_STR_SIZE,
+				OV5640_OTP_STR_SIZE},
+	.set_gain = ov5640_set_gain,
+	.set_exposure = ov5640_set_exposure,
+	.set_exposure_short = ov5640_set_exposure_short,
+	.set_frame_rate = ov5640_set_frame_rate,
+	.set_group_hold = ov5640_set_group_hold,
+	.fill_string_ctrl = ov5640_fill_string_ctrl,
+};
+
+static int ov5640_board_setup(struct ov5640 *priv)
+{
+	struct camera_common_data *s_data = priv->s_data;
+	struct device *dev = s_data->dev;
+	bool eeprom_ctrl = 0;
+	int err = 0;
+
+	dev_dbg(dev, "%s++\n", __func__);
+
+	/* eeprom interface */
+	err = ov5640_eeprom_device_init(priv);
+	if (err && s_data->pdata->has_eeprom)
+		dev_err(dev,
+			"Failed to allocate eeprom reg map: %d\n", err);
+	eeprom_ctrl = !err;
+
+	err = camera_common_mclk_enable(s_data);
+	if (err) {
+		dev_err(dev,
+			"Error %d turning on mclk\n", err);
+		return err;
+	}
+
+	err = ov5640_power_on(s_data);
+	if (err) {
+		dev_err(dev,
+			"Error %d during power on sensor\n", err);
+		return err;
+	}
+
+	if (eeprom_ctrl) {
+		err = ov5640_read_eeprom(priv);
+		if (err) {
+			dev_err(dev,
+				"Error %d reading eeprom\n", err);
+			goto error;
+		}
+	}
+
+	err = ov5640_otp_setup(priv);
+	if (err) {
+		dev_err(dev,
+			"Error %d reading otp data\n", err);
+		goto error;
+	}
+
+	err = ov5640_fuse_id_setup(priv);
+	if (err) {
+		dev_err(dev,
+			"Error %d reading fuse id data\n", err);
+		goto error;
+	}
+
+error:
+	ov5640_power_off(s_data);
+	camera_common_mclk_disable(s_data);
+	return err;
+}
+
+static void ov5640_debugfs_remove(struct ov5640 *priv)
+{
+	debugfs_remove_recursive(priv->debugfs_dir);
+	priv->debugfs_dir = NULL;
+}
+
+static int ov5640_open(struct v4l2_subdev *sd, struct v4l2_subdev_fh *fh)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+
+	dev_dbg(&client->dev, "%s:\n", __func__);
+	return 0;
+}
+
+static const struct v4l2_subdev_internal_ops ov5640_subdev_internal_ops = {
+	.open = ov5640_open,
+};
+
+static int ov5640_probe(struct i2c_client *client,
+			const struct i2c_device_id *id)
+{
+	struct device *dev = &client->dev;
+	struct device_node *node = client->dev.of_node;
+	struct tegracam_device *tc_dev;
+	struct ov5640 *priv;
+	int err;
+	const struct of_device_id *match;
+
+	dev_info(dev, "probing v4l2 sensor.\n");
+
+	match = of_match_device(ov5640_of_match, dev);
+	if (!match) {
+		dev_err(dev, "No device match found\n");
+		return -ENODEV;
+	}
+
+	if (!IS_ENABLED(CONFIG_OF) || !node)
+		return -EINVAL;
+
+	priv = devm_kzalloc(dev,
+			    sizeof(struct ov5640), GFP_KERNEL);
+	if (!priv)
+		return -ENOMEM;
+
+	tc_dev = devm_kzalloc(dev,
+			    sizeof(struct tegracam_device), GFP_KERNEL);
+	if (!tc_dev)
+		return -ENOMEM;
+
+	priv->i2c_client = tc_dev->client = client;
+	tc_dev->dev = dev;
+	strncpy(tc_dev->name, "ov5640", sizeof(tc_dev->name));
+	tc_dev->dev_regmap_config = &ov5640_regmap_config;
+	tc_dev->sensor_ops = &ov5640_common_ops;
+	tc_dev->v4l2sd_internal_ops = &ov5640_subdev_internal_ops;
+	tc_dev->tcctrl_ops = &ov5640_ctrl_ops;
+
+	err = tegracam_device_register(tc_dev);
+	if (err) {
+		dev_err(dev, "tegra camera driver registration failed\n");
+		return err;
+	}
+
+	priv->tc_dev = tc_dev;
+	priv->s_data = tc_dev->s_data;
+	priv->subdev = &tc_dev->s_data->subdev;
+	tegracam_set_privdata(tc_dev, (void *)priv);
+	mutex_init(&priv->streaming_lock);
+
+	err = ov5640_board_setup(priv);
+		if (err) {
+			dev_err(dev, "board setup failed\n");
+			return err;
+	}
+
+	err = tegracam_v4l2subdev_register(tc_dev, true);
+	if (err) {
+		dev_err(dev, "tegra camera subdev registration failed\n");
+		return err;
+	}
+
+	err = ov5640_debugfs_create(priv);
+	if (err) {
+		dev_err(dev, "error creating debugfs interface");
+		ov5640_debugfs_remove(priv);
+		return err;
+	}
+
+	dev_dbg(dev, "Detected OV5640 sensor\n");
+
+	return 0;
+}
+
+static int
+ov5640_remove(struct i2c_client *client)
+{
+	struct camera_common_data *s_data = to_camera_common_data(&client->dev);
+	struct ov5640 *priv = (struct ov5640 *)s_data->priv;
+
+	ov5640_debugfs_remove(priv);
+
+	tegracam_v4l2subdev_unregister(priv->tc_dev);
+	ov5640_power_put(priv->tc_dev);
+	tegracam_device_unregister(priv->tc_dev);
+	ov5640_eeprom_device_release(priv);
+
+	mutex_destroy(&priv->streaming_lock);
+
+	return 0;
+}
+
+static const struct i2c_device_id ov5640_id[] = {
+	{ "ov5640", 0 },
+	{ }
+};
+
+MODULE_DEVICE_TABLE(i2c, ov5640_id);
+
+static struct i2c_driver ov5640_i2c_driver = {
+	.driver = {
+		.name = "ov5640",
+		.owner = THIS_MODULE,
+		.of_match_table = of_match_ptr(ov5640_of_match),
+	},
+	.probe = ov5640_probe,
+	.remove = ov5640_remove,
+	.id_table = ov5640_id,
+};
+module_i2c_driver(ov5640_i2c_driver);
+
+MODULE_DESCRIPTION("Media Controller driver for OmniVision OV5640");
+MODULE_AUTHOR("NVIDIA Corporation");
+MODULE_LICENSE("GPL v2");
diff --git a/nvidia/drivers/media/i2c/ov5640_mode_tbls.h b/nvidia/drivers/media/i2c/ov5640_mode_tbls.h
new file mode 100755
index 000000000000..bec1acd873f4
--- /dev/null
+++ b/nvidia/drivers/media/i2c/ov5640_mode_tbls.h
@@ -0,0 +1,377 @@
+/*
+ * ov5640_mode_tbls.h - ov5640 sensor mode tables
+ *
+ * Copyright (c) 2015-2017, NVIDIA CORPORATION, All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#ifndef __OV5640_TABLES__
+#define __OV5640_TABLES__
+
+#include <media/camera_common.h>
+
+#define OV5640_TABLE_WAIT_MS	0
+#define OV5640_TABLE_END	1
+#define OV5640_MAX_RETRIES	3
+#define OV5640_WAIT_MS		10
+
+#define ov5640_reg struct reg_8
+
+static const ov5640_reg ov5640_start[] = {
+	{0x3008, 0x02}, /* mode select streaming on */
+	{OV5640_TABLE_END, 0x00}
+};
+
+static const ov5640_reg ov5640_stop[] = {
+	{0x3008, 0x42}, /* mode select streaming on */
+	{OV5640_TABLE_END, 0x00}
+};
+
+static const ov5640_reg tp_colorbars[] = {
+	{0x503d, 0x80},
+
+	{OV5640_TABLE_WAIT_MS, OV5640_WAIT_MS},
+	{OV5640_TABLE_END, 0x00}
+};
+
+static const ov5640_reg mode_1920x1080[] = {
+	{OV5640_TABLE_WAIT_MS, OV5640_WAIT_MS},
+
+	{0x3103, 0x11}, // global settings
+    {0x3103, 0x11},
+    {0x3008, 0x82}, // reset
+    {OV5640_TABLE_WAIT_MS, 0x1e},// delay here of 30ms
+    {0x3008, 0x42}, // power down
+    {0x3103, 0x03},
+    {0x3017, 0x00}, // disable oe
+    {0x3018, 0x00},
+
+    // PLL settings - RAW10, MIPISCLK = 420, SCLK = 84MHz, PCLK=84M
+    // {0x3034, 0x18}, // 8bit
+    {0x3034, 0x1a}, // 10bit - /2.5 of PLL
+    // {0x3035, 0x11},
+    {0x3035, 0x21}, // sys div /2, mipi  div /1 == MIPISCLK = 420MHz
+    // {0x3036, 0x54}, // 0x46 - 30fps,
+    {0x3036, 0x69}, // 0x69 = 105 mult - VCO = 840MHz
+    {0x3037, 0x03}, // div - pre div = /3 -> 8MHz, PLL root divider - /1
+    // {0x3037, 0x08},
+    // {0x3108, 0x01},
+    {0x3108, 0x11}, // PCLK root div /2, SCLK2x div /1, SCLK root div /2 -> PLL = 420MHz, 
+    {0x3824, 0x01},
+    {OV5640_TABLE_WAIT_MS,0x05}, // delay 5ms
+
+    {0x3630, 0x36},
+    {0x3631, 0x0e},
+    {0x3632, 0xe2},
+    {0x3633, 0x12},
+    {0x3621, 0xe0},
+    {0x3704, 0xa0},
+    {0x3703, 0x5a},
+    {0x3715, 0x78},
+    {0x3717, 0x01},
+    {0x370b, 0x60},
+    {0x3705, 0x1a},
+    {0x3905, 0x02},
+    {0x3906, 0x10},
+    {0x3901, 0x0a},
+    {0x3731, 0x12},
+    {0x3600, 0x08},
+    {0x3601, 0x33},
+    {0x302d, 0x60},
+    {0x3620, 0x52},
+    {0x371b, 0x20},
+    {0x471c, 0x50},
+    {0x3a13, 0x43},
+    {0x3a18, 0x00},
+    {0x3a19, 0xf8}, // AGC ceiling
+    {0x3635, 0x13},
+    {0x3636, 0x03},
+    {0x3634, 0x40},
+    {0x3622, 0x01},
+    {0x3c01, 0x34}, //Band manual enable
+    
+    {0x3c04, 0x28},
+    {0x3c05, 0x98},
+    {0x3c06, 0x00},
+    {0x3c07, 0x07}, // spec light meter threshold
+
+    {0x3c08, 0x00},
+    {0x3c09, 0x1c},
+    {0x3c0a, 0x9c},
+    {0x3c0b, 0x40},
+
+    {0x3820, 0x40}, // timing control
+    {0x3821, 0x06}, // timing control
+
+    {0x3814, 0x11},
+    {0x3815, 0x11},
+
+    {0x3800, 0x01}, // size setup
+    {0x3801, 0x50},
+    {0x3802, 0x01},
+    {0x3803, 0xb2},
+    {0x3804, 0x08},
+    {0x3805, 0xef},
+    {0x3806, 0x05},
+    {0x3807, 0xf1},
+    {0x3808, 0x07},
+    {0x3809, 0x80},
+    {0x380a, 0x04},
+    {0x380b, 0x38},
+    {0x380c, 0x09},
+    {0x380d, 0xc4},
+    {0x380e, 0x04},
+    {0x380f, 0x60},
+
+    {0x3810, 0x00},
+    {0x3811, 0x10},
+    {0x3812, 0x00},
+
+    {0x3813, 0x04},
+    {0x3618, 0x04},
+    {0x3612, 0x2b},
+    {0x3708, 0x64},
+    {0x3709, 0x12},
+    {0x370c, 0x00},
+    {0x3a02, 0x04},
+    {0x3a03, 0x60},
+    {0x3a08, 0x01},
+    {0x3a09, 0x50},
+    {0x3a0b, 0x18},
+    {0x3a0e, 0x03},
+    {0x3a0d, 0x04},
+    {0x3a14, 0x04},
+    {0x3a15, 0x60},
+
+    {0x3503, 0x03}, //AEC Manual mode
+
+    {0x4001, 0x02},
+    {0x4004, 0x06}, // black line control process
+
+    {0x3000, 0x00}, // no resets
+    {0x3002, 0x1c},
+    {0x3004, 0xff},
+    {0x3006, 0xc3},
+
+    {0x300e, 0x45},  //  2 lane MIPI, MIPI enable, DEBUG
+    {0x302e, 0x08},
+
+    // {0x4300, 0x32}, // UYVY
+    {0x4300, 0xf8}, // RAW BGGR
+    {0x501f, 0x03}, // ISP RAW (DPC)
+    {0x4713, 0x02},
+    {0x4407, 0x04},
+    {0x440e, 0x00},
+
+    {0x460c, 0x20},
+    {0x4837, 24},  // PCLK period = 1/PCLK in ns * 2 (depends on # of lanes)
+    {0x5000, 0x06}, //CHANGED ..Gamma enable = bad
+    {0x5001, 0x00},
+    {0x3a0f, 0x30},       
+    {0x3a10, 0x28},
+    {0x3a1b, 0x30},
+    {0x3a1e, 0x26},
+    {0x3a11, 0x60},
+    {0x3a1f, 0x14},
+    {0x3008, 0x02},
+
+
+	{OV5640_TABLE_END, 0x0000}
+};
+
+static const ov5640_reg mode_2592x1944[] = {
+    {OV5640_TABLE_WAIT_MS, OV5640_WAIT_MS},
+
+	{0x3103, 0x11}, // global settings
+    {0x3103, 0x11},
+    {0x3008, 0x82}, // reset
+    {OV5640_TABLE_WAIT_MS, 0x1e},// delay here of 30ms
+    {0x3008, 0x42}, // power down
+    {0x3103, 0x03},
+    {0x3017, 0x00}, // disable oe
+    {0x3018, 0x00},
+
+    // PLL settings - RAW10, MIPISCLK = 420, SCLK = 84MHz, PCLK=84M
+    //{0x3034, 0x18}, // 8bit
+    {0x3034, 0x1a}, // 10bit - /2.5 of PLL
+    {0x3035, 0x12},
+    // {0x3035, 0x21}, // sys div /2, mipi  div /1 == MIPISCLK = 420MHz
+    // {0x3036, 0x54}, // 0x46 - 30fps,
+    {0x3036, 0x69}, // 0x69 = 105 mult - VCO = 840MHz
+    {0x3037, 0x13}, // div - pre div = /3 -> 8MHz, PLL root divider - /2
+    // {0x3037, 0x03}, // div - pre div = /3 -> 8MHz, PLL root divider - /1
+
+    {0x3108, 0x11}, // PCLK root div /2, SCLK2x div /1, SCLK root div /2 -> PLL = 420MHz, 
+    {0x3824, 0x01},
+    {OV5640_TABLE_WAIT_MS,0x05}, // delay 5ms
+
+    {0x3630, 0x36},
+    {0x3631, 0x0e},
+    {0x3632, 0xe2},
+    {0x3633, 0x12},
+    {0x3621, 0xe0},
+    {0x3704, 0xa0},
+    {0x3703, 0x5a},
+    {0x3715, 0x78},
+    {0x3717, 0x01},
+    {0x370b, 0x60},
+    {0x3705, 0x1a},
+    {0x3905, 0x02},
+    {0x3906, 0x10},
+    {0x3901, 0x0a},
+    {0x3731, 0x12},
+    {0x3600, 0x08},
+    {0x3601, 0x33},
+    {0x302d, 0x60},
+    {0x3620, 0x52},
+    {0x371b, 0x20},
+    {0x471c, 0x50},
+    {0x3a13, 0x43},
+    {0x3a18, 0x00},
+    {0x3a19, 0xf8}, // AGC ceiling
+    {0x3635, 0x13},
+    {0x3636, 0x03},
+    {0x3634, 0x40},
+    {0x3622, 0x01},
+    {0x3c01, 0x34}, //Band manual enable
+    
+    {0x3c04, 0x28},
+    {0x3c05, 0x98},
+    {0x3c06, 0x00},
+    {0x3c07, 0x07}, // spec light meter threshold
+
+    {0x3c08, 0x00},
+    {0x3c09, 0x1c},
+    {0x3c0a, 0x9c},
+    {0x3c0b, 0x40},
+
+    {0x3820, 0x40}, // timing control
+    {0x3821, 0x00}, // timing control
+
+    {0x3814, 0x11},
+    {0x3815, 0x11},
+
+    {0x3800, 0x00}, // size setup
+    {0x3801, 0x00},
+    {0x3802, 0x00},
+    {0x3803, 0x00},
+    {0x3804, 0x0a},
+    {0x3805, 0x3f},
+    {0x3806, 0x07},
+    {0x3807, 0x9f},
+    {0x3808, 0x0a},
+    {0x3809, 0x20},
+    {0x380a, 0x07},
+    {0x380b, 0x98},
+    {0x380c, 0x0b},
+    {0x380d, 0x1c},
+    {0x380e, 0x07},
+    {0x380f, 0xb0},
+
+    {0x3810, 0x00},
+    {0x3811, 0x10},
+    {0x3812, 0x00},
+
+    {0x3813, 0x04},
+    {0x3618, 0x04},
+    {0x3612, 0x2b},
+    {0x3708, 0x63},
+    {0x3709, 0x12},
+    {0x370c, 0x00},
+    {0x3a02, 0x07},
+    {0x3a03, 0xb0},
+    {0x3a08, 0x01},
+    {0x3a09, 0x27},
+    {0x3a0a, 0x00},
+    {0x3a0b, 0xf6},
+    {0x3a0e, 0x06},
+    {0x3a0d, 0x08},
+    {0x3a14, 0x07},
+    {0x3a15, 0xb0},
+
+    {0x3503, 0x03}, //AEC Manual mode
+
+    {0x4001, 0x02},
+    {0x4004, 0x06}, // black line control process
+    {0x4050, 0x6e},
+    {0x4051, 0x8f},
+    {0x3000, 0x00}, // no resets
+    {0x3002, 0x1c},
+    {0x3004, 0xff},
+    {0x3006, 0xc3},
+
+    {0x300e, 0x45},  //  2 lane MIPI, MIPI enable, DEBUG
+    {0x302e, 0x08},
+
+    // {0x4300, 0x32}, // UYVY
+    {0x4300, 0xf8}, // RAW BGGR
+    {0x501f, 0x03}, // ISP RAW (DPC)
+    {0x5684, 0x0a},
+    {0x5685, 0x20},
+    {0x5686, 0x07},
+    {0x5687, 0x98},
+    {0x440e, 0x00},
+
+    
+    {0x4837, 24},  // PCLK period = 1/PCLK in ns * 2 (depends on # of lanes)
+    {0x5000, 0x06}, //CHANGED ..Gamma enable = bad
+    {0x5001, 0x00},
+    {0x3a0f, 0x36},       
+    {0x3a10, 0x2e},
+    {0x3a1b, 0x38},
+    {0x3a1e, 0x2c},
+    {0x3a11, 0x70},
+    {0x3a1f, 0x18},
+    {0x3008, 0x02},
+
+
+	{OV5640_TABLE_END, 0x0000}
+    
+};
+
+enum {
+	OV5640_MODE_1920X1080,
+	OV5640_MODE_START_STREAM,
+	OV5640_MODE_STOP_STREAM,
+	OV5640_MODE_TEST_PATTERN
+};
+
+static const ov5640_reg *mode_table[] = {
+	[OV5640_MODE_1920X1080]			= mode_1920x1080,
+    [OV5640_MODE_START_STREAM]		= ov5640_start,
+	[OV5640_MODE_STOP_STREAM]		= ov5640_stop,
+	[OV5640_MODE_TEST_PATTERN]		= tp_colorbars,
+};
+
+static const int ov5640_15fps[] = {
+	15,
+};
+
+static const int ov5640_24fps[] = {
+	24,
+};
+
+static const int ov5640_30fps[] = {
+	30,
+};
+
+static const int ov5640_120fps[] = {
+	120,
+};
+
+static const struct camera_common_frmfmt ov5640_frmfmt[] = {
+	{{1920, 1080},	ov5640_30fps,	1, 0,	OV5640_MODE_1920X1080},
+};
+#endif  /* __OV5640_TABLES__ */
+
diff --git a/nvidia/drivers/media/i2c/ov5670.c b/nvidia/drivers/media/i2c/ov5670.c
new file mode 100644
index 000000000000..3c22f60f4e63
--- /dev/null
+++ b/nvidia/drivers/media/i2c/ov5670.c
@@ -0,0 +1,1268 @@
+/*
+ * ov5670_v4l2.c - ov5670 sensor driver
+ *
+ * Copyright (c) 2013-2019, NVIDIA CORPORATION.  All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include <linux/slab.h>
+#include <linux/uaccess.h>
+#include <linux/gpio.h>
+#include <linux/module.h>
+#include <linux/debugfs.h>
+
+#include <linux/seq_file.h>
+#include <linux/of.h>
+#include <linux/of_device.h>
+#include <linux/of_gpio.h>
+#include <media/tegra-v4l2-camera.h>
+#include <media/tegracam_core.h>
+#include <media/ov5670.h>
+
+
+#include "../platform/tegra/camera/camera_gpio.h"
+
+#include "ov5670_mode_tbls.h"
+#define CREATE_TRACE_POINTS
+#include <trace/events/ov5670.h>
+
+#define OV5670_MAX_COARSE_DIFF		6
+#define OV5670_MAX_FRAME_LENGTH	(0x7fff)
+#define OV5670_MIN_EXPOSURE_COARSE	(0x0002)
+#define OV5670_MAX_EXPOSURE_COARSE	\
+	(OV5670_MAX_FRAME_LENGTH-OV5670_MAX_COARSE_DIFF)
+#define OV5670_DEFAULT_LINE_LENGTH	(0xA80)
+#define OV5670_DEFAULT_PIXEL_CLOCK	(240)
+#define OV5670_DEFAULT_FRAME_LENGTH	(0x07C0)
+#define OV5670_DEFAULT_EXPOSURE_COARSE	\
+	(OV5670_DEFAULT_FRAME_LENGTH-OV5670_MAX_COARSE_DIFF)
+
+static const u32 ctrl_cid_list[] = {
+	TEGRA_CAMERA_CID_GAIN,
+	TEGRA_CAMERA_CID_EXPOSURE,
+	TEGRA_CAMERA_CID_EXPOSURE_SHORT,
+	TEGRA_CAMERA_CID_FRAME_RATE,
+	TEGRA_CAMERA_CID_GROUP_HOLD,
+	TEGRA_CAMERA_CID_HDR_EN,
+	TEGRA_CAMERA_CID_EEPROM_DATA,
+	TEGRA_CAMERA_CID_OTP_DATA,
+	TEGRA_CAMERA_CID_FUSE_ID,
+};
+
+struct ov5670 {
+	struct camera_common_eeprom_data eeprom[OV5670_EEPROM_NUM_BLOCKS];
+	u8				eeprom_buf[OV5670_EEPROM_SIZE];
+	u8				otp_buf[OV5670_OTP_SIZE];
+	struct i2c_client		*i2c_client;
+	struct v4l2_subdev		*subdev;
+	u8				fuse_id[OV5670_FUSE_ID_SIZE];
+	const char			*devname;
+	struct dentry			*debugfs_dir;
+	struct mutex			streaming_lock;
+	bool				streaming;
+
+	s32				group_hold_prev;
+	u32				frame_length;
+	bool				group_hold_en;
+	struct camera_common_i2c	i2c_dev;
+	struct camera_common_data	*s_data;
+	struct tegracam_device		*tc_dev;
+};
+
+static struct regmap_config ov5670_regmap_config = {
+	.reg_bits = 16,
+	.val_bits = 8,
+};
+
+static inline void ov5670_get_frame_length_regs(ov5670_reg *regs,
+				u32 frame_length)
+{
+	regs->addr = OV5670_FRAME_LENGTH_ADDR_MSB;
+	regs->val = (frame_length >> 8) & 0xff;
+	(regs + 1)->addr = OV5670_FRAME_LENGTH_ADDR_LSB;
+	(regs + 1)->val = (frame_length) & 0xff;
+}
+
+static inline void ov5670_get_coarse_time_regs(ov5670_reg *regs,
+				u32 coarse_time)
+{
+	regs->addr = OV5670_COARSE_TIME_ADDR_1;
+	regs->val = (coarse_time >> 12) & 0xff;
+	(regs + 1)->addr = OV5670_COARSE_TIME_ADDR_2;
+	(regs + 1)->val = (coarse_time >> 4) & 0xff;
+	(regs + 2)->addr = OV5670_COARSE_TIME_ADDR_3;
+	(regs + 2)->val = (coarse_time & 0xf) << 4;
+}
+
+static inline void ov5670_get_coarse_time_short_regs(ov5670_reg *regs,
+				u32 coarse_time)
+{
+	regs->addr = OV5670_COARSE_TIME_SHORT_ADDR_1;
+	regs->val = (coarse_time >> 12) & 0xff;
+	(regs + 1)->addr = OV5670_COARSE_TIME_SHORT_ADDR_2;
+	(regs + 1)->val = (coarse_time >> 4) & 0xff;
+	(regs + 2)->addr = OV5670_COARSE_TIME_SHORT_ADDR_3;
+	(regs + 2)->val = (coarse_time & 0xf) << 4;
+}
+
+static inline void ov5670_get_gain_regs(ov5670_reg *regs,
+				u16 gain)
+{
+	regs->addr = OV5670_GAIN_ADDR_MSB;
+	regs->val = (gain >> 8) & 0xff;
+
+	(regs + 1)->addr = OV5670_GAIN_ADDR_LSB;
+	(regs + 1)->val = (gain) & 0xff;
+}
+
+static int test_mode;
+module_param(test_mode, int, 0644);
+
+static inline int ov5670_read_reg(struct camera_common_data *s_data,
+				u16 addr, u8 *val)
+{
+	int err = 0;
+	u32 reg_val = 0;
+
+	err = regmap_read(s_data->regmap, addr, &reg_val);
+	*val = reg_val & 0xFF;
+
+	return err;
+}
+
+static int ov5670_write_reg(struct camera_common_data *s_data, u16 addr, u8 val)
+{
+	int err;
+	struct device *dev = s_data->dev;
+
+	err = regmap_write(s_data->regmap, addr, val);
+
+	if (err)
+		dev_err(dev, "%s: i2c write failed, 0x%x = %x\n",
+			__func__, addr, val);
+
+	return err;
+}
+
+static int ov5670_write_table(struct ov5670 *priv,
+			      const ov5670_reg table[])
+{
+	struct camera_common_data *s_data = priv->s_data;
+
+	return regmap_util_write_table_8(s_data->regmap,
+					 table,
+					 NULL, 0,
+					 OV5670_TABLE_WAIT_MS,
+					 OV5670_TABLE_END);
+}
+
+static void ov5670_gpio_set(struct camera_common_data *s_data,
+			    unsigned int gpio, int val)
+{
+	struct camera_common_pdata *pdata = s_data->pdata;
+
+	if (pdata && pdata->use_cam_gpio)
+		cam_gpio_ctrl(s_data->dev, gpio, val, 1);
+	else {
+		if (gpio_cansleep(gpio))
+			gpio_set_value_cansleep(gpio, val);
+		else
+			gpio_set_value(gpio, val);
+	}
+}
+
+static int ov5670_power_on(struct camera_common_data *s_data)
+{
+	int err = 0;
+	struct camera_common_power_rail *pw = s_data->power;
+	struct camera_common_pdata *pdata = s_data->pdata;
+	struct device *dev = s_data->dev;
+	u32 frame_time;
+
+	dev_dbg(dev, "%s: power on\n", __func__);
+
+	if (pdata && pdata->power_on) {
+		err = pdata->power_on(pw);
+		if (err)
+			dev_err(dev, "%s failed.\n", __func__);
+		else
+			pw->state = SWITCH_ON;
+		return err;
+	}
+	/* sleeps calls in the sequence below are for internal device
+	 * signal propagation as specified by sensor vendor
+	 */
+
+	if (pw->avdd)
+		err = regulator_enable(pw->avdd);
+	if (err)
+		goto ov5670_avdd_fail;
+
+	if (pw->dvdd)
+		err = regulator_enable(pw->dvdd);
+	if (err)
+		goto ov5670_dvdd_fail;
+
+	usleep_range(1, 2);
+	if (gpio_is_valid(pw->pwdn_gpio))
+		ov5670_gpio_set(s_data, pw->pwdn_gpio, 1);
+
+	/*
+	 * datasheet 2.9: reset requires ~2ms settling time
+	 * a power on reset is generated after core power becomes stable
+	 */
+	usleep_range(2000, 2010);
+
+	if (gpio_is_valid(pw->reset_gpio))
+		ov5670_gpio_set(s_data, pw->reset_gpio, 1);
+
+	/* datasheet fig 2-9: t3 */
+	usleep_range(2000, 2010);
+
+	pw->state = SWITCH_ON;
+
+	ov5670_write_reg(s_data, 0x0100, 0x01);
+	ov5670_write_reg(s_data, 0x0100, 0x00);
+
+	frame_time = OV5670_DEFAULT_FRAME_LENGTH *
+			OV5670_DEFAULT_LINE_LENGTH / OV5670_DEFAULT_PIXEL_CLOCK;
+	usleep_range(frame_time, frame_time + 1000);
+
+	return 0;
+
+ov5670_dvdd_fail:
+	regulator_disable(pw->avdd);
+
+ov5670_avdd_fail:
+	dev_err(dev, "%s failed.\n", __func__);
+	return -ENODEV;
+}
+
+static int ov5670_power_off(struct camera_common_data *s_data)
+{
+	int err = 0;
+	struct camera_common_power_rail *pw = s_data->power;
+	struct device *dev = s_data->dev;
+	struct camera_common_pdata *pdata = s_data->pdata;
+
+	dev_dbg(dev, "%s: power off\n", __func__);
+
+	if (pdata && pdata->power_off) {
+		err = pdata->power_off(pw);
+		if (!err) {
+			goto power_off_done;
+		} else {
+			dev_err(dev, "%s failed.\n", __func__);
+			return err;
+		}
+	}
+
+	/* sleeps calls in the sequence below are for internal device
+	 * signal propagation as specified by sensor vendor
+	 */
+	usleep_range(21, 25);
+	if (gpio_is_valid(pw->pwdn_gpio))
+		ov5670_gpio_set(s_data, pw->pwdn_gpio, 0);
+	usleep_range(1, 2);
+	if (gpio_is_valid(pw->reset_gpio))
+		ov5670_gpio_set(s_data, pw->reset_gpio, 0);
+
+	/* datasheet 2.9: reset requires ~2ms settling time*/
+	usleep_range(2000, 2010);
+
+	if (pw->dvdd)
+		regulator_disable(pw->dvdd);
+	if (pw->avdd)
+		regulator_disable(pw->avdd);
+
+power_off_done:
+	pw->state = SWITCH_OFF;
+	return 0;
+}
+
+static int ov5670_power_put(struct tegracam_device *tc_dev)
+{
+	struct camera_common_data *s_data = tc_dev->s_data;
+	struct camera_common_power_rail *pw = s_data->power;
+	struct camera_common_pdata *pdata = s_data->pdata;
+	struct device *dev = tc_dev->dev;
+
+	if (unlikely(!pw))
+		return -EFAULT;
+
+	if (pdata && pdata->use_cam_gpio)
+		cam_gpio_deregister(dev, pw->pwdn_gpio);
+	else {
+		if (gpio_is_valid(pw->pwdn_gpio))
+			gpio_free(pw->pwdn_gpio);
+		if (gpio_is_valid(pw->reset_gpio))
+			gpio_free(pw->reset_gpio);
+	}
+
+	return 0;
+}
+
+static int ov5670_power_get(struct tegracam_device *tc_dev)
+{
+	struct camera_common_data *s_data = tc_dev->s_data;
+	struct camera_common_power_rail *pw = s_data->power;
+	struct camera_common_pdata *pdata = s_data->pdata;
+	struct device *dev = tc_dev->dev;
+	const char *mclk_name;
+	const char *parentclk_name;
+	struct clk *parent;
+	int err = 0, ret = 0;
+
+	if (!pdata) {
+		dev_err(dev, "pdata missing\n");
+		return -EFAULT;
+	}
+
+	mclk_name = pdata->mclk_name ?
+		    pdata->mclk_name : "cam_mclk1";
+	pw->mclk = devm_clk_get(dev, mclk_name);
+	if (IS_ERR(pw->mclk)) {
+		dev_err(dev, "unable to get clock %s\n", mclk_name);
+		return PTR_ERR(pw->mclk);
+	}
+	parentclk_name = pdata->parentclk_name;
+	if (parentclk_name) {
+		parent = devm_clk_get(dev, parentclk_name);
+		if (IS_ERR(parent)) {
+			dev_err(dev, "unable to get parent clcok %s",
+				parentclk_name);
+		} else
+			clk_set_parent(pw->mclk, parent);
+	}
+
+	/* analog 2.8v */
+	err |= camera_common_regulator_get(dev,
+			&pw->avdd, pdata->regulators.avdd);
+	/* DVDD 1.5v */
+	err |= camera_common_regulator_get(dev,
+			&pw->dvdd, pdata->regulators.dvdd);
+
+	if (!err) {
+		pw->reset_gpio = pdata->reset_gpio;
+		pw->pwdn_gpio = pdata->pwdn_gpio;
+	}
+	if (pdata->use_cam_gpio) {
+		err = cam_gpio_register(dev, pw->pwdn_gpio);
+		if (err)
+			dev_err(dev, "%s ERR can't register cam gpio %u!\n",
+				 __func__, pw->pwdn_gpio);
+	} else {
+		if (gpio_is_valid(pw->pwdn_gpio)) {
+			ret = gpio_request(pw->pwdn_gpio, "cam_pwdn_gpio");
+			if (ret < 0) {
+				dev_dbg(dev, "%s can't request pwdn_gpio %d\n",
+					__func__, ret);
+			}
+			gpio_direction_output(pw->pwdn_gpio, 1);
+		}
+		if (gpio_is_valid(pw->reset_gpio)) {
+			ret = gpio_request(pw->reset_gpio, "cam_reset_gpio");
+			if (ret < 0) {
+				dev_dbg(dev, "%s can't request reset_gpio %d\n",
+					__func__, ret);
+			}
+			gpio_direction_output(pw->reset_gpio, 1);
+		}
+	}
+
+	pw->state = SWITCH_OFF;
+	return err;
+}
+
+static int ov5670_set_gain(struct tegracam_device *tc_dev, s64 val);
+static int ov5670_set_frame_rate(struct tegracam_device *tc_dev, s64 val);
+static int ov5670_set_exposure(struct tegracam_device *tc_dev, s64 val);
+static int ov5670_set_exposure_short(struct tegracam_device *tc_dev, s64 val);
+
+static const struct of_device_id ov5670_of_match[] = {
+	{
+		.compatible = "nvidia,ov5670",
+	},
+	{ },
+};
+
+static int ov5670_set_group_hold(struct tegracam_device *tc_dev, bool val)
+{
+	int err;
+	struct ov5670 *priv = tc_dev->priv;
+	int gh_prev = switch_ctrl_qmenu[priv->group_hold_prev];
+	struct device *dev = tc_dev->dev;
+
+	if (priv->group_hold_en == true && gh_prev == SWITCH_OFF) {
+		camera_common_i2c_aggregate(&priv->i2c_dev, true);
+		/* enter group hold */
+		err = ov5670_write_reg(priv->s_data,
+				       OV5670_GROUP_HOLD_ADDR, val);
+		if (err)
+			goto fail;
+
+		priv->group_hold_prev = 1;
+
+		dev_dbg(dev, "%s: enter group hold\n", __func__);
+	} else if (priv->group_hold_en == false && gh_prev == SWITCH_ON) {
+		/* leave group hold */
+		err = ov5670_write_reg(priv->s_data,
+				       OV5670_GROUP_HOLD_ADDR, 0x11);
+		if (err)
+			goto fail;
+
+		err = ov5670_write_reg(priv->s_data,
+				       OV5670_GROUP_HOLD_ADDR, 0x61);
+		if (err)
+			goto fail;
+
+		camera_common_i2c_aggregate(&priv->i2c_dev, false);
+
+		priv->group_hold_prev = 0;
+
+		dev_dbg(dev, "%s: leave group hold\n", __func__);
+	}
+
+	return 0;
+
+fail:
+	dev_dbg(dev, "%s: Group hold control error\n", __func__);
+	return err;
+}
+
+static int ov5670_set_gain(struct tegracam_device *tc_dev, s64 val)
+{
+	struct camera_common_data *s_data = tc_dev->s_data;
+	struct ov5670 *priv = (struct ov5670 *)tc_dev->priv;
+	struct device *dev = tc_dev->dev;
+	const struct sensor_mode_properties *mode =
+		&s_data->sensor_props.sensor_modes[s_data->mode_prop_idx];
+	ov5670_reg reg_list[2];
+	int err;
+	u16 gain;
+	int i;
+
+	if (!priv->group_hold_prev)
+		ov5670_set_group_hold(tc_dev, 1);
+
+	/* translate value */
+	gain = (u16) (((val * 16) +
+			(mode->control_properties.gain_factor / 2)) /
+			mode->control_properties.gain_factor);
+	ov5670_get_gain_regs(reg_list, gain);
+	dev_dbg(dev, "%s: gain %d val: %lld\n", __func__, gain, val);
+
+	for (i = 0; i < 2; i++) {
+		err = ov5670_write_reg(s_data, reg_list[i].addr,
+			 reg_list[i].val);
+		if (err)
+			goto fail;
+	}
+
+	return 0;
+
+fail:
+	dev_dbg(dev, "%s: GAIN control error\n", __func__);
+	return err;
+}
+
+static int ov5670_set_frame_rate(struct tegracam_device *tc_dev, s64 val)
+{
+	struct camera_common_data *s_data = tc_dev->s_data;
+	struct device *dev = tc_dev->dev;
+	struct ov5670 *priv = tc_dev->priv;
+	const struct sensor_mode_properties *mode =
+		&s_data->sensor_props.sensor_modes[s_data->mode_prop_idx];
+	ov5670_reg reg_list[2];
+	int err;
+	u32 frame_length;
+	int i;
+
+	if (!priv->group_hold_prev)
+		ov5670_set_group_hold(tc_dev, 1);
+
+	frame_length =  mode->signal_properties.pixel_clock.val *
+		mode->control_properties.framerate_factor /
+		mode->image_properties.line_length / val;
+
+	ov5670_get_frame_length_regs(reg_list, frame_length);
+	dev_dbg(dev, "%s: val: %d\n", __func__, frame_length);
+
+	for (i = 0; i < 2; i++) {
+		err = ov5670_write_reg(s_data, reg_list[i].addr,
+			 reg_list[i].val);
+		if (err)
+			goto fail;
+	}
+
+	priv->frame_length = frame_length;
+
+	return 0;
+
+fail:
+	dev_dbg(dev, "%s: FRAME_LENGTH control error\n", __func__);
+	return err;
+}
+
+static int ov5670_set_exposure(struct tegracam_device *tc_dev, s64 val)
+{
+	struct camera_common_data *s_data = tc_dev->s_data;
+	struct device *dev = tc_dev->dev;
+	struct ov5670 *priv = tc_dev->priv;
+	const s32 max_coarse_time = priv->frame_length - OV5670_MAX_COARSE_DIFF;
+	const struct sensor_mode_properties *mode =
+		&s_data->sensor_props.sensor_modes[s_data->mode_prop_idx];
+	ov5670_reg reg_list[3];
+	int err;
+	u32 coarse_time;
+	int i;
+
+	if (!priv->group_hold_prev)
+		ov5670_set_group_hold(tc_dev, 1);
+
+	coarse_time = (u32)(((mode->signal_properties.pixel_clock.val*val)
+			/mode->image_properties.line_length)/
+			mode->control_properties.exposure_factor);
+	if (coarse_time < OV5670_MIN_EXPOSURE_COARSE)
+		coarse_time = OV5670_MIN_EXPOSURE_COARSE;
+	else if (coarse_time > max_coarse_time)
+		coarse_time = max_coarse_time;
+	ov5670_get_coarse_time_regs(reg_list, coarse_time);
+	dev_dbg(dev, "%s: val: %d\n", __func__, coarse_time);
+
+	for (i = 0; i < 3; i++) {
+		err = ov5670_write_reg(s_data, reg_list[i].addr,
+			 reg_list[i].val);
+		if (err)
+			goto fail;
+	}
+
+	return 0;
+
+fail:
+	dev_dbg(dev, "%s: COARSE_TIME control error\n", __func__);
+	return err;
+}
+
+static int ov5670_set_exposure_short(struct tegracam_device *tc_dev, s64 val)
+{
+	struct camera_common_data *s_data = tc_dev->s_data;
+	struct device *dev = tc_dev->dev;
+	struct ov5670 *priv = tc_dev->priv;
+	const struct sensor_mode_properties *mode =
+		&s_data->sensor_props.sensor_modes[s_data->mode_prop_idx];
+	ov5670_reg reg_list[3];
+	int err;
+	struct v4l2_control hdr_control;
+	int hdr_en;
+	u32 coarse_time_short;
+	int i;
+	if (!priv->group_hold_prev)
+		ov5670_set_group_hold(tc_dev, 1);
+
+	/* check hdr enable ctrl */
+	hdr_control.id = TEGRA_CAMERA_CID_HDR_EN;
+
+	err = camera_common_g_ctrl(s_data, &hdr_control);
+	if (err < 0) {
+		dev_err(dev, "could not find device ctrl.\n");
+		return err;
+	}
+
+	hdr_en = switch_ctrl_qmenu[hdr_control.value];
+	if (hdr_en == SWITCH_OFF)
+		return 0;
+
+	coarse_time_short = (u32)(((mode->signal_properties.pixel_clock.val*val)
+				/mode->image_properties.line_length)
+				/mode->control_properties.exposure_factor);
+
+	ov5670_get_coarse_time_short_regs(reg_list, coarse_time_short);
+	dev_dbg(dev, "%s: val: %d\n", __func__, coarse_time_short);
+
+	for (i = 0; i < 3; i++) {
+		err = ov5670_write_reg(s_data, reg_list[i].addr,
+			 reg_list[i].val);
+		if (err)
+			goto fail;
+	}
+
+	return 0;
+
+fail:
+	dev_dbg(dev, "%s: COARSE_TIME_SHORT control error\n", __func__);
+	return err;
+}
+
+static int ov5670_fill_string_ctrl(struct tegracam_device *tc_dev,
+				struct v4l2_ctrl *ctrl)
+{
+	struct ov5670 *priv = tc_dev->priv;
+	int i;
+
+	switch (ctrl->id) {
+	case TEGRA_CAMERA_CID_EEPROM_DATA:
+		for (i = 0; i < OV5670_EEPROM_SIZE; i++)
+			sprintf(&ctrl->p_new.p_char[i*2], "%02x",
+				priv->eeprom_buf[i]);
+		break;
+	case TEGRA_CAMERA_CID_OTP_DATA:
+		for (i = 0; i < OV5670_OTP_SIZE; i++)
+			sprintf(&ctrl->p_new.p_char[i*2], "%02x",
+				priv->otp_buf[i]);
+		break;
+	case TEGRA_CAMERA_CID_FUSE_ID:
+		for (i = 0; i < OV5670_FUSE_ID_SIZE; i++)
+			sprintf(&ctrl->p_new.p_char[i*2], "%02x",
+				priv->fuse_id[i]);
+		break;
+	default:
+		dev_dbg(tc_dev->dev, "%s: Invalid ctrl -> id\n", __func__);
+		return -EINVAL;
+	}
+	ctrl->p_cur.p_char = ctrl->p_new.p_char;
+	return 0;
+}
+
+static int ov5670_eeprom_device_release(struct ov5670 *priv)
+{
+	int i;
+
+	for (i = 0; i < OV5670_EEPROM_NUM_BLOCKS; i++) {
+		if (priv->eeprom[i].i2c_client != NULL) {
+			i2c_unregister_device(priv->eeprom[i].i2c_client);
+			priv->eeprom[i].i2c_client = NULL;
+		}
+	}
+
+	return 0;
+}
+
+static int ov5670_eeprom_device_init(struct ov5670 *priv)
+{
+	struct camera_common_pdata *pdata =  priv->s_data->pdata;
+	char *dev_name = "eeprom_ov5670";
+	static struct regmap_config eeprom_regmap_config = {
+		.reg_bits = 8,
+		.val_bits = 8,
+	};
+	int i;
+	int err;
+
+	if (!pdata->has_eeprom)
+		return -EINVAL;
+
+	for (i = 0; i < OV5670_EEPROM_NUM_BLOCKS; i++) {
+		priv->eeprom[i].adap = i2c_get_adapter(
+				priv->i2c_client->adapter->nr);
+		memset(&priv->eeprom[i].brd, 0, sizeof(priv->eeprom[i].brd));
+		strncpy(priv->eeprom[i].brd.type, dev_name,
+				sizeof(priv->eeprom[i].brd.type));
+		priv->eeprom[i].brd.addr = OV5670_EEPROM_ADDRESS + i;
+		priv->eeprom[i].i2c_client = i2c_new_device(
+				priv->eeprom[i].adap, &priv->eeprom[i].brd);
+
+		priv->eeprom[i].regmap = devm_regmap_init_i2c(
+			priv->eeprom[i].i2c_client, &eeprom_regmap_config);
+		if (IS_ERR(priv->eeprom[i].regmap)) {
+			err = PTR_ERR(priv->eeprom[i].regmap);
+			ov5670_eeprom_device_release(priv);
+			return err;
+		}
+	}
+
+	return 0;
+}
+
+static int ov5670_read_eeprom(struct ov5670 *priv)
+{
+	int err, i;
+
+	for (i = 0; i < OV5670_EEPROM_NUM_BLOCKS; i++) {
+		err = regmap_bulk_read(priv->eeprom[i].regmap, 0,
+			&priv->eeprom_buf[i * OV5670_EEPROM_BLOCK_SIZE],
+			OV5670_EEPROM_BLOCK_SIZE);
+		if (err)
+			return err;
+	}
+	return 0;
+}
+
+static int ov5670_read_otp_bank(struct ov5670 *priv,
+				u8 *buf, int bank, u16 addr, int size)
+{
+	int err;
+
+	/* sleeps calls in the sequence below are for internal device
+	 * signal propagation as specified by sensor vendor */
+
+	usleep_range(10000, 11000);
+	mutex_lock(&priv->streaming_lock);
+	err = ov5670_write_table(priv, mode_table[OV5670_MODE_START_STREAM]);
+	if (err) {
+		mutex_unlock(&priv->streaming_lock);
+		return err;
+	} else {
+		priv->streaming = true;
+		mutex_unlock(&priv->streaming_lock);
+	}
+
+	err = ov5670_write_reg(priv->s_data, OV5670_OTP_BANK_SELECT_ADDR,
+			       0xC0 | bank);
+	if (err)
+		return err;
+
+	err = ov5670_write_reg(priv->s_data, OV5670_OTP_LOAD_CTRL_ADDR, 0x01);
+	if (err)
+		return err;
+
+	usleep_range(10000, 11000);
+	err = regmap_bulk_read(priv->s_data->regmap, addr, buf, size);
+
+	if (err)
+		return err;
+
+	mutex_lock(&priv->streaming_lock);
+	err = ov5670_write_table(priv, mode_table[OV5670_MODE_STOP_STREAM]);
+	if (err) {
+		mutex_unlock(&priv->streaming_lock);
+		return err;
+	} else {
+		priv->streaming = false;
+		mutex_unlock(&priv->streaming_lock);
+	}
+
+	return 0;
+}
+
+static int ov5670_otp_setup(struct ov5670 *priv)
+{
+	struct device *dev = priv->s_data->dev;
+	int err = 0;
+	int i;
+
+	for (i = 0; i < OV5670_OTP_NUM_BANKS; i++) {
+		err = ov5670_read_otp_bank(priv,
+					&priv->otp_buf[i
+					* OV5670_OTP_BANK_SIZE],
+					i,
+					OV5670_OTP_BANK_START_ADDR,
+					OV5670_OTP_BANK_SIZE);
+		if (err) {
+			dev_err(dev, "could not read otp bank\n");
+			goto ret;
+		}
+	}
+
+ret:
+	return err;
+}
+
+static int ov5670_fuse_id_setup(struct ov5670 *priv)
+{
+	struct device *dev = priv->s_data->dev;
+	int err;
+
+	err = ov5670_read_otp_bank(priv,
+				&priv->fuse_id[0],
+				OV5670_FUSE_ID_OTP_BANK,
+				OV5670_FUSE_ID_OTP_START_ADDR,
+				OV5670_FUSE_ID_SIZE);
+	if (err) {
+		dev_err(dev, "could not read otp bank\n");
+		goto ret;
+	}
+
+ret:
+	return err;
+}
+
+MODULE_DEVICE_TABLE(of, ov5670_of_match);
+
+static struct camera_common_pdata *ov5670_parse_dt(struct tegracam_device
+							*tc_dev)
+{
+	struct device *dev = tc_dev->dev;
+	struct device_node *node = dev->of_node;
+	struct camera_common_pdata *board_priv_pdata;
+	const struct of_device_id *match;
+	int gpio;
+	int err;
+	struct camera_common_pdata *ret = NULL;
+
+	if (!node)
+		return NULL;
+
+	match = of_match_device(ov5670_of_match, dev);
+	if (!match) {
+		dev_err(dev, "Failed to find matching dt id\n");
+		return NULL;
+	}
+
+	board_priv_pdata = devm_kzalloc(dev,
+			   sizeof(*board_priv_pdata), GFP_KERNEL);
+	if (!board_priv_pdata)
+		return NULL;
+
+	err = camera_common_parse_clocks(dev,
+					 board_priv_pdata);
+	if (err) {
+		dev_err(dev, "Failed to find clocks\n");
+		goto error;
+	}
+
+	gpio = of_get_named_gpio(node, "pwdn-gpios", 0);
+	if (gpio < 0) {
+		if (gpio == -EPROBE_DEFER) {
+			ret = ERR_PTR(-EPROBE_DEFER);
+			goto error;
+		}
+        dev_dbg(dev, "pwdn gpios not in DT\n");
+		gpio = 0;
+	}
+	board_priv_pdata->pwdn_gpio = (unsigned int)gpio;
+
+	gpio = of_get_named_gpio(node, "reset-gpios", 0);
+	if (gpio < 0) {
+		/* reset-gpio is not absolutely needed */
+		if (gpio == -EPROBE_DEFER) {
+			ret = ERR_PTR(-EPROBE_DEFER);
+			goto error;
+		}
+		dev_dbg(dev, "reset gpios not in DT\n");
+		gpio = 0;
+	}
+	board_priv_pdata->reset_gpio = (unsigned int)gpio;
+
+	board_priv_pdata->use_cam_gpio =
+		of_property_read_bool(node, "cam,use-cam-gpio");
+
+	err = of_property_read_string(node, "avdd-reg",
+			&board_priv_pdata->regulators.avdd);
+	if (err) {
+		dev_err(dev, "avdd-reg not in DT\n");
+		goto error;
+	}
+	err = of_property_read_string(node, "dvdd-reg",
+			&board_priv_pdata->regulators.dvdd);
+	if (err) {
+		dev_err(dev, "dvdd-reg not in DT\n");
+		goto error;
+	}
+
+	board_priv_pdata->has_eeprom =
+		of_property_read_bool(node, "has-eeprom");
+	board_priv_pdata->v_flip = of_property_read_bool(node, "vertical-flip");
+	board_priv_pdata->h_mirror = of_property_read_bool(node,
+							 "horizontal-mirror");
+
+	return board_priv_pdata;
+
+error:
+	devm_kfree(dev, board_priv_pdata);
+	return ret;
+}
+
+static int ov5670_set_mode(struct tegracam_device *tc_dev)
+{
+	struct ov5670 *priv = (struct ov5670 *)tegracam_get_privdata(tc_dev);
+	struct camera_common_data *s_data = tc_dev->s_data;
+	int err;
+
+	err = ov5670_write_table(priv, mode_table[s_data->mode_prop_idx]);
+	if (err)
+		return err;
+
+	return 0;
+}
+
+static int ov5670_start_streaming(struct tegracam_device *tc_dev)
+{
+	struct ov5670 *priv = (struct ov5670 *)tegracam_get_privdata(tc_dev);
+	struct camera_common_data *s_data = tc_dev->s_data;
+	struct camera_common_pdata *pdata = s_data->pdata;
+	struct device *dev = s_data->dev;
+	int err;
+	u8 val;
+
+	mutex_lock(&priv->streaming_lock);
+	err = ov5670_write_table(priv, mode_table[OV5670_MODE_START_STREAM]);
+	if (err) {
+		mutex_unlock(&priv->streaming_lock);
+		goto exit;
+	} else {
+		priv->streaming = true;
+		mutex_unlock(&priv->streaming_lock);
+	}
+	if (pdata->v_flip) {
+		ov5670_read_reg(s_data, OV5670_TIMING_REG20, &val);
+		ov5670_write_reg(s_data, OV5670_TIMING_REG20,
+				 val | VERTICAL_FLIP);
+	}
+	if (pdata->h_mirror) {
+		ov5670_read_reg(s_data, OV5670_TIMING_REG21, &val);
+		ov5670_write_reg(s_data, OV5670_TIMING_REG21,
+				 val | HORIZONTAL_MIRROR_MASK);
+	} else {
+		ov5670_read_reg(s_data, OV5670_TIMING_REG21, &val);
+		ov5670_write_reg(s_data, OV5670_TIMING_REG21,
+				 val & (~HORIZONTAL_MIRROR_MASK));
+	}
+	if (test_mode)
+		err = ov5670_write_table(priv,
+			mode_table[OV5670_MODE_TEST_PATTERN]);
+
+	return 0;
+
+exit:
+	dev_err(dev, "%s: error starting stream\n", __func__);
+	return err;
+}
+
+static int ov5670_stop_streaming(struct tegracam_device *tc_dev)
+{
+	struct camera_common_data *s_data = tc_dev->s_data;
+	struct ov5670 *priv = (struct ov5670 *)tegracam_get_privdata(tc_dev);
+	struct device *dev = s_data->dev;
+	u32 frame_time;
+	int err;
+
+	mutex_lock(&priv->streaming_lock);
+	err = ov5670_write_table(priv,
+		mode_table[OV5670_MODE_STOP_STREAM]);
+	if (err) {
+		mutex_unlock(&priv->streaming_lock);
+		goto exit;
+	} else {
+		priv->streaming = false;
+		mutex_unlock(&priv->streaming_lock);
+	}
+
+	/*
+	 * Wait for one frame to make sure sensor is set to
+	 * software standby in V-blank
+	 *
+	 * frame_time = frame length rows * Tline
+	 * Tline = line length / pixel clock (in MHz)
+	 */
+	frame_time = priv->frame_length *
+		OV5670_DEFAULT_LINE_LENGTH / OV5670_DEFAULT_PIXEL_CLOCK;
+
+	usleep_range(frame_time, frame_time + 1000);
+
+	return 0;
+
+exit:
+	dev_err(dev, "%s: error stopping stream\n", __func__);
+	return err;
+}
+
+static struct camera_common_sensor_ops ov5670_common_ops = {
+	.numfrmfmts = ARRAY_SIZE(ov5670_frmfmt),
+	.frmfmt_table = ov5670_frmfmt,
+	.power_on = ov5670_power_on,
+	.power_off = ov5670_power_off,
+	.write_reg = ov5670_write_reg,
+	.read_reg = ov5670_read_reg,
+	.parse_dt = ov5670_parse_dt,
+	.power_get = ov5670_power_get,
+	.power_put = ov5670_power_put,
+	.set_mode = ov5670_set_mode,
+	.start_streaming = ov5670_start_streaming,
+	.stop_streaming = ov5670_stop_streaming,
+};
+
+static int ov5670_debugfs_streaming_show(void *data, u64 *val)
+{
+	struct ov5670 *priv = data;
+
+	mutex_lock(&priv->streaming_lock);
+	*val = priv->streaming;
+	mutex_unlock(&priv->streaming_lock);
+
+	return 0;
+}
+
+static int ov5670_debugfs_streaming_write(void *data, u64 val)
+{
+	int err = 0;
+	struct ov5670 *priv = data;
+	struct i2c_client *client = priv->i2c_client;
+	bool enable = (val != 0);
+	int mode_index = enable ?
+		(OV5670_MODE_START_STREAM) : (OV5670_MODE_STOP_STREAM);
+
+	dev_info(&client->dev, "%s: %s sensor\n",
+			__func__, (enable ? "enabling" : "disabling"));
+
+	mutex_lock(&priv->streaming_lock);
+
+	err = ov5670_write_table(priv, mode_table[mode_index]);
+	if (err) {
+		dev_err(&client->dev, "%s: error setting sensor streaming\n",
+			__func__);
+		goto done;
+	}
+
+	priv->streaming = enable;
+
+done:
+	mutex_unlock(&priv->streaming_lock);
+
+	return err;
+}
+
+DEFINE_SIMPLE_ATTRIBUTE(ov5670_debugfs_streaming_fops,
+	ov5670_debugfs_streaming_show,
+	ov5670_debugfs_streaming_write,
+	"%lld\n");
+
+static void ov5670_debugfs_remove(struct ov5670 *priv);
+
+static int ov5670_debugfs_create(struct ov5670 *priv)
+{
+	int err = 0;
+	struct i2c_client *client = priv->i2c_client;
+	const char *devnode;
+	char debugfs_dir[16];
+
+	err = of_property_read_string(client->dev.of_node, "devnode", &devnode);
+	if (err) {
+		dev_err(&client->dev, "devnode not in DT\n");
+		return err;
+	}
+	snprintf(debugfs_dir, sizeof(debugfs_dir), "camera-%s", devnode);
+
+	priv->debugfs_dir = debugfs_create_dir(debugfs_dir, NULL);
+	if (priv->debugfs_dir == NULL)
+		return -ENOMEM;
+
+	if (!debugfs_create_file("streaming", 0644, priv->debugfs_dir, priv,
+			&ov5670_debugfs_streaming_fops))
+		goto error;
+
+	return 0;
+
+error:
+	ov5670_debugfs_remove(priv);
+
+	return -ENOMEM;
+}
+
+static struct tegracam_ctrl_ops ov5670_ctrl_ops = {
+	.numctrls = ARRAY_SIZE(ctrl_cid_list),
+	.ctrl_cid_list = ctrl_cid_list,
+	.string_ctrl_size = {OV5670_EEPROM_STR_SIZE,
+				OV5670_FUSE_ID_STR_SIZE,
+				OV5670_OTP_STR_SIZE},
+	.set_gain = ov5670_set_gain,
+	.set_exposure = ov5670_set_exposure,
+	.set_exposure_short = ov5670_set_exposure_short,
+	.set_frame_rate = ov5670_set_frame_rate,
+	.set_group_hold = ov5670_set_group_hold,
+	.fill_string_ctrl = ov5670_fill_string_ctrl,
+};
+
+static int ov5670_board_setup(struct ov5670 *priv)
+{
+	struct camera_common_data *s_data = priv->s_data;
+	struct device *dev = s_data->dev;
+	bool eeprom_ctrl = 0;
+	int err = 0;
+
+	dev_dbg(dev, "%s++\n", __func__);
+
+	/* eeprom interface */
+	err = ov5670_eeprom_device_init(priv);
+	if (err && s_data->pdata->has_eeprom)
+		dev_err(dev,
+			"Failed to allocate eeprom reg map: %d\n", err);
+	eeprom_ctrl = !err;
+
+	err = camera_common_mclk_enable(s_data);
+	if (err) {
+		dev_err(dev,
+			"Error %d turning on mclk\n", err);
+		return err;
+	}
+
+	err = ov5670_power_on(s_data);
+	if (err) {
+		dev_err(dev,
+			"Error %d during power on sensor\n", err);
+		return err;
+	}
+
+	if (eeprom_ctrl) {
+		err = ov5670_read_eeprom(priv);
+		if (err) {
+			dev_err(dev,
+				"Error %d reading eeprom\n", err);
+			goto error;
+		}
+	}
+
+	err = ov5670_otp_setup(priv);
+	if (err) {
+		dev_err(dev,
+			"Error %d reading otp data\n", err);
+		goto error;
+	}
+
+	err = ov5670_fuse_id_setup(priv);
+	if (err) {
+		dev_err(dev,
+			"Error %d reading fuse id data\n", err);
+		goto error;
+	}
+
+error:
+	ov5670_power_off(s_data);
+	camera_common_mclk_disable(s_data);
+	return err;
+}
+
+static void ov5670_debugfs_remove(struct ov5670 *priv)
+{
+	debugfs_remove_recursive(priv->debugfs_dir);
+	priv->debugfs_dir = NULL;
+}
+
+static int ov5670_open(struct v4l2_subdev *sd, struct v4l2_subdev_fh *fh)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+
+	dev_dbg(&client->dev, "%s:\n", __func__);
+	return 0;
+}
+
+static const struct v4l2_subdev_internal_ops ov5670_subdev_internal_ops = {
+	.open = ov5670_open,
+};
+
+static int ov5670_probe(struct i2c_client *client,
+			const struct i2c_device_id *id)
+{
+	struct device *dev = &client->dev;
+	struct device_node *node = client->dev.of_node;
+	struct tegracam_device *tc_dev;
+	struct ov5670 *priv;
+	int err;
+	const struct of_device_id *match;
+
+	dev_info(dev, "probing v4l2 sensor.\n");
+
+	match = of_match_device(ov5670_of_match, dev);
+	if (!match) {
+		dev_err(dev, "No device match found\n");
+		return -ENODEV;
+	}
+
+	if (!IS_ENABLED(CONFIG_OF) || !node)
+		return -EINVAL;
+
+	priv = devm_kzalloc(dev,
+			    sizeof(struct ov5670), GFP_KERNEL);
+	if (!priv)
+		return -ENOMEM;
+
+	tc_dev = devm_kzalloc(dev,
+			    sizeof(struct tegracam_device), GFP_KERNEL);
+	if (!tc_dev)
+		return -ENOMEM;
+
+	priv->i2c_client = tc_dev->client = client;
+	tc_dev->dev = dev;
+	strncpy(tc_dev->name, "ov5670", sizeof(tc_dev->name));
+	tc_dev->dev_regmap_config = &ov5670_regmap_config;
+	tc_dev->sensor_ops = &ov5670_common_ops;
+	tc_dev->v4l2sd_internal_ops = &ov5670_subdev_internal_ops;
+	tc_dev->tcctrl_ops = &ov5670_ctrl_ops;
+
+	err = tegracam_device_register(tc_dev);
+	if (err) {
+		dev_err(dev, "tegra camera driver registration failed\n");
+		return err;
+	}
+
+	priv->tc_dev = tc_dev;
+	priv->s_data = tc_dev->s_data;
+	priv->subdev = &tc_dev->s_data->subdev;
+	tegracam_set_privdata(tc_dev, (void *)priv);
+	mutex_init(&priv->streaming_lock);
+
+	err = ov5670_board_setup(priv);
+		if (err) {
+			dev_err(dev, "board setup failed\n");
+			return err;
+	}
+
+	err = tegracam_v4l2subdev_register(tc_dev, true);
+	if (err) {
+		dev_err(dev, "tegra camera subdev registration failed\n");
+		return err;
+	}
+
+	err = ov5670_debugfs_create(priv);
+	if (err) {
+		dev_err(dev, "error creating debugfs interface");
+		ov5670_debugfs_remove(priv);
+		return err;
+	}
+
+	dev_dbg(dev, "Detected OV5670 sensor\n");
+
+	return 0;
+}
+
+static int
+ov5670_remove(struct i2c_client *client)
+{
+	struct camera_common_data *s_data = to_camera_common_data(&client->dev);
+	struct ov5670 *priv = (struct ov5670 *)s_data->priv;
+
+	ov5670_debugfs_remove(priv);
+
+	tegracam_v4l2subdev_unregister(priv->tc_dev);
+	ov5670_power_put(priv->tc_dev);
+	tegracam_device_unregister(priv->tc_dev);
+	ov5670_eeprom_device_release(priv);
+
+	mutex_destroy(&priv->streaming_lock);
+
+	return 0;
+}
+
+static const struct i2c_device_id ov5670_id[] = {
+	{ "ov5670", 0 },
+	{ }
+};
+
+MODULE_DEVICE_TABLE(i2c, ov5670_id);
+
+static struct i2c_driver ov5670_i2c_driver = {
+	.driver = {
+		.name = "ov5670",
+		.owner = THIS_MODULE,
+		.of_match_table = of_match_ptr(ov5670_of_match),
+	},
+	.probe = ov5670_probe,
+	.remove = ov5670_remove,
+	.id_table = ov5670_id,
+};
+module_i2c_driver(ov5670_i2c_driver);
+
+MODULE_DESCRIPTION("Media Controller driver for OmniVision OV5670");
+MODULE_AUTHOR("NVIDIA Corporation");
+MODULE_LICENSE("GPL v2");
diff --git a/nvidia/drivers/media/i2c/ov5670_mode_tbls.h b/nvidia/drivers/media/i2c/ov5670_mode_tbls.h
new file mode 100755
index 000000000000..ec1fd91533f0
--- /dev/null
+++ b/nvidia/drivers/media/i2c/ov5670_mode_tbls.h
@@ -0,0 +1,2955 @@
+/*
+ * ov5670_mode_tbls.h - ov5670 sensor mode tables
+ *
+ * Copyright (c) 2015-2017, NVIDIA CORPORATION, All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#ifndef __OV5670_TABLES__
+#define __OV5670_TABLES__
+
+#include <media/camera_common.h>
+
+#define OV5670_TABLE_WAIT_MS	0
+#define OV5670_TABLE_END	1
+#define OV5670_MAX_RETRIES	3
+#define OV5670_WAIT_MS		10
+
+#define ov5670_reg struct reg_8
+
+static const ov5670_reg ov5670_start[] = {
+	{0x0100, 0x01}, /* mode select streaming on */
+	{OV5670_TABLE_END, 0x00}
+};
+
+static const ov5670_reg ov5670_stop[] = {
+	{0x0100, 0x00}, /* mode select streaming on */
+	{OV5670_TABLE_END, 0x00}
+};
+
+static const ov5670_reg tp_colorbars[] = {
+	{0x4303, 0x08},
+	{0x4320, 0x80},
+
+	{OV5670_TABLE_WAIT_MS, OV5670_WAIT_MS},
+	{OV5670_TABLE_END, 0x00}
+};
+
+static const ov5670_reg ov5670_pll_840mbps[] = {
+	{OV5670_TABLE_WAIT_MS, OV5670_WAIT_MS},
+	{ 0x030a, 0x00 },
+	{ 0x0300, 0x04 },
+	{ 0x0301, 0x00 },
+	{ 0x0302, 0x78 },
+	{ 0x0304, 0x03 },
+	{ 0x0303, 0x00 },
+	{ 0x0305, 0x01 },
+	{ 0x0306, 0x01 },
+	{ 0x0312, 0x01 },
+	{ 0x030b, 0x00 },
+	{ 0x030c, 0x00 },
+	{ 0x030d, 0x1e },
+	{ 0x030f, 0x06 },
+	{ 0x030e, 0x00 },
+	{OV5670_TABLE_END, 0x00}
+};
+
+static const ov5670_reg mode_2592x1944_regs[] = {
+	{OV5670_TABLE_WAIT_MS, OV5670_WAIT_MS},
+	{0x0100, 0x00},/* Including sw reset */
+	{0x3000, 0x00},
+	{0x3002, 0x21},
+	{0x3005, 0xf0},
+	{0x3007, 0x00},
+	{0x3015, 0x0f},
+	{0x3018, 0x32},
+	{0x301a, 0xf0},
+	{0x301b, 0xf0},
+	{0x301c, 0xf0},
+	{0x301d, 0xf0},
+	{0x301e, 0xf0},
+	{0x3030, 0x00},
+	{0x3031, 0x0a},
+	{0x303c, 0xff},
+	{0x303e, 0xff},
+	{0x3040, 0xf0},
+	{0x3041, 0x00},
+	{0x3042, 0xf0},
+	{0x3106, 0x11},
+	{0x3500, 0x00},
+	{0x3501, 0x80},
+	{0x3502, 0x00},
+	{0x3503, 0x04},
+	{0x3504, 0x03},
+	{0x3505, 0x83},
+	{0x3508, 0x04},
+	{0x3509, 0x00},
+	{0x350e, 0x04},
+	{0x350f, 0x00},
+	{0x3510, 0x00},
+	{0x3511, 0x02},
+	{0x3512, 0x00},
+	{0x3601, 0xc8},
+	{0x3610, 0x88},
+	{0x3612, 0x48},
+	{0x3614, 0x5b},
+	{0x3615, 0x96},
+	{0x3621, 0xd0},
+	{0x3622, 0x00},
+	{0x3623, 0x00},
+	{0x3633, 0x13},
+	{0x3634, 0x13},
+	{0x3635, 0x13},
+	{0x3636, 0x13},
+	{0x3645, 0x13},
+	{0x3646, 0x82},
+	{0x3650, 0x00},
+	{0x3652, 0xff},
+	{0x3655, 0x20},
+	{0x3656, 0xff},
+	{0x365a, 0xff},
+	{0x365e, 0xff},
+	{0x3668, 0x00},
+	{0x366a, 0x07},
+	{0x366e, 0x10},
+	{0x366d, 0x00},
+	{0x366f, 0x80},
+	{0x3700, 0x28},
+	{0x3701, 0x10},
+	{0x3702, 0x3a},
+	{0x3703, 0x19},
+	{0x3704, 0x10},
+	{0x3705, 0x00},
+	{0x3706, 0x66},
+	{0x3707, 0x08},
+	{0x3708, 0x34},
+	{0x3709, 0x40},
+	{0x370a, 0x01},
+	{0x370b, 0x1b},
+	{0x3714, 0x24},
+	{0x371a, 0x3e},
+	{0x3733, 0x00},
+	{0x3734, 0x00},
+	{0x373a, 0x05},
+	{0x373b, 0x06},
+	{0x373c, 0x0a},
+	{0x373f, 0xa0},
+	{0x3755, 0x00},
+	{0x3758, 0x00},
+	{0x375b, 0x0e},
+	{0x3766, 0x5f},
+	{0x3768, 0x00},
+	{0x3769, 0x22},
+	{0x3773, 0x08},
+	{0x3774, 0x1f},
+	{0x3776, 0x06},
+	{0x37a0, 0x88},
+	{0x37a1, 0x5c},
+	{0x37a7, 0x88},
+	{0x37a8, 0x70},
+	{0x37aa, 0x88},
+	{0x37ab, 0x48},
+	{0x37b3, 0x66},
+	{0x37c2, 0x04},
+	{0x37c5, 0x00},
+	{0x37c8, 0x00},
+	{0x3800, 0x00},
+	{0x3801, 0x0c},
+	{0x3802, 0x00},
+	{0x3803, 0x04},
+	{0x3804, 0x0a},
+	{0x3805, 0x33},
+	{0x3806, 0x07},
+	{0x3807, 0xa3},
+	{0x3808, 0x0a},
+	{0x3809, 0x20},
+	{0x380a, 0x07},
+	{0x380b, 0x98},
+	{0x380c, 0x06},
+	{0x380d, 0x90},
+	{0x380e, 0x08},
+	{0x380f, 0x08},
+	{0x3811, 0x04},
+	{0x3813, 0x02},
+	{0x3814, 0x01},
+	{0x3815, 0x01},
+	{0x3816, 0x00},
+	{0x3817, 0x00},
+	{0x3818, 0x00},
+	{0x3819, 0x00},
+	{0x3820, 0x02},
+	{0x3821, 0x46},
+	{0x3822, 0x48},
+	{0x3826, 0x00},
+	{0x3827, 0x08},
+	{0x382a, 0x01},
+	{0x382b, 0x01},
+	{0x3830, 0x08},
+	{0x3836, 0x02},
+	{0x3837, 0x00},
+	{0x3838, 0x10},
+	{0x3841, 0xff},
+	{0x3846, 0x48},
+	{0x3861, 0x00},
+	{0x3862, 0x04},
+	{0x3863, 0x06},
+	{0x3a11, 0x01},
+	{0x3a12, 0x78},
+	{0x3b00, 0x00},
+	{0x3b02, 0x00},
+	{0x3b03, 0x00},
+	{0x3b04, 0x00},
+	{0x3b05, 0x00},
+	{0x3c00, 0x89},
+	{0x3c01, 0xab},
+	{0x3c02, 0x01},
+	{0x3c03, 0x00},
+	{0x3c04, 0x00},
+	{0x3c05, 0x03},
+	{0x3c06, 0x00},
+	{0x3c07, 0x05},
+	{0x3c0c, 0x00},
+	{0x3c0d, 0x00},
+	{0x3c0e, 0x00},
+	{0x3c0f, 0x00},
+	{0x3c40, 0x00},
+	{0x3c41, 0xa3},
+	{0x3c43, 0x7d},
+	{0x3c45, 0xd7},
+	{0x3c47, 0xfc},
+	{0x3c50, 0x05},
+	{0x3c52, 0xaa},
+	{0x3c54, 0x71},
+	{0x3c56, 0x80},
+	{0x3d85, 0x17},
+	{0x3f03, 0x00},
+	{0x3f0a, 0x00},
+	{0x3f0b, 0x00},
+	{0x4001, 0x60},
+	{0x4009, 0x0d},
+	{0x4020, 0x00},
+	{0x4021, 0x00},
+	{0x4022, 0x00},
+	{0x4023, 0x00},
+	{0x4024, 0x00},
+	{0x4025, 0x00},
+	{0x4026, 0x00},
+	{0x4027, 0x00},
+	{0x4028, 0x00},
+	{0x4029, 0x00},
+	{0x402a, 0x00},
+	{0x402b, 0x00},
+	{0x402c, 0x00},
+	{0x402d, 0x00},
+	{0x402e, 0x00},
+	{0x402f, 0x00},
+	{0x4040, 0x00},
+	{0x4041, 0x03},
+	{0x4042, 0x00},
+	{0x4043, 0x7A},
+	{0x4044, 0x00},
+	{0x4045, 0x7A},
+	{0x4046, 0x00},
+	{0x4047, 0x7A},
+	{0x4048, 0x00},
+	{0x4049, 0x7A},
+	{0x4307, 0x30},
+	{0x4500, 0x58},
+	{0x4501, 0x04},
+	{0x4502, 0x40},
+	{0x4503, 0x10},
+	{0x4508, 0xaa},
+	{0x4509, 0xaa},
+	{0x450a, 0x00},
+	{0x450b, 0x00},
+	{0x4600, 0x01},
+	{0x4601, 0x03},
+	{0x4700, 0xa4},
+	{0x4800, 0x4c},
+	{0x4816, 0x53},
+	{0x481f, 0x40},
+	{0x4837, 0x13},
+	{0x5000, 0x56},
+	{0x5001, 0x01},
+	{0x5002, 0x28},
+	{0x5004, 0x0c},
+	{0x5006, 0x0c},
+	{0x5007, 0xe0},
+	{0x5008, 0x01},
+	{0x5009, 0xb0},
+	{0x5901, 0x00},
+	{0x5a01, 0x00},
+	{0x5a03, 0x00},
+	{0x5a04, 0x0c},
+	{0x5a05, 0xe0},
+	{0x5a06, 0x09},
+	{0x5a07, 0xb0},
+	{0x5a08, 0x06},
+	{0x5e00, 0x00},
+	{0x3734, 0x40},
+	{0x5b00, 0x01},
+	{0x5b01, 0x10},
+	{0x5b02, 0x01},
+	{0x5b03, 0xdb},
+	{0x3d8c, 0x71},
+	{0x3d8d, 0xea},
+	{0x4017, 0x08},
+	{0x3618, 0x2a},
+	{0x5780, 0x3e},
+	{0x5781, 0x0f},
+	{0x5782, 0x44},
+	{0x5783, 0x02},
+	{0x5784, 0x01},
+	{0x5785, 0x01},
+	{0x5786, 0x00},
+	{0x5787, 0x04},
+	{0x5788, 0x02},
+	{0x5789, 0x0f},
+	{0x578a, 0xfd},
+	{0x578b, 0xf5},
+	{0x578c, 0xf5},
+	{0x578d, 0x03},
+	{0x578e, 0x08},
+	{0x578f, 0x0c},
+	{0x5790, 0x08},
+	{0x5791, 0x06},
+	{0x5792, 0x00},
+	{0x5793, 0x52},
+	{0x5794, 0xa3},
+	{0x3503, 0x00},
+	{0x5045, 0x05},
+	{0x4003, 0x40},
+	{0x5048, 0x40},
+	{OV5670_TABLE_END, 0x0000}
+};
+static const ov5670_reg mode_2592x1944[] = {
+	{OV5670_TABLE_WAIT_MS, OV5670_WAIT_MS},
+	{0x0100, 0x00},/* Including sw reset */
+	{0x3001, 0x0a},
+	{0x3002, 0x80},
+	{0x3006, 0x00},
+	{0x3011, 0x21},
+	{0x3012, 0x09},
+	{0x3013, 0x10},
+	{0x3014, 0x00},
+	{0x3015, 0x08},
+	{0x3016, 0xf0},
+	{0x3017, 0xf0},
+	{0x3018, 0xf0},
+	{0x301b, 0xb4},
+	{0x301d, 0x02},
+	{0x3021, 0x00},
+	{0x3022, 0x01},
+	{0x3028, 0x44},
+	{0x3090, 0x02},
+	{0x3091, 0x0e},
+	{0x3092, 0x00},
+	{0x3093, 0x00},
+	{0x3098, 0x03},
+	{0x3099, 0x1e},
+	{0x309a, 0x02},
+	{0x309b, 0x01},
+	{0x309c, 0x00},
+	{0x30a0, 0xd2},
+	{0x30a2, 0x01},
+	{0x30b2, 0x00},
+	{0x30b3, 0x68},
+	{0x30b4, 0x03},
+	{0x30b5, 0x04},
+	{0x30b6, 0x01},
+	{0x3104, 0x21},
+	{0x3106, 0x00},
+	{0x3406, 0x01},
+	{0x3500, 0x00},
+	{0x3501, 0x7b},
+	{0x3502, 0x00},
+	{0x3503, 0x07},
+	{0x3504, 0x00},
+	{0x3505, 0x00},
+	{0x3506, 0x00},
+	{0x3507, 0x02},
+	{0x3508, 0x00},
+	{0x3509, 0x10},
+	{0x350a, 0x00},
+	{0x350b, 0x40},
+	{0x3601, 0x0a},
+	{0x3602, 0x18},
+	{0x3612, 0x80},
+	{0x3620, 0x54},
+	{0x3621, 0xc7},
+	{0x3622, 0x0f},
+	{0x3625, 0x10},
+	{0x3630, 0x55},
+	{0x3631, 0xf4},
+	{0x3632, 0x00},
+	{0x3633, 0x34},
+	{0x3634, 0x02},
+	{0x364d, 0x0d},
+	{0x364f, 0xdd},
+	{0x3660, 0x04},
+	{0x3662, 0x10},
+	{0x3663, 0xf1},
+	{0x3665, 0x00},
+	{0x3666, 0x20},
+	{0x3667, 0x00},
+	{0x366a, 0x80},
+	{0x3680, 0xe0},
+	{0x3681, 0x00},
+	{0x3700, 0x42},
+	{0x3701, 0x14},
+	{0x3702, 0xa0},
+	{0x3703, 0xd8},
+	{0x3704, 0x78},
+	{0x3705, 0x02},
+	{0x3708, 0xe2},
+	{0x3709, 0xc3},
+	{0x370a, 0x00},
+	{0x370b, 0x20},
+	{0x370c, 0x0c},
+	{0x370d, 0x11},
+	{0x370e, 0x00},
+	{0x370f, 0x40},
+	{0x3710, 0x00},
+	{0x371a, 0x1c},
+	{0x371b, 0x05},
+	{0x371c, 0x01},
+	{0x371e, 0xa1},
+	{0x371f, 0x0c},
+	{0x3721, 0x00},
+	{0x3724, 0x10},
+	{0x3726, 0x00},
+	{0x372a, 0x01},
+	{0x3730, 0x10},
+	{0x3738, 0x22},
+	{0x3739, 0xe5},
+	{0x373a, 0x50},
+	{0x373b, 0x02},
+	{0x373c, 0x41},
+	{0x373f, 0x02},
+	{0x3740, 0x42},
+	{0x3741, 0x02},
+	{0x3742, 0x18},
+	{0x3743, 0x01},
+	{0x3744, 0x02},
+	{0x3747, 0x10},
+	{0x374c, 0x04},
+	{0x3751, 0xf0},
+	{0x3752, 0x00},
+	{0x3753, 0x00},
+	{0x3754, 0xc0},
+	{0x3755, 0x00},
+	{0x3756, 0x1a},
+	{0x3758, 0x00},
+	{0x3759, 0x0f},
+	{0x376b, 0x44},
+	{0x375c, 0x04},
+	{0x3776, 0x00},
+	{0x377f, 0x08},
+	{0x3780, 0x22},
+	{0x3781, 0x0c},
+	{0x3784, 0x2c},
+	{0x3785, 0x1e},
+	{0x378f, 0xf5},
+	{0x3791, 0xb0},
+	{0x3795, 0x00},
+	{0x3796, 0x64},
+	{0x3797, 0x11},
+	{0x3798, 0x30},
+	{0x3799, 0x41},
+	{0x379a, 0x07},
+	{0x379b, 0xb0},
+	{0x379c, 0x0c},
+	{0x37c5, 0x00},
+	{0x37c6, 0x00},
+	{0x37c7, 0x00},
+	{0x37c9, 0x00},
+	{0x37ca, 0x00},
+	{0x37cb, 0x00},
+	{0x37de, 0x00},
+	{0x37df, 0x00},
+	{0x3800, 0x00},
+	{0x3801, 0x02},
+	{0x3802, 0x00},
+	{0x3803, 0x02},
+	{0x3804, 0x0a},
+	{0x3805, 0x41},
+	{0x3806, 0x07},
+	{0x3807, 0xa5},
+	{0x3808, 0x0a},
+	{0x3809, 0x20},
+	{0x380a, 0x07},
+	{0x380b, 0x98},
+	{0x380c, 0x0a},
+	{0x380d, 0x80},
+	{0x380e, 0x07},
+	{0x380f, 0xc0},
+	{0x3810, 0x00},
+	{0x3811, 0x02},
+	{0x3812, 0x00},
+	{0x3813, 0x02},
+	{0x3814, 0x11},
+	{0x3815, 0x11},
+	{0x3820, 0x02},
+	{0x3821, 0x1e},
+	{0x3823, 0x00},
+	{0x3824, 0x00},
+	{0x3825, 0x00},
+	{0x3826, 0x00},
+	{0x3827, 0x00},
+	{0x382a, 0x04},
+	{0x3a04, 0x06},
+	{0x3a05, 0x14},
+	{0x3a06, 0x00},
+	{0x3a07, 0xfe},
+	{0x3b00, 0x00},
+	{0x3b02, 0x00},
+	{0x3b03, 0x00},
+	{0x3b04, 0x00},
+	{0x3b05, 0x00},
+	{0x3d00, 0x00},
+	{0x3d01, 0x00},
+	{0x3d02, 0x00},
+	{0x3d03, 0x00},
+	{0x3d04, 0x00},
+	{0x3d05, 0x00},
+	{0x3d06, 0x00},
+	{0x3d07, 0x00},
+	{0x3d08, 0x00},
+	{0x3d09, 0x00},
+	{0x3d0a, 0x00},
+	{0x3d0b, 0x00},
+	{0x3d0c, 0x00},
+	{0x3d0d, 0x00},
+	{0x3d0e, 0x00},
+	{0x3d0f, 0x00},
+	{0x3d80, 0x00},
+	{0x3d81, 0x00},
+	{0x3d84, 0x00},
+	{0x3e07, 0x20},
+	{0x4000, 0x08},
+	{0x4001, 0x04},
+	{0x4002, 0x45},
+	{0x4004, 0x08},
+	{0x4005, 0x18},
+	{0x4006, 0x20},
+	{0x4008, 0x24},
+	{0x4009, 0x10},
+	{0x400c, 0x00},
+	{0x400d, 0x00},
+	{0x4058, 0x00},
+	{0x4101, 0xb2},
+	{0x4303, 0x00},
+	{0x4304, 0x08},
+	{0x4307, 0x30},
+	{0x4311, 0x04},
+	{0x4315, 0x01},
+	{0x4511, 0x05},
+	{0x4512, 0x01},
+	{0x4800, 0x20}, /* dis-continuous */
+	{0x4806, 0x00},
+	{0x4816, 0x52},
+	{0x481f, 0x30},
+	{0x4826, 0x32},
+	{0x4831, 0x6a},
+	{0x4d00, 0x04},
+	{0x4d01, 0x71},
+	{0x4d02, 0xfd},
+	{0x4d03, 0xf5},
+	{0x4d04, 0x0c},
+	{0x4d05, 0xcc},
+	{0x4837, 0x0a},
+	{0x5000, 0x06},
+	{0x5001, 0x01},
+	{0x5002, 0x00},
+	{0x5003, 0x20},
+	{0x5046, 0x0a},
+	{0x5013, 0x00},
+	{0x5046, 0x0a},
+	{0x5780, 0x1c},
+	{0x5786, 0x20},
+	{0x5787, 0x10},
+	{0x5788, 0x18},
+	{0x578a, 0x04},
+	{0x578b, 0x02},
+	{0x578c, 0x02},
+	{0x578e, 0x06},
+	{0x578f, 0x02},
+	{0x5790, 0x02},
+	{0x5791, 0xff},
+	{0x5842, 0x01},
+	{0x5843, 0x2b},
+	{0x5844, 0x01},
+	{0x5845, 0x92},
+	{0x5846, 0x01},
+	{0x5847, 0x8f},
+	{0x5848, 0x01},
+	{0x5849, 0x0c},
+	{0x5e00, 0x00},
+	{0x5e10, 0x0c},
+	{OV5670_TABLE_END, 0x0000}
+};
+
+static const ov5670_reg mode_2560x1440_regs[] = {
+	{OV5670_TABLE_WAIT_MS, OV5670_WAIT_MS},
+	{0x0100, 0x00},/* Including sw reset */
+	{0x3000, 0x00},
+	{0x3002, 0x21},
+	{0x3005, 0xf0},
+	{0x3007, 0x00},
+	{0x3015, 0x0f},
+	{0x3018, 0x32},
+	{0x301a, 0xf0},
+	{0x301b, 0xf0},
+	{0x301c, 0xf0},
+	{0x301d, 0xf0},
+	{0x301e, 0xf0},
+	{0x3030, 0x00},
+	{0x3031, 0x0a},
+	{0x303c, 0xff},
+	{0x303e, 0xff},
+	{0x3040, 0xf0},
+	{0x3041, 0x00},
+	{0x3042, 0xf0},
+	{0x3106, 0x11},
+	{0x3500, 0x00},
+	{0x3501, 0x80},
+	{0x3502, 0x00},
+	{0x3503, 0x04},
+	{0x3504, 0x03},
+	{0x3505, 0x83},
+	{0x3508, 0x04},
+	{0x3509, 0x00},
+	{0x350e, 0x04},
+	{0x350f, 0x00},
+	{0x3510, 0x00},
+	{0x3511, 0x02},
+	{0x3512, 0x00},
+	{0x3601, 0xc8},
+	{0x3610, 0x88},
+	{0x3612, 0x48},
+	{0x3614, 0x5b},
+	{0x3615, 0x96},
+	{0x3621, 0xd0},
+	{0x3622, 0x00},
+	{0x3623, 0x00},
+	{0x3633, 0x13},
+	{0x3634, 0x13},
+	{0x3635, 0x13},
+	{0x3636, 0x13},
+	{0x3645, 0x13},
+	{0x3646, 0x82},
+	{0x3650, 0x00},
+	{0x3652, 0xff},
+	{0x3655, 0x20},
+	{0x3656, 0xff},
+	{0x365a, 0xff},
+	{0x365e, 0xff},
+	{0x3668, 0x00},
+	{0x366a, 0x07},
+	{0x366e, 0x10},
+	{0x366d, 0x00},
+	{0x366f, 0x80},
+	{0x3700, 0x28},
+	{0x3701, 0x10},
+	{0x3702, 0x3a},
+	{0x3703, 0x19},
+	{0x3704, 0x10},
+	{0x3705, 0x00},
+	{0x3706, 0x66},
+	{0x3707, 0x08},
+	{0x3708, 0x34},
+	{0x3709, 0x40},
+	{0x370a, 0x01},
+	{0x370b, 0x1b},
+	{0x3714, 0x24},
+	{0x371a, 0x3e},
+	{0x3733, 0x00},
+	{0x3734, 0x00},
+	{0x373a, 0x05},
+	{0x373b, 0x06},
+	{0x373c, 0x0a},
+	{0x373f, 0xa0},
+	{0x3755, 0x00},
+	{0x3758, 0x00},
+	{0x375b, 0x0e},
+	{0x3766, 0x5f},
+	{0x3768, 0x00},
+	{0x3769, 0x22},
+	{0x3773, 0x08},
+	{0x3774, 0x1f},
+	{0x3776, 0x06},
+	{0x37a0, 0x88},
+	{0x37a1, 0x5c},
+	{0x37a7, 0x88},
+	{0x37a8, 0x70},
+	{0x37aa, 0x88},
+	{0x37ab, 0x48},
+	{0x37b3, 0x66},
+	{0x37c2, 0x04},
+	{0x37c5, 0x00},
+	{0x37c8, 0x00},
+	{0x3800, 0x00},
+	{0x3801, 0x0c},
+	{0x3802, 0x00},
+	{0x3803, 0x04},
+	{0x3804, 0x0a},
+	{0x3805, 0x33},
+	{0x3806, 0x07},
+	{0x3807, 0xa3},
+	{0x3808, 0x0a},
+	{0x3809, 0x00},
+	{0x380a, 0x05},
+	{0x380b, 0xa0},
+	{0x380c, 0x06},
+	{0x380d, 0x90},
+	{0x380e, 0x08},
+	{0x380f, 0x08},
+	{0x3811, 0x04},
+	{0x3813, 0x02},
+	{0x3814, 0x01},
+	{0x3815, 0x01},
+	{0x3816, 0x00},
+	{0x3817, 0x00},
+	{0x3818, 0x00},
+	{0x3819, 0x00},
+	{0x3820, 0x84},
+	{0x3821, 0x46},
+	{0x3822, 0x48},
+	{0x3826, 0x00},
+	{0x3827, 0x08},
+	{0x382a, 0x01},
+	{0x382b, 0x01},
+	{0x3830, 0x08},
+	{0x3836, 0x02},
+	{0x3837, 0x00},
+	{0x3838, 0x10},
+	{0x3841, 0xff},
+	{0x3846, 0x48},
+	{0x3861, 0x00},
+	{0x3862, 0x04},
+	{0x3863, 0x06},
+	{0x3a11, 0x01},
+	{0x3a12, 0x78},
+	{0x3b00, 0x00},
+	{0x3b02, 0x00},
+	{0x3b03, 0x00},
+	{0x3b04, 0x00},
+	{0x3b05, 0x00},
+	{0x3c00, 0x89},
+	{0x3c01, 0xab},
+	{0x3c02, 0x01},
+	{0x3c03, 0x00},
+	{0x3c04, 0x00},
+	{0x3c05, 0x03},
+	{0x3c06, 0x00},
+	{0x3c07, 0x05},
+	{0x3c0c, 0x00},
+	{0x3c0d, 0x00},
+	{0x3c0e, 0x00},
+	{0x3c0f, 0x00},
+	{0x3c40, 0x00},
+	{0x3c41, 0xa3},
+	{0x3c43, 0x7d},
+	{0x3c45, 0xd7},
+	{0x3c47, 0xfc},
+	{0x3c50, 0x05},
+	{0x3c52, 0xaa},
+	{0x3c54, 0x71},
+	{0x3c56, 0x80},
+	{0x3d85, 0x17},
+	{0x3f03, 0x00},
+	{0x3f0a, 0x00},
+	{0x3f0b, 0x00},
+	{0x4001, 0x60},
+	{0x4009, 0x0d},
+	{0x4020, 0x00},
+	{0x4021, 0x00},
+	{0x4022, 0x00},
+	{0x4023, 0x00},
+	{0x4024, 0x00},
+	{0x4025, 0x00},
+	{0x4026, 0x00},
+	{0x4027, 0x00},
+	{0x4028, 0x00},
+	{0x4029, 0x00},
+	{0x402a, 0x00},
+	{0x402b, 0x00},
+	{0x402c, 0x00},
+	{0x402d, 0x00},
+	{0x402e, 0x00},
+	{0x402f, 0x00},
+	{0x4040, 0x00},
+	{0x4041, 0x03},
+	{0x4042, 0x00},
+	{0x4043, 0x7A},
+	{0x4044, 0x00},
+	{0x4045, 0x7A},
+	{0x4046, 0x00},
+	{0x4047, 0x7A},
+	{0x4048, 0x00},
+	{0x4049, 0x7A},
+	{0x4307, 0x30},
+	{0x4500, 0x58},
+	{0x4501, 0x04},
+	{0x4502, 0x40},
+	{0x4503, 0x10},
+	{0x4508, 0xaa},
+	{0x4509, 0xaa},
+	{0x450a, 0x00},
+	{0x450b, 0x00},
+	{0x4600, 0x01},
+	{0x4601, 0x00},
+	{0x4700, 0xa4},
+	{0x4800, 0x4c},
+	{0x4816, 0x53},
+	{0x481f, 0x40},
+	{0x4837, 0x13},
+	{0x5000, 0x56},
+	{0x5001, 0x01},
+	{0x5002, 0x28},
+	{0x5004, 0x0c},
+	{0x5006, 0x0c},
+	{0x5007, 0xe0},
+	{0x5008, 0x01},
+	{0x5009, 0xb0},
+	{0x5901, 0x00},
+	{0x5a01, 0x00},
+	{0x5a03, 0x00},
+	{0x5a04, 0x0c},
+	{0x5a05, 0xe0},
+	{0x5a06, 0x09},
+	{0x5a07, 0xb0},
+	{0x5a08, 0x06},
+	{0x5e00, 0x00},
+	{0x3734, 0x40},
+	{0x5b00, 0x01},
+	{0x5b01, 0x10},
+	{0x5b02, 0x01},
+	{0x5b03, 0xdb},
+	{0x3d8c, 0x71},
+	{0x3d8d, 0xea},
+	{0x4017, 0x08},
+	{0x3618, 0x2a},
+	{0x5780, 0x3e},
+	{0x5781, 0x0f},
+	{0x5782, 0x44},
+	{0x5783, 0x02},
+	{0x5784, 0x01},
+	{0x5785, 0x01},
+	{0x5786, 0x00},
+	{0x5787, 0x04},
+	{0x5788, 0x02},
+	{0x5789, 0x0f},
+	{0x578a, 0xfd},
+	{0x578b, 0xf5},
+	{0x578c, 0xf5},
+	{0x578d, 0x03},
+	{0x578e, 0x08},
+	{0x578f, 0x0c},
+	{0x5790, 0x08},
+	{0x5791, 0x06},
+	{0x5792, 0x00},
+	{0x5793, 0x52},
+	{0x5794, 0xa3},
+	{0x5045, 0x05},
+	{0x4003, 0x40},
+	{0x5048, 0x40},
+	{OV5670_TABLE_END, 0x0000}
+};
+
+static const ov5670_reg mode_2592x1458[] = {
+	{OV5670_TABLE_WAIT_MS, OV5670_WAIT_MS},
+	{0x0100, 0x00},/* Including sw reset */
+	{0x3001, 0x0a},
+	{0x3002, 0x80},
+	{0x3006, 0x00},
+	{0x3011, 0x21},
+	{0x3012, 0x09},
+	{0x3013, 0x10},
+	{0x3014, 0x00},
+	{0x3015, 0x08},
+	{0x3016, 0xf0},
+	{0x3017, 0xf0},
+	{0x3018, 0xf0},
+	{0x301b, 0xb4},
+	{0x301d, 0x02},
+	{0x3021, 0x00},
+	{0x3022, 0x01},
+	{0x3028, 0x44},
+	{0x3098, 0x03},
+	{0x3099, 0x1e},
+	{0x309a, 0x02},
+	{0x309b, 0x01},
+	{0x309c, 0x00},
+	{0x30a0, 0xd2},
+	{0x30a2, 0x01},
+	{0x30b2, 0x00},
+	{0x30b3, 0x68},
+	{0x30b4, 0x03},
+	{0x30b5, 0x04},
+	{0x30b6, 0x01},
+	{0x3104, 0x21},
+	{0x3106, 0x00},
+	{0x3400, 0x04},
+	{0x3401, 0x00},
+	{0x3402, 0x04},
+	{0x3403, 0x00},
+	{0x3404, 0x04},
+	{0x3405, 0x00},
+	{0x3406, 0x01},
+	{0x3500, 0x00},
+	{0x3501, 0x7b},
+	{0x3502, 0x00},
+	{0x3503, 0x07},
+	{0x3504, 0x00},
+	{0x3505, 0x00},
+	{0x3506, 0x00},
+	{0x3507, 0x02},
+	{0x3508, 0x00},
+	{0x3509, 0x10},
+	{0x350a, 0x00},
+	{0x350b, 0x40},
+	{0x3600, 0xbc},
+	{0x3601, 0x0a},
+	{0x3602, 0x38},
+	{0x3612, 0x80},
+	{0x3620, 0x44},
+	{0x3621, 0xb5},
+	{0x3622, 0x0c},
+	{0x3625, 0x10},
+	{0x3630, 0x55},
+	{0x3631, 0xf4},
+	{0x3632, 0x00},
+	{0x3633, 0x34},
+	{0x3634, 0x02},
+	{0x364d, 0x0d},
+	{0x364f, 0xdd},
+	{0x3660, 0x04},
+	{0x3662, 0x10},
+	{0x3663, 0xf1},
+	{0x3665, 0x00},
+	{0x3666, 0x20},
+	{0x3667, 0x00},
+	{0x366a, 0x80},
+	{0x3680, 0xe0},
+	{0x3681, 0x00},
+	{0x3700, 0x42},
+	{0x3701, 0x14},
+	{0x3702, 0xa0},
+	{0x3703, 0xd8},
+	{0x3704, 0x78},
+	{0x3705, 0x02},
+	{0x3708, 0xe2},
+	{0x3709, 0xc3},
+	{0x370a, 0x00},
+	{0x370b, 0x20},
+	{0x370c, 0x0c},
+	{0x370d, 0x11},
+	{0x370e, 0x00},
+	{0x370f, 0x40},
+	{0x3710, 0x00},
+	{0x371a, 0x1c},
+	{0x371b, 0x05},
+	{0x371c, 0x01},
+	{0x371e, 0xa1},
+	{0x371f, 0x0c},
+	{0x3721, 0x00},
+	{0x3724, 0x10},
+	{0x3726, 0x00},
+	{0x372a, 0x01},
+	{0x3730, 0x10},
+	{0x3738, 0x22},
+	{0x3739, 0xe5},
+	{0x373a, 0x50},
+	{0x373b, 0x02},
+	{0x373c, 0x41},
+	{0x373f, 0x02},
+	{0x3740, 0x42},
+	{0x3741, 0x02},
+	{0x3742, 0x18},
+	{0x3743, 0x01},
+	{0x3744, 0x02},
+	{0x3747, 0x10},
+	{0x374c, 0x04},
+	{0x3751, 0xf0},
+	{0x3752, 0x00},
+	{0x3753, 0x00},
+	{0x3754, 0xc0},
+	{0x3755, 0x00},
+	{0x3756, 0x1a},
+	{0x3758, 0x00},
+	{0x3759, 0x0f},
+	{0x376b, 0x44},
+	{0x375c, 0x04},
+	{0x3774, 0x10},
+	{0x3776, 0x00},
+	{0x377f, 0x08},
+	{0x3780, 0x22},
+	{0x3781, 0x0c},
+	{0x3784, 0x2c},
+	{0x3785, 0x1e},
+	{0x378f, 0xf5},
+	{0x3791, 0xb0},
+	{0x3795, 0x00},
+	{0x3796, 0x64},
+	{0x3797, 0x11},
+	{0x3798, 0x30},
+	{0x3799, 0x41},
+	{0x379a, 0x07},
+	{0x379b, 0xb0},
+	{0x379c, 0x0c},
+	{0x37c5, 0x00},
+	{0x37c6, 0x00},
+	{0x37c7, 0x00},
+	{0x37c9, 0x00},
+	{0x37ca, 0x00},
+	{0x37cb, 0x00},
+	{0x37de, 0x00},
+	{0x37df, 0x00},
+	{0x3800, 0x00},
+	{0x3801, 0x00},
+	{0x3802, 0x00},
+	{0x3803, 0xf4},
+	{0x3804, 0x0a},
+	{0x3805, 0x3f},
+	{0x3806, 0x06},
+	{0x3807, 0xb1},
+	{0x3808, 0x0a},
+	{0x3809, 0x20},
+	{0x380a, 0x05},
+	{0x380b, 0xb2},
+	{0x380c, 0x0a},
+	{0x380d, 0x80},
+	{0x380e, 0x07},
+	{0x380f, 0xc0},
+	{0x3810, 0x00},
+	{0x3811, 0x10},
+	{0x3812, 0x00},
+	{0x3813, 0x06},
+	{0x3814, 0x11},
+	{0x3815, 0x11},
+	{0x3820, 0x02},
+	{0x3821, 0x1e},
+	{0x3823, 0x00},
+	{0x3824, 0x00},
+	{0x3825, 0x00},
+	{0x3826, 0x00},
+	{0x3827, 0x00},
+	{0x382a, 0x04},
+	{0x3a04, 0x06},
+	{0x3a05, 0x14},
+	{0x3a06, 0x00},
+	{0x3a07, 0xfe},
+	{0x3b00, 0x00},
+	{0x3b02, 0x00},
+	{0x3b03, 0x00},
+	{0x3b04, 0x00},
+	{0x3b05, 0x00},
+	{0x3e07, 0x20},
+	{0x4000, 0x08},
+	{0x4001, 0x04},
+	{0x4002, 0x45},
+	{0x4004, 0x08},
+	{0x4005, 0x18},
+	{0x4006, 0x20},
+	{0x4008, 0x24},
+	{0x4009, 0x10},
+	{0x400c, 0x00},
+	{0x400d, 0x00},
+	{0x4058, 0x00},
+	{0x404e, 0x37},
+	{0x404f, 0x8f},
+	{0x4058, 0x00},
+	{0x4101, 0xb2},
+	{0x4303, 0x00},
+	{0x4304, 0x08},
+	{0x4307, 0x30},
+	{0x4311, 0x04},
+	{0x4315, 0x01},
+	{0x4511, 0x05},
+	{0x4512, 0x01},
+	{0x4800, 0x20}, /* dis-continuous */
+	{0x4806, 0x00},
+	{0x4816, 0x52},
+	{0x481f, 0x30},
+	{0x4826, 0x32},
+	{0x4831, 0x6a},
+	{0x4d00, 0x04},
+	{0x4d01, 0x71},
+	{0x4d02, 0xfd},
+	{0x4d03, 0xf5},
+	{0x4d04, 0x0c},
+	{0x4d05, 0xcc},
+	{0x4837, 0x0a},
+	{0x5000, 0x06},
+	{0x5001, 0x01},
+	{0x5002, 0x00},
+	{0x5003, 0x20},
+	{0x5046, 0x0a},
+	{0x5013, 0x00},
+	{0x5046, 0x0a},
+	{0x5780, 0xfc},
+	{0x5781, 0x13},
+	{0x5782, 0x03},
+	{0x5786, 0x20},
+	{0x5787, 0x40},
+	{0x5788, 0x08},
+	{0x5789, 0x08},
+	{0x578a, 0x02},
+	{0x578b, 0x01},
+	{0x578c, 0x01},
+	{0x578d, 0x0c},
+	{0x578e, 0x02},
+	{0x578f, 0x01},
+	{0x5790, 0x01},
+	{0x5791, 0xff},
+	{0x5842, 0x01},
+	{0x5843, 0x2b},
+	{0x5844, 0x01},
+	{0x5845, 0x92},
+	{0x5846, 0x01},
+	{0x5847, 0x8f},
+	{0x5848, 0x01},
+	{0x5849, 0x0c},
+	{0x5e00, 0x00},
+	{0x5e10, 0x0c},
+	{OV5670_TABLE_END, 0x0000}
+};
+
+static const ov5670_reg mode_1920x1080_regs[] = {
+	{OV5670_TABLE_WAIT_MS, OV5670_WAIT_MS},
+	{0x0100, 0x00},
+	{0x3000, 0x00},
+	{0x3002, 0x21},
+	{0x3005, 0xf0},
+	{0x3007, 0x00},
+	{0x3015, 0x0f},
+	{0x3018, 0x32},
+	{0x301a, 0xf0},
+	{0x301b, 0xf0},
+	{0x301c, 0xf0},
+	{0x301d, 0xf0},
+	{0x301e, 0xf0},
+	{0x3021, 0x03},
+	{0x3030, 0x00},
+	{0x3031, 0x0a},
+	{0x303c, 0xff},
+	{0x303e, 0xff},
+	{0x3040, 0xf0},
+	{0x3041, 0x00},
+	{0x3042, 0xf0},
+	{0x3106, 0x11},
+	{0x3500, 0x00},
+	{0x3502, 0x00},
+	{0x3503, 0x04},
+	{0x3504, 0x03},
+	{0x3505, 0x83},
+	{0x3508, 0x04},
+	{0x3509, 0x00},
+	{0x350e, 0x04},
+	{0x350f, 0x00},
+	{0x3510, 0x00},
+	{0x3511, 0x02},
+	{0x3512, 0x00},
+	{0x3601, 0xc8},
+	{0x3610, 0x88},
+	{0x3612, 0x48},
+	{0x3614, 0x5b},
+	{0x3615, 0x96},
+	{0x3621, 0xd0},
+	{0x3622, 0x00},
+	{0x3623, 0x00},
+	{0x3633, 0x13},
+	{0x3634, 0x13},
+	{0x3635, 0x13},
+	{0x3636, 0x13},
+	{0x3645, 0x13},
+	{0x3646, 0x82},
+	{0x3650, 0x00},
+	{0x3652, 0xff},
+	{0x3655, 0x20},
+	{0x3656, 0xff},
+	{0x365a, 0xff},
+	{0x365e, 0xff},
+	{0x3668, 0x00},
+	{0x366a, 0x07},
+	{0x366e, 0x10},
+	{0x366d, 0x00},
+	{0x366f, 0x80},
+	{0x3700, 0x28},
+	{0x3701, 0x10},
+	{0x3702, 0x3a},
+	{0x3703, 0x19},
+	{0x3704, 0x10},
+	{0x3705, 0x00},
+	{0x3706, 0x66},
+	{0x3707, 0x08},
+	{0x3708, 0x34},
+	{0x3709, 0x40},
+	{0x370a, 0x01},
+	{0x370b, 0x1b},
+	{0x3714, 0x24},
+	{0x371a, 0x3e},
+	{0x3733, 0x00},
+	{0x3734, 0x00},
+	{0x373a, 0x05},
+	{0x373b, 0x06},
+	{0x373c, 0x0a},
+	{0x373f, 0xa0},
+	{0x3755, 0x00},
+	{0x3758, 0x00},
+	{0x375b, 0x0e},
+	{0x3766, 0x5f},
+	{0x3768, 0x00},
+	{0x3769, 0x22},
+	{0x3773, 0x08},
+	{0x3774, 0x1f},
+	{0x3776, 0x06},
+	{0x37a0, 0x88},
+	{0x37a1, 0x5c},
+	{0x37a7, 0x88},
+	{0x37a8, 0x70},
+	{0x37aa, 0x88},
+	{0x37ab, 0x48},
+	{0x37b3, 0x66},
+	{0x37c2, 0x04},
+	{0x37c5, 0x00},
+	{0x37c8, 0x00},
+	{0x3800, 0x00},
+	{0x3801, 0x0c},
+	{0x3802, 0x00},
+	{0x3803, 0x04},
+	{0x3804, 0x0a},
+	{0x3805, 0x33},
+	{0x3806, 0x07},
+	{0x3807, 0xa3},
+	{0x3811, 0x04},
+	{0x3813, 0x02},
+	{0x3815, 0x01},
+	{0x3816, 0x00},
+	{0x3817, 0x00},
+	{0x3818, 0x00},
+	{0x3819, 0x00},
+	{0x3820, 0x00},
+	{0x3821, 0x06},
+	{0x3822, 0x48},
+	{0x3826, 0x00},
+	{0x3827, 0x08},
+	{0x3830, 0x08},
+	{0x3836, 0x02},
+	{0x3837, 0x00},
+	{0x3838, 0x10},
+	{0x3841, 0xff}, /* Auto size function enabled */
+	{0x3846, 0x48},
+	{0x3861, 0x00},
+	{0x3862, 0x04},
+	{0x3863, 0x06},
+	{0x3a11, 0x01},
+	{0x3a12, 0x78},
+	{0x3b00, 0x00},
+	{0x3b02, 0x00},
+	{0x3b03, 0x00},
+	{0x3b04, 0x00},
+	{0x3b05, 0x00},
+	{0x3c00, 0x89},
+	{0x3c01, 0xab},
+	{0x3c02, 0x01},
+	{0x3c03, 0x00},
+	{0x3c04, 0x00},
+	{0x3c05, 0x03},
+	{0x3c06, 0x00},
+	{0x3c07, 0x05},
+	{0x3c0c, 0x00},
+	{0x3c0d, 0x00},
+	{0x3c0e, 0x00},
+	{0x3c0f, 0x00},
+	{0x3c40, 0x00},
+	{0x3c41, 0xa3},
+	{0x3c43, 0x7d},
+	{0x3c45, 0xd7},
+	{0x3c47, 0xfc},
+	{0x3c50, 0x05},
+	{0x3c52, 0xaa},
+	{0x3c54, 0x71},
+	{0x3c56, 0x80},
+	{0x3d85, 0x17},
+	{0x3d8d, 0xea},
+	{0x3f03, 0x00},
+	{0x3f0a, 0x00},
+	{0x3f0b, 0x00},
+	{0x4001, 0x60},
+	{0x4009, 0x0d},
+	{0x4017, 0x08},
+	{0x4020, 0x00},
+	{0x4021, 0x00},
+	{0x4022, 0x00},
+	{0x4023, 0x00},
+	{0x4024, 0x00},
+	{0x4025, 0x00},
+	{0x4026, 0x00},
+	{0x4027, 0x00},
+	{0x4028, 0x00},
+	{0x4029, 0x00},
+	{0x402a, 0x00},
+	{0x402b, 0x00},
+	{0x402c, 0x00},
+	{0x402d, 0x00},
+	{0x402e, 0x00},
+	{0x402f, 0x00},
+	{0x4040, 0x00},
+	{0x4041, 0x03},
+	{0x4042, 0x00},
+	{0x4043, 0x7A},
+	{0x4044, 0x00},
+	{0x4045, 0x7A},
+	{0x4046, 0x00},
+	{0x4047, 0x7A},
+	{0x4048, 0x00},
+	{0x4049, 0x7A},
+	{0x4303, 0x00},
+	{0x4307, 0x30},
+	{0x4320, 0x80},
+	{0x4500, 0x58},
+	{0x4501, 0x04},
+	{0x4502, 0x40},
+	{0x4503, 0x10},
+	{0x4508, 0xaa},
+	{0x4509, 0xaa},
+	{0x450a, 0x00},
+	{0x450b, 0x00},
+	{0x4700, 0xa4},
+	{0x4800, 0x4c},
+	{0x4816, 0x53},
+	{0x481f, 0x40},
+	{0x4837, 0x13},
+	{0x5000, 0x56},
+	{0x5001, 0x01},
+	{0x5002, 0x28},
+	{0x5004, 0x0c},
+	{0x5006, 0x0c},
+	{0x5007, 0xe0},
+	{0x5008, 0x01},
+	{0x5009, 0xb0},
+	{0x5901, 0x00},
+	{0x5a01, 0x00},
+	{0x5a03, 0x00},
+	{0x5a04, 0x0c},
+	{0x5a05, 0xe0},
+	{0x5a06, 0x09},
+	{0x5a07, 0xb0},
+	{0x5a08, 0x06},
+	{0x5e00, 0x00},
+	{0x3734, 0x40},
+	{0x5b00, 0x01},
+	{0x5b01, 0x10},
+	{0x5b02, 0x01},
+	{0x5b03, 0xdb},
+	{0x3d8c, 0x71},
+	{0x370b, 0x05},
+	{0x3618, 0x2a},
+	{0x5780, 0x3e},
+	{0x5781, 0x0f},
+	{0x5782, 0x44},
+	{0x5783, 0x02},
+	{0x5784, 0x01},
+	{0x5785, 0x01},
+	{0x5786, 0x00},
+	{0x5787, 0x04},
+	{0x5788, 0x02},
+	{0x5789, 0x0f},
+	{0x578a, 0xfd},
+	{0x578b, 0xf5},
+	{0x578c, 0xf5},
+	{0x578d, 0x03},
+	{0x578e, 0x08},
+	{0x578f, 0x0c},
+	{0x5790, 0x08},
+	{0x5791, 0x06},
+	{0x5792, 0x00},
+	{0x5793, 0x52},
+	{0x5794, 0xa3},
+	{0x3503, 0x00},
+	{0x380e, 0x04},
+	{0x380f, 0x60},
+	{0x3002, 0x61},
+	{0x3010, 0x40},
+	{0x300D, 0x00},
+	{0x5045, 0x05},
+	{0x5048, 0x10},
+	{0x3610, 0xa8},
+	{0x3733, 0x10},
+	{0x3734, 0x40},
+	{0x3808, 0x07},
+	{0x3809, 0x80},
+	{0x380a, 0x04},
+	{0x380b, 0x38},
+	{0x3821, 0x06},
+	{0x4600, 0x00},
+	{0x4601, 0xc0},
+	{OV5670_TABLE_END, 0x0000}
+};
+
+static const ov5670_reg mode_1920x1080[] = {
+	{OV5670_TABLE_WAIT_MS, OV5670_WAIT_MS},
+	{0x0100, 0x00},/*, 0xIncluding, 0xsw, 0xreset, 0x*/
+	{0x3001, 0x0a},
+	{0x3002, 0x80},
+	{0x3006, 0x00},
+	{0x3011, 0x21},
+	{0x3012, 0x09},
+	{0x3013, 0x10},
+	{0x3014, 0x00},
+	{0x3015, 0x08},
+	{0x3016, 0xf0},
+	{0x3017, 0xf0},
+	{0x3018, 0xf0},
+	{0x301b, 0xb4},
+	{0x301d, 0x02},
+	{0x3021, 0x00},
+	{0x3022, 0x01},
+	{0x3028, 0x44},
+	{0x3098, 0x03},
+	{0x3099, 0x1e},
+	{0x309a, 0x02},
+	{0x309b, 0x01},
+	{0x309c, 0x00},
+	{0x30a0, 0xd2},
+	{0x30a2, 0x01},
+	{0x30b2, 0x00},
+	{0x30b3, 0x68},
+	{0x30b4, 0x03},
+	{0x30b5, 0x04},
+	{0x30b6, 0x01},
+	{0x3104, 0x21},
+	{0x3106, 0x00},
+	{0x3406, 0x01},
+	{0x3500, 0x00},
+	{0x3501, 0x7b},
+	{0x3502, 0x00},
+	{0x3503, 0x07},
+	{0x3504, 0x00},
+	{0x3505, 0x00},
+	{0x3506, 0x00},
+	{0x3507, 0x02},
+	{0x3508, 0x00},
+	{0x3509, 0x10},
+	{0x350a, 0x00},
+	{0x350b, 0x40},
+	{0x3601, 0x0a},
+	{0x3602, 0x38},
+	{0x3612, 0x80},
+	{0x3620, 0x54},
+	{0x3621, 0xc7},
+	{0x3622, 0x0f},
+	{0x3625, 0x10},
+	{0x3630, 0x55},
+	{0x3631, 0xf4},
+	{0x3632, 0x00},
+	{0x3633, 0x34},
+	{0x3634, 0x02},
+	{0x364d, 0x0d},
+	{0x364f, 0xdd},
+	{0x3660, 0x04},
+	{0x3662, 0x10},
+	{0x3663, 0xf1},
+	{0x3665, 0x00},
+	{0x3666, 0x20},
+	{0x3667, 0x00},
+	{0x366a, 0x80},
+	{0x3680, 0xe0},
+	{0x3681, 0x00},
+	{0x3700, 0x42},
+	{0x3701, 0x14},
+	{0x3702, 0xa0},
+	{0x3703, 0xd8},
+	{0x3704, 0x78},
+	{0x3705, 0x02},
+	{0x3708, 0xe2},
+	{0x3709, 0xc3},
+	{0x370a, 0x00},
+	{0x370b, 0x20},
+	{0x370c, 0x0c},
+	{0x370d, 0x11},
+	{0x370e, 0x00},
+	{0x370f, 0x40},
+	{0x3710, 0x00},
+	{0x371a, 0x1c},
+	{0x371b, 0x05},
+	{0x371c, 0x01},
+	{0x371e, 0xa1},
+	{0x371f, 0x0c},
+	{0x3721, 0x00},
+	{0x3724, 0x10},
+	{0x3726, 0x00},
+	{0x372a, 0x01},
+	{0x3730, 0x10},
+	{0x3738, 0x22},
+	{0x3739, 0xe5},
+	{0x373a, 0x50},
+	{0x373b, 0x02},
+	{0x373c, 0x41},
+	{0x373f, 0x02},
+	{0x3740, 0x42},
+	{0x3741, 0x02},
+	{0x3742, 0x18},
+	{0x3743, 0x01},
+	{0x3744, 0x02},
+	{0x3747, 0x10},
+	{0x374c, 0x04},
+	{0x3751, 0xf0},
+	{0x3752, 0x00},
+	{0x3753, 0x00},
+	{0x3754, 0xc0},
+	{0x3755, 0x00},
+	{0x3756, 0x1a},
+	{0x3758, 0x00},
+	{0x3759, 0x0f},
+	{0x376b, 0x44},
+	{0x375c, 0x04},
+	{0x3774, 0x10},
+	{0x3776, 0x00},
+	{0x377f, 0x08},
+	{0x3780, 0x22},
+	{0x3781, 0x0c},
+	{0x3784, 0x2c},
+	{0x3785, 0x1e},
+	{0x378f, 0xf5},
+	{0x3791, 0xb0},
+	{0x3795, 0x00},
+	{0x3796, 0x64},
+	{0x3797, 0x11},
+	{0x3798, 0x30},
+	{0x3799, 0x41},
+	{0x379a, 0x07},
+	{0x379b, 0xb0},
+	{0x379c, 0x0c},
+	{0x37c5, 0x00},
+	{0x37c6, 0x00},
+	{0x37c7, 0x00},
+	{0x37c9, 0x00},
+	{0x37ca, 0x00},
+	{0x37cb, 0x00},
+	{0x37de, 0x00},
+	{0x37df, 0x00},
+	{0x3800, 0x00},
+	{0x3801, 0x00},
+	{0x3802, 0x00},
+	{0x3803, 0xf8},
+	{0x3804, 0x0a},
+	{0x3805, 0x3f},
+	{0x3806, 0x06},
+	{0x3807, 0xab},
+	{0x3808, 0x07},
+	{0x3809, 0x80},
+	{0x380a, 0x04},
+	{0x380b, 0x38},
+	{0x380c, 0x0a},
+	{0x380d, 0x80},
+	{0x380e, 0x07},
+	{0x380f, 0xc0},
+	{0x3810, 0x00},
+	{0x3811, 0x02},
+	{0x3812, 0x00},
+	{0x3813, 0x02},
+	{0x3814, 0x11},
+	{0x3815, 0x11},
+	{0x3820, 0x02},
+	{0x3821, 0x1e},
+	{0x3823, 0x00},
+	{0x3824, 0x00},
+	{0x3825, 0x00},
+	{0x3826, 0x00},
+	{0x3827, 0x00},
+	{0x382a, 0x04},
+	{0x3a04, 0x06},
+	{0x3a05, 0x14},
+	{0x3a06, 0x00},
+	{0x3a07, 0xfe},
+	{0x3b00, 0x00},
+	{0x3b02, 0x00},
+	{0x3b03, 0x00},
+	{0x3b04, 0x00},
+	{0x3b05, 0x00},
+	{0x3e07, 0x20},
+	{0x4000, 0x08},
+	{0x4001, 0x04},
+	{0x4002, 0x45},
+	{0x4004, 0x08},
+	{0x4005, 0x18},
+	{0x4006, 0x20},
+	{0x4008, 0x24},
+	{0x4009, 0x10},
+	{0x400c, 0x00},
+	{0x400d, 0x00},
+	{0x4058, 0x00},
+	{0x404e, 0x37},
+	{0x404f, 0x8f},
+	{0x4058, 0x00},
+	{0x4101, 0xb2},
+	{0x4303, 0x00},
+	{0x4304, 0x08},
+	{0x4307, 0x30},
+	{0x4311, 0x04},
+	{0x4315, 0x01},
+	{0x4511, 0x05},
+	{0x4512, 0x01},
+	{0x4800, 0x20}, /* dis-continuous */
+	{0x4806, 0x00},
+	{0x4816, 0x52},
+	{0x481f, 0x30},
+	{0x4826, 0x32},
+	{0x4831, 0x6a},
+	{0x4d00, 0x04},
+	{0x4d01, 0x71},
+	{0x4d02, 0xfd},
+	{0x4d03, 0xf5},
+	{0x4d04, 0x0c},
+	{0x4d05, 0xcc},
+	{0x4837, 0x0a},
+	{0x5000, 0x06},
+	{0x5001, 0x01},
+	{0x5002, 0x80},
+	{0x5003, 0x20},
+	{0x5046, 0x0a},
+	{0x5013, 0x00},
+	{0x5046, 0x0a},
+	{0x5780, 0x1c},
+	{0x5786, 0x20},
+	{0x5787, 0x10},
+	{0x5788, 0x18},
+	{0x578a, 0x04},
+	{0x578b, 0x02},
+	{0x578c, 0x02},
+	{0x578e, 0x06},
+	{0x578f, 0x02},
+	{0x5790, 0x02},
+	{0x5791, 0xff},
+	{0x5842, 0x01},
+	{0x5843, 0x2b},
+	{0x5844, 0x01},
+	{0x5845, 0x92},
+	{0x5846, 0x01},
+	{0x5847, 0x8f},
+	{0x5848, 0x01},
+	{0x5849, 0x0c},
+	{0x5e00, 0x00},
+	{0x5e10, 0x0c},
+	{OV5670_TABLE_END, 0x0000}
+};
+
+static const ov5670_reg mode_1280x720_120fps[] = {
+	{OV5670_TABLE_WAIT_MS, OV5670_WAIT_MS},
+	{0x0100, 0x00},/* Including sw reset */
+	{0x3001, 0x0a},
+	{0x3002, 0x80},
+	{0x3006, 0x00},
+	{0x3011, 0x21},
+	{0x3012, 0x09},
+	{0x3013, 0x10},
+	{0x3014, 0x00},
+	{0x3015, 0x08},
+	{0x3016, 0xf0},
+	{0x3017, 0xf0},
+	{0x3018, 0xf0},
+	{0x301b, 0xb4},
+	{0x301d, 0x02},
+	{0x3021, 0x00},
+	{0x3022, 0x01},
+	{0x3028, 0x44},
+	{0x3098, 0x03},
+	{0x3099, 0x1e},
+	{0x309a, 0x02},
+	{0x309b, 0x01},
+	{0x309c, 0x00},
+	{0x30a0, 0xd2},
+	{0x30a2, 0x01},
+	{0x30b2, 0x00},
+	{0x30b3, 0x68},
+	{0x30b4, 0x03},
+	{0x30b5, 0x04},
+	{0x30b6, 0x01},
+	{0x3104, 0x21},
+	{0x3106, 0x00},
+	{0x3406, 0x01},
+	{0x3500, 0x00},
+	{0x3501, 0x2e},
+	{0x3502, 0x80},
+	{0x3503, 0x07},
+	{0x3504, 0x00},
+	{0x3505, 0x00},
+	{0x3506, 0x00},
+	{0x3507, 0x02},
+	{0x3508, 0x00},
+	{0x3509, 0x10},
+	{0x350a, 0x00},
+	{0x350b, 0x40},
+	{0x3601, 0x0a},
+	{0x3602, 0x38},
+	{0x3612, 0x80},
+	{0x3620, 0x54},
+	{0x3621, 0xc7},
+	{0x3622, 0x0f},
+	{0x3625, 0x10},
+	{0x3630, 0x55},
+	{0x3631, 0xf4},
+	{0x3632, 0x00},
+	{0x3633, 0x34},
+	{0x3634, 0x02},
+	{0x364d, 0x0d},
+	{0x364f, 0xdd},
+	{0x3660, 0x04},
+	{0x3662, 0x10},
+	{0x3663, 0xf1},
+	{0x3665, 0x00},
+	{0x3666, 0x20},
+	{0x3667, 0x00},
+	{0x366a, 0x80},
+	{0x3680, 0xe0},
+	{0x3681, 0x00},
+	{0x3700, 0x42},
+	{0x3701, 0x14},
+	{0x3702, 0xa0},
+	{0x3703, 0xd8},
+	{0x3704, 0x78},
+	{0x3705, 0x02},
+	{0x3708, 0xe6},
+	{0x3709, 0xc7},
+	{0x370a, 0x00},
+	{0x370b, 0x20},
+	{0x370c, 0x0c},
+	{0x370d, 0x11},
+	{0x370e, 0x00},
+	{0x370f, 0x40},
+	{0x3710, 0x00},
+	{0x371a, 0x1c},
+	{0x371b, 0x05},
+	{0x371c, 0x01},
+	{0x371e, 0xa1},
+	{0x371f, 0x0c},
+	{0x3721, 0x00},
+	{0x3724, 0x10},
+	{0x3726, 0x00},
+	{0x372a, 0x01},
+	{0x3730, 0x10},
+	{0x3738, 0x22},
+	{0x3739, 0xe5},
+	{0x373a, 0x50},
+	{0x373b, 0x02},
+	{0x373c, 0x41},
+	{0x373f, 0x02},
+	{0x3740, 0x42},
+	{0x3741, 0x02},
+	{0x3742, 0x18},
+	{0x3743, 0x01},
+	{0x3744, 0x02},
+	{0x3747, 0x10},
+	{0x374c, 0x04},
+	{0x3751, 0xf0},
+	{0x3752, 0x00},
+	{0x3753, 0x00},
+	{0x3754, 0xc0},
+	{0x3755, 0x00},
+	{0x3756, 0x1a},
+	{0x3758, 0x00},
+	{0x3759, 0x0f},
+	{0x376b, 0x44},
+	{0x375c, 0x04},
+	{0x3774, 0x10},
+	{0x3776, 0x00},
+	{0x377f, 0x08},
+	{0x3780, 0x22},
+	{0x3781, 0x0c},
+	{0x3784, 0x2c},
+	{0x3785, 0x1e},
+	{0x378f, 0xf5},
+	{0x3791, 0xb0},
+	{0x3795, 0x00},
+	{0x3796, 0x64},
+	{0x3797, 0x11},
+	{0x3798, 0x30},
+	{0x3799, 0x41},
+	{0x379a, 0x07},
+	{0x379b, 0xb0},
+	{0x379c, 0x0c},
+	{0x37c5, 0x00},
+	{0x37c6, 0x00},
+	{0x37c7, 0x00},
+	{0x37c9, 0x00},
+	{0x37ca, 0x00},
+	{0x37cb, 0x00},
+	{0x37de, 0x00},
+	{0x37df, 0x00},
+	{0x3800, 0x00},
+	{0x3801, 0x00},
+	{0x3802, 0x00},
+	{0x3803, 0xf4},
+	{0x3804, 0x0a},
+	{0x3805, 0x3f},
+	{0x3806, 0x06},
+	{0x3807, 0xab},
+	{0x3808, 0x05},
+	{0x3809, 0x00},
+	{0x380a, 0x02},
+	{0x380b, 0xd0},
+	{0x380c, 0x06},
+	{0x380d, 0xd8},
+	{0x380e, 0x02},
+	{0x380f, 0xf8},
+	{0x3810, 0x00},
+	{0x3811, 0x02},
+	{0x3812, 0x00},
+	{0x3813, 0x02},
+	{0x3814, 0x31},
+	{0x3815, 0x31},
+	{0x3820, 0x02},
+	{0x3821, 0x1f},
+	{0x3823, 0x00},
+	{0x3824, 0x00},
+	{0x3825, 0x00},
+	{0x3826, 0x00},
+	{0x3827, 0x00},
+	{0x382a, 0x04},
+	{0x3a04, 0x06},
+	{0x3a05, 0x14},
+	{0x3a06, 0x00},
+	{0x3a07, 0xfe},
+	{0x3b00, 0x00},
+	{0x3b02, 0x00},
+	{0x3b03, 0x00},
+	{0x3b04, 0x00},
+	{0x3b05, 0x00},
+	{0x3e07, 0x20},
+	{0x4000, 0x08},
+	{0x4001, 0x04},
+	{0x4002, 0x45},
+	{0x4004, 0x08},
+	{0x4005, 0x18},
+	{0x4006, 0x20},
+	{0x4008, 0x24},
+	{0x4009, 0x10},
+	{0x400c, 0x00},
+	{0x400d, 0x00},
+	{0x4058, 0x00},
+	{0x404e, 0x37},
+	{0x404f, 0x8f},
+	{0x4058, 0x00},
+	{0x4101, 0xb2},
+	{0x4303, 0x00},
+	{0x4304, 0x08},
+	{0x4307, 0x30},
+	{0x4311, 0x04},
+	{0x4315, 0x01},
+	{0x4511, 0x05},
+	{0x4512, 0x00},
+	{0x4800, 0x20}, /* dis-continuous */
+	{0x4806, 0x00},
+	{0x4816, 0x52},
+	{0x481f, 0x30},
+	{0x4826, 0x32},
+	{0x4831, 0x6a},
+	{0x4d00, 0x04},
+	{0x4d01, 0x71},
+	{0x4d02, 0xfd},
+	{0x4d03, 0xf5},
+	{0x4d04, 0x0c},
+	{0x4d05, 0xcc},
+	{0x4837, 0x0a},
+	{0x5000, 0x06},
+	{0x5001, 0x01},
+	{0x5002, 0x00},
+	{0x5003, 0x20},
+	{0x5046, 0x0a},
+	{0x5013, 0x00},
+	{0x5046, 0x0a},
+	{0x5780, 0x1c},
+	{0x5786, 0x20},
+	{0x5787, 0x10},
+	{0x5788, 0x18},
+	{0x578a, 0x04},
+	{0x578b, 0x02},
+	{0x578c, 0x02},
+	{0x578e, 0x06},
+	{0x578f, 0x02},
+	{0x5790, 0x02},
+	{0x5791, 0xff},
+	{0x5842, 0x01},
+	{0x5843, 0x2b},
+	{0x5844, 0x01},
+	{0x5845, 0x92},
+	{0x5846, 0x01},
+	{0x5847, 0x8f},
+	{0x5848, 0x01},
+	{0x5849, 0x0c},
+	{0x5e00, 0x00},
+	{0x5e10, 0x0c},
+	{OV5670_TABLE_END, 0x0000}
+};
+
+static const ov5670_reg mode_2592x1944_HDR_24fps[] = {
+	{OV5670_TABLE_WAIT_MS, OV5670_WAIT_MS},
+	{0x0100, 0x00},/* Including sw reset */
+	{0x0103, 0x01},
+	{0x3001, 0x0a},
+	{0x3002, 0x80},
+	{0x3006, 0x00},
+	{0x3011, 0x21},
+	{0x3012, 0x09},
+	{0x3013, 0x10},
+	{0x3014, 0x00},
+	{0x3015, 0x08},
+	{0x3016, 0xf0},
+	{0x3017, 0xf0},
+	{0x3018, 0xf0},
+	{0x301b, 0xb4},
+	{0x301d, 0x02},
+	{0x3021, 0x00},
+	{0x3022, 0x01},
+	{0x3028, 0x44},
+	{0x3098, 0x02},
+	{0x3099, 0x16},
+	{0x309a, 0x02},
+	{0x309b, 0x01},
+	{0x309c, 0x00},
+	{0x30b2, 0x00},
+	{0x30b3, 0x6e},
+	{0x30b4, 0x03},
+	{0x30a0, 0xd2},
+	{0x30a2, 0x01},
+	{0x30b5, 0x04},
+	{0x30b6, 0x01},
+	{0x3104, 0x21},
+	{0x3106, 0x00},
+	{0x3406, 0x01},
+	{0x3500, 0x00},
+	{0x3501, 0x7b},
+	{0x3502, 0x80},
+	{0x3503, 0x07},
+	{0x3504, 0x00},
+	{0x3505, 0x00},
+	{0x3506, 0x00},
+	{0x3507, 0x01},
+	{0x3508, 0x80},
+	{0x3509, 0x10},
+	{0x350a, 0x00},
+	{0x350b, 0x40},
+	{0x3601, 0x0a},
+	{0x3602, 0x38},
+	{0x3612, 0x80},
+	{0x3620, 0x54},
+	{0x3621, 0xc7},
+	{0x3622, 0x05},
+	{0x3625, 0x10},
+	{0x3630, 0x55},
+	{0x3631, 0xf4},
+	{0x3632, 0x00},
+	{0x3633, 0x34},
+	{0x3634, 0x02},
+	{0x364d, 0x0d},
+	{0x364f, 0xdd},
+	{0x3660, 0x04},
+	{0x3662, 0x10},
+	{0x3663, 0xf1},
+	{0x3665, 0x00},
+	{0x3666, 0x20},
+	{0x3667, 0x00},
+	{0x366a, 0x80},
+	{0x3680, 0xe0},
+	{0x3681, 0x00},
+	{0x3700, 0x42},
+	{0x3701, 0x14},
+	{0x3702, 0xa0},
+	{0x3703, 0xa8},
+	{0x3704, 0x78},
+	{0x3705, 0x02},
+	{0x3708, 0xe2},
+	{0x3709, 0xc3},
+	{0x370a, 0x00},
+	{0x370b, 0x20},
+	{0x370c, 0x0c},
+	{0x370d, 0x11},
+	{0x370e, 0x00},
+	{0x370f, 0x40},
+	{0x3710, 0x00},
+	{0x371a, 0x0c},
+	{0x371b, 0x05},
+	{0x371c, 0x01},
+	{0x371e, 0xa1},
+	{0x371f, 0x0c},
+	{0x3721, 0x00},
+	{0x3724, 0x10},
+	{0x3726, 0x00},
+	{0x372a, 0x01},
+	{0x3730, 0x10},
+	{0x3738, 0x22},
+	{0x3739, 0xe5},
+	{0x373a, 0x50},
+	{0x373b, 0x02},
+	{0x373c, 0x41},
+	{0x373f, 0x02},
+	{0x3740, 0x42},
+	{0x3741, 0x02},
+	{0x3742, 0x18},
+	{0x3743, 0x01},
+	{0x3744, 0x02},
+	{0x3747, 0x10},
+	{0x374c, 0x04},
+	{0x3751, 0xf0},
+	{0x3752, 0x00},
+	{0x3753, 0x00},
+	{0x3754, 0xc0},
+	{0x3755, 0x00},
+	{0x3756, 0x1a},
+	{0x3758, 0x00},
+	{0x3759, 0x0f},
+	{0x376b, 0x44},
+	{0x375c, 0x04},
+	{0x3774, 0x10},
+	{0x3776, 0x00},
+	{0x377f, 0x08},
+	{0x3780, 0x22},
+	{0x3781, 0x0c},
+	{0x3784, 0x2c},
+	{0x3785, 0x1e},
+	{0x378f, 0xf5},
+	{0x3791, 0xb0},
+	{0x3795, 0x00},
+	{0x3796, 0x64},
+	{0x3797, 0x11},
+	{0x3798, 0x30},
+	{0x3799, 0x41},
+	{0x379a, 0x07},
+	{0x379b, 0xb0},
+	{0x379c, 0x0c},
+	{0x37c5, 0x00},
+	{0x37c6, 0x00},
+	{0x37c7, 0x00},
+	{0x37c9, 0x00},
+	{0x37ca, 0x00},
+	{0x37cb, 0x00},
+	{0x37de, 0x00},
+	{0x37df, 0x00},
+	{0x3800, 0x00},
+	{0x3801, 0x02},
+	{0x3802, 0x00},
+	{0x3803, 0x06},
+	{0x3804, 0x0a},
+	{0x3805, 0x41},
+	{0x3806, 0x07},
+	{0x3807, 0xa1},
+	{0x3808, 0x0a},
+	{0x3809, 0x20},
+	{0x380a, 0x07},
+	{0x380b, 0x98},
+	{0x380c, 0x0e},
+	{0x380d, 0x70},
+	{0x380e, 0x07},
+	{0x380f, 0xc0},
+	{0x3810, 0x00},
+	{0x3811, 0x10},
+	{0x3812, 0x00},
+	{0x3813, 0x02},
+	{0x3814, 0x11},
+	{0x3815, 0x11},
+	{0x3820, 0x02},
+	{0x3821, 0x9e},
+	{0x3823, 0x00},
+	{0x3824, 0x00},
+	{0x3825, 0x00},
+	{0x3826, 0x00},
+	{0x3827, 0x00},
+	{0x382a, 0x04},
+	{0x3a04, 0x09},
+	{0x3a05, 0xa9},
+	{0x3a06, 0x00},
+	{0x3a07, 0xfe},
+	{0x3b00, 0x00},
+	{0x3b02, 0x00},
+	{0x3b03, 0x00},
+	{0x3b04, 0x00},
+	{0x3b05, 0x00},
+	{0x3e07, 0x20},
+	{0x4000, 0x08},
+	{0x4001, 0x04},
+	{0x4002, 0x45},
+	{0x4004, 0x08},
+	{0x4005, 0x18},
+	{0x4006, 0x20},
+	{0x4008, 0x24},
+	{0x4009, 0x10},
+	{0x400c, 0x00},
+	{0x400d, 0x00},
+	{0x4058, 0x00},
+	{0x404e, 0x37},
+	{0x404f, 0x8f},
+	{0x4058, 0x00},
+	{0x4101, 0xb2},
+	{0x4303, 0x00},
+	{0x4304, 0x08},
+	{0x4307, 0x30},
+	{0x4311, 0x04},
+	{0x4315, 0x01},
+	{0x4511, 0x05},
+	{0x4512, 0x01},
+	{0x4800, 0x20}, /* dis-continuous */
+	{0x4806, 0x00},
+	{0x4816, 0x52},
+	{0x481f, 0x30},
+	{0x4826, 0x32},
+	{0x4831, 0x6a},
+	{0x4d00, 0x04},
+	{0x4d01, 0x71},
+	{0x4d02, 0xfd},
+	{0x4d03, 0xf5},
+	{0x4d04, 0x0c},
+	{0x4d05, 0xcc},
+	{0x4837, 0x0a},
+	{0x5000, 0x06},
+	{0x5001, 0x01},
+	{0x5002, 0x00},
+	{0x5003, 0x20},
+	{0x5046, 0x0a},
+	{0x5013, 0x00},
+	{0x5046, 0x0a},
+	{0x5780, 0x1c},
+	{0x5786, 0x20},
+	{0x5787, 0x10},
+	{0x5788, 0x18},
+	{0x578a, 0x04},
+	{0x578b, 0x02},
+	{0x578c, 0x02},
+	{0x578e, 0x06},
+	{0x578f, 0x02},
+	{0x5790, 0x02},
+	{0x5791, 0xff},
+	{0x5842, 0x01},
+	{0x5843, 0x2b},
+	{0x5844, 0x01},
+	{0x5845, 0x92},
+	{0x5846, 0x01},
+	{0x5847, 0x8f},
+	{0x5848, 0x01},
+	{0x5849, 0x0c},
+	{0x5e00, 0x00},
+	{0x5e10, 0x0c},
+	{OV5670_TABLE_END, 0x0000}
+};
+
+static const ov5670_reg mode_1920x1080_HDR_30fps[] = {
+	{OV5670_TABLE_WAIT_MS, OV5670_WAIT_MS},
+	{0x0100, 0x00},/* Including sw reset */
+	{0x0103, 0x01},
+	{0x3001, 0x0a},
+	{0x3002, 0x80},
+	{0x3006, 0x00},
+	{0x3011, 0x21},
+	{0x3012, 0x09},
+	{0x3013, 0x10},
+	{0x3014, 0x00},
+	{0x3015, 0x08},
+	{0x3016, 0xf0},
+	{0x3017, 0xf0},
+	{0x3018, 0xf0},
+	{0x301b, 0xb4},
+	{0x301d, 0x02},
+	{0x3021, 0x00},
+	{0x3022, 0x01},
+	{0x3028, 0x44},
+	{0x3098, 0x03},
+	{0x3099, 0x1e},
+	{0x309a, 0x02},
+	{0x309b, 0x01},
+	{0x309c, 0x00},
+	{0x30a0, 0xd2},
+	{0x30a2, 0x01},
+	{0x30b2, 0x00},
+	{0x30b3, 0x68},
+	{0x30b4, 0x03},
+	{0x30b5, 0x04},
+	{0x30b6, 0x01},
+	{0x3104, 0x21},
+	{0x3106, 0x00},
+	{0x3406, 0x01},
+	{0x3500, 0x00},
+	{0x3501, 0x72},
+	{0x3502, 0x00},
+	{0x3503, 0x07},
+	{0x3504, 0x00},
+	{0x3505, 0x00},
+	{0x3506, 0x00},
+	{0x3507, 0x01},
+	{0x3508, 0x80},
+	{0x3509, 0x10},
+	{0x350a, 0x00},
+	{0x350b, 0x40},
+	{0x3601, 0x0a},
+	{0x3602, 0x38},
+	{0x3612, 0x80},
+	{0x3620, 0x54},
+	{0x3621, 0xc7},
+	{0x3622, 0x0f},
+	{0x3625, 0x10},
+	{0x3630, 0x55},
+	{0x3631, 0xf4},
+	{0x3632, 0x00},
+	{0x3633, 0x34},
+	{0x3634, 0x02},
+	{0x364d, 0x0d},
+	{0x364f, 0xdd},
+	{0x3660, 0x04},
+	{0x3662, 0x10},
+	{0x3663, 0xf1},
+	{0x3665, 0x00},
+	{0x3666, 0x20},
+	{0x3667, 0x00},
+	{0x366a, 0x80},
+	{0x3680, 0xe0},
+	{0x3681, 0x00},
+	{0x3700, 0x42},
+	{0x3701, 0x14},
+	{0x3702, 0xa0},
+	{0x3703, 0xd8},
+	{0x3704, 0x78},
+	{0x3705, 0x02},
+	{0x3708, 0xe2},
+	{0x3709, 0xc3},
+	{0x370a, 0x00},
+	{0x370b, 0x20},
+	{0x370c, 0x0c},
+	{0x370d, 0x11},
+	{0x370e, 0x00},
+	{0x370f, 0x40},
+	{0x3710, 0x00},
+	{0x371a, 0x1c},
+	{0x371b, 0x05},
+	{0x371c, 0x01},
+	{0x371e, 0xa1},
+	{0x371f, 0x0c},
+	{0x3721, 0x00},
+	{0x3724, 0x10},
+	{0x3726, 0x00},
+	{0x372a, 0x01},
+	{0x3730, 0x10},
+	{0x3738, 0x22},
+	{0x3739, 0xe5},
+	{0x373a, 0x50},
+	{0x373b, 0x02},
+	{0x373c, 0x41},
+	{0x373f, 0x02},
+	{0x3740, 0x42},
+	{0x3741, 0x02},
+	{0x3742, 0x18},
+	{0x3743, 0x01},
+	{0x3744, 0x02},
+	{0x3747, 0x10},
+	{0x374c, 0x04},
+	{0x3751, 0xf0},
+	{0x3752, 0x00},
+	{0x3753, 0x00},
+	{0x3754, 0xc0},
+	{0x3755, 0x00},
+	{0x3756, 0x1a},
+	{0x3758, 0x00},
+	{0x3759, 0x0f},
+	{0x376b, 0x44},
+	{0x375c, 0x04},
+	{0x3774, 0x10},
+	{0x3776, 0x00},
+	{0x377f, 0x08},
+	{0x3780, 0x22},
+	{0x3781, 0x0c},
+	{0x3784, 0x2c},
+	{0x3785, 0x1e},
+	{0x378f, 0xf5},
+	{0x3791, 0xb0},
+	{0x3795, 0x00},
+	{0x3796, 0x64},
+	{0x3797, 0x11},
+	{0x3798, 0x30},
+	{0x3799, 0x41},
+	{0x379a, 0x07},
+	{0x379b, 0xb0},
+	{0x379c, 0x0c},
+	{0x37c5, 0x00},
+	{0x37c6, 0x00},
+	{0x37c7, 0x00},
+	{0x37c9, 0x00},
+	{0x37ca, 0x00},
+	{0x37cb, 0x00},
+	{0x37de, 0x00},
+	{0x37df, 0x00},
+	{0x3800, 0x01},
+	{0x3801, 0x70},
+	{0x3802, 0x01},
+	{0x3803, 0xbc},
+	{0x3804, 0x09},
+	{0x3805, 0x0f},
+	{0x3806, 0x05},
+	{0x3807, 0xff},
+	{0x3808, 0x07},
+	{0x3809, 0x80},
+	{0x380a, 0x04},
+	{0x380b, 0x38},
+	{0x380c, 0x0b},
+	{0x380d, 0x40},
+	{0x380e, 0x07},
+	{0x380f, 0x3a},
+	{0x3810, 0x00},
+	{0x3811, 0x02},
+	{0x3812, 0x00},
+	{0x3813, 0x02},
+	{0x3814, 0x11},
+	{0x3815, 0x11},
+	{0x3820, 0x02},
+	{0x3821, 0x9e},
+	{0x3823, 0x00},
+	{0x3824, 0x00},
+	{0x3825, 0x00},
+	{0x3826, 0x00},
+	{0x3827, 0x00},
+	{0x382a, 0x04},
+	{0x3a04, 0x09},
+	{0x3a05, 0xa9},
+	{0x3a06, 0x00},
+	{0x3a07, 0xfe},
+	{0x3b00, 0x00},
+	{0x3b02, 0x00},
+	{0x3b03, 0x00},
+	{0x3b04, 0x00},
+	{0x3b05, 0x00},
+	{0x3e07, 0x20},
+	{0x4000, 0x08},
+	{0x4001, 0x04},
+	{0x4002, 0x45},
+	{0x4004, 0x08},
+	{0x4005, 0x18},
+	{0x4006, 0x20},
+	{0x4008, 0x24},
+	{0x4009, 0x10},
+	{0x400c, 0x00},
+	{0x400d, 0x00},
+	{0x4058, 0x00},
+	{0x404e, 0x37},
+	{0x404f, 0x8f},
+	{0x4058, 0x00},
+	{0x4101, 0xb2},
+	{0x4303, 0x00},
+	{0x4304, 0x08},
+	{0x4307, 0x30},
+	{0x4311, 0x04},
+	{0x4315, 0x01},
+	{0x4511, 0x05},
+	{0x4512, 0x01},
+	{0x4800, 0x20}, /* dis-continuous */
+	{0x4806, 0x00},
+	{0x4816, 0x52},
+	{0x481f, 0x30},
+	{0x4826, 0x32},
+	{0x4831, 0x6a},
+	{0x4d00, 0x04},
+	{0x4d01, 0x71},
+	{0x4d02, 0xfd},
+	{0x4d03, 0xf5},
+	{0x4d04, 0x0c},
+	{0x4d05, 0xcc},
+	{0x4837, 0x0a},
+	{0x5000, 0x06},
+	{0x5001, 0x01},
+	{0x5002, 0x00},
+	{0x5003, 0x20},
+	{0x5046, 0x0a},
+	{0x5013, 0x00},
+	{0x5046, 0x0a},
+	{0x5780, 0x1c},
+	{0x5786, 0x20},
+	{0x5787, 0x10},
+	{0x5788, 0x18},
+	{0x578a, 0x04},
+	{0x578b, 0x02},
+	{0x578c, 0x02},
+	{0x578e, 0x06},
+	{0x578f, 0x02},
+	{0x5790, 0x02},
+	{0x5791, 0xff},
+	{0x5842, 0x01},
+	{0x5843, 0x2b},
+	{0x5844, 0x01},
+	{0x5845, 0x92},
+	{0x5846, 0x01},
+	{0x5847, 0x8f},
+	{0x5848, 0x01},
+	{0x5849, 0x0c},
+	{0x5e00, 0x00},
+	{0x5e10, 0x0c},
+	{OV5670_TABLE_END, 0x0000}
+};
+
+static const ov5670_reg mode_1280x720_HDR_60fps[] = {
+	{OV5670_TABLE_WAIT_MS, OV5670_WAIT_MS},
+	{0x0100, 0x00},/* Including sw reset */
+	{0x0103, 0x01},
+	{0x3001, 0x0a},
+	{0x3002, 0x80},
+	{0x3006, 0x00},
+	{0x3011, 0x21},
+	{0x3012, 0x09},
+	{0x3013, 0x10},
+	{0x3014, 0x00},
+	{0x3015, 0x08},
+	{0x3016, 0xf0},
+	{0x3017, 0xf0},
+	{0x3018, 0xf0},
+	{0x301b, 0xb4},
+	{0x301d, 0x02},
+	{0x3021, 0x00},
+	{0x3022, 0x01},
+	{0x3028, 0x44},
+	{0x3098, 0x03},
+	{0x3099, 0x1e},
+	{0x309a, 0x02},
+	{0x309b, 0x01},
+	{0x309c, 0x00},
+	{0x30a0, 0xd2},
+	{0x30a2, 0x01},
+	{0x30b2, 0x00},
+	{0x30b3, 0x68},
+	{0x30b4, 0x03},
+	{0x30b5, 0x04},
+	{0x30b6, 0x01},
+	{0x3104, 0x21},
+	{0x3106, 0x00},
+	{0x3406, 0x01},
+	{0x3500, 0x00},
+	{0x3501, 0x39},
+	{0x3502, 0x00},
+	{0x3503, 0x07},
+	{0x3504, 0x00},
+	{0x3505, 0x00},
+	{0x3506, 0x00},
+	{0x3507, 0x01},
+	{0x3508, 0x80},
+	{0x3509, 0x10},
+	{0x350a, 0x00},
+	{0x350b, 0x40},
+	{0x3601, 0x0a},
+	{0x3602, 0x38},
+	{0x3612, 0x80},
+	{0x3620, 0x54},
+	{0x3621, 0xc7},
+	{0x3622, 0x0f},
+	{0x3625, 0x10},
+	{0x3630, 0x55},
+	{0x3631, 0xf4},
+	{0x3632, 0x00},
+	{0x3633, 0x34},
+	{0x3634, 0x02},
+	{0x364d, 0x0d},
+	{0x364f, 0xdd},
+	{0x3660, 0x04},
+	{0x3662, 0x10},
+	{0x3663, 0xf1},
+	{0x3665, 0x00},
+	{0x3666, 0x20},
+	{0x3667, 0x00},
+	{0x366a, 0x80},
+	{0x3680, 0xe0},
+	{0x3681, 0x00},
+	{0x3700, 0x42},
+	{0x3701, 0x14},
+	{0x3702, 0xa0},
+	{0x3703, 0xd8},
+	{0x3704, 0x78},
+	{0x3705, 0x02},
+	{0x3708, 0xe2},
+	{0x3709, 0xc3},
+	{0x370a, 0x00},
+	{0x370b, 0x20},
+	{0x370c, 0x0c},
+	{0x370d, 0x11},
+	{0x370e, 0x00},
+	{0x370f, 0x40},
+	{0x3710, 0x00},
+	{0x371a, 0x1c},
+	{0x371b, 0x05},
+	{0x371c, 0x01},
+	{0x371e, 0xa1},
+	{0x371f, 0x0c},
+	{0x3721, 0x00},
+	{0x3724, 0x10},
+	{0x3726, 0x00},
+	{0x372a, 0x01},
+	{0x3730, 0x10},
+	{0x3738, 0x22},
+	{0x3739, 0xe5},
+	{0x373a, 0x50},
+	{0x373b, 0x02},
+	{0x373c, 0x41},
+	{0x373f, 0x02},
+	{0x3740, 0x42},
+	{0x3741, 0x02},
+	{0x3742, 0x18},
+	{0x3743, 0x01},
+	{0x3744, 0x02},
+	{0x3747, 0x10},
+	{0x374c, 0x04},
+	{0x3751, 0xf0},
+	{0x3752, 0x00},
+	{0x3753, 0x00},
+	{0x3754, 0xc0},
+	{0x3755, 0x00},
+	{0x3756, 0x1a},
+	{0x3758, 0x00},
+	{0x3759, 0x0f},
+	{0x376b, 0x44},
+	{0x375c, 0x04},
+	{0x3774, 0x10},
+	{0x3776, 0x00},
+	{0x377f, 0x08},
+	{0x3780, 0x22},
+	{0x3781, 0x0c},
+	{0x3784, 0x2c},
+	{0x3785, 0x1e},
+	{0x378f, 0xf5},
+	{0x3791, 0xb0},
+	{0x3795, 0x00},
+	{0x3796, 0x64},
+	{0x3797, 0x11},
+	{0x3798, 0x30},
+	{0x3799, 0x41},
+	{0x379a, 0x07},
+	{0x379b, 0xb0},
+	{0x379c, 0x0c},
+	{0x37c5, 0x00},
+	{0x37c6, 0x00},
+	{0x37c7, 0x00},
+	{0x37c9, 0x00},
+	{0x37ca, 0x00},
+	{0x37cb, 0x00},
+	{0x37de, 0x00},
+	{0x37df, 0x00},
+	{0x3800, 0x02},
+	{0x3801, 0xa8},
+	{0x3802, 0x02},
+	{0x3803, 0x68},
+	{0x3804, 0x07},
+	{0x3805, 0xb7},
+	{0x3806, 0x05},
+	{0x3807, 0x3b},
+	{0x3808, 0x05},
+	{0x3809, 0x00},
+	{0x380a, 0x02},
+	{0x380b, 0xd0},
+	{0x380c, 0x0b},
+	{0x380d, 0x40},
+	{0x380e, 0x03},
+	{0x380f, 0x9e},
+	{0x3810, 0x00},
+	{0x3811, 0x02},
+	{0x3812, 0x00},
+	{0x3813, 0x02},
+	{0x3814, 0x11},
+	{0x3815, 0x11},
+	{0x3820, 0x02},
+	{0x3821, 0x9e},
+	{0x3823, 0x00},
+	{0x3824, 0x00},
+	{0x3825, 0x00},
+	{0x3826, 0x00},
+	{0x3827, 0x00},
+	{0x382a, 0x04},
+	{0x3a04, 0x09},
+	{0x3a05, 0xa9},
+	{0x3a06, 0x00},
+	{0x3a07, 0xfe},
+	{0x3b00, 0x00},
+	{0x3b02, 0x00},
+	{0x3b03, 0x00},
+	{0x3b04, 0x00},
+	{0x3b05, 0x00},
+	{0x3e07, 0x20},
+	{0x4000, 0x08},
+	{0x4001, 0x04},
+	{0x4002, 0x45},
+	{0x4004, 0x08},
+	{0x4005, 0x18},
+	{0x4006, 0x20},
+	{0x4008, 0x24},
+	{0x4009, 0x10},
+	{0x400c, 0x00},
+	{0x400d, 0x00},
+	{0x4058, 0x00},
+	{0x404e, 0x37},
+	{0x404f, 0x8f},
+	{0x4058, 0x00},
+	{0x4101, 0xb2},
+	{0x4303, 0x00},
+	{0x4304, 0x08},
+	{0x4307, 0x30},
+	{0x4311, 0x04},
+	{0x4315, 0x01},
+	{0x4511, 0x05},
+	{0x4512, 0x01},
+	{0x4800, 0x20}, /* dis-continuous */
+	{0x4806, 0x00},
+	{0x4816, 0x52},
+	{0x481f, 0x30},
+	{0x4826, 0x32},
+	{0x4831, 0x6a},
+	{0x4d00, 0x04},
+	{0x4d01, 0x71},
+	{0x4d02, 0xfd},
+	{0x4d03, 0xf5},
+	{0x4d04, 0x0c},
+	{0x4d05, 0xcc},
+	{0x4837, 0x0a},
+	{0x5000, 0x06},
+	{0x5001, 0x01},
+	{0x5002, 0x00},
+	{0x5003, 0x20},
+	{0x5046, 0x0a},
+	{0x5013, 0x00},
+	{0x5046, 0x0a},
+	{0x5780, 0x1c},
+	{0x5786, 0x20},
+	{0x5787, 0x10},
+	{0x5788, 0x18},
+	{0x578a, 0x04},
+	{0x578b, 0x02},
+	{0x578c, 0x02},
+	{0x578e, 0x06},
+	{0x578f, 0x02},
+	{0x5790, 0x02},
+	{0x5791, 0xff},
+	{0x5842, 0x01},
+	{0x5843, 0x2b},
+	{0x5844, 0x01},
+	{0x5845, 0x92},
+	{0x5846, 0x01},
+	{0x5847, 0x8f},
+	{0x5848, 0x01},
+	{0x5849, 0x0c},
+	{0x5e00, 0x00},
+	{0x5e10, 0x0c},
+	{OV5670_TABLE_END, 0x0000}
+};
+
+static const ov5670_reg mode_2592x1944_one_lane_15fps[] = {
+	{0x0100, 0x00},/* Including sw reset */
+	{0x0103, 0x01},
+	{0x3001, 0x0a},
+	{0x3002, 0x80},
+	{0x3006, 0x00},
+	{0x3011, 0x11},
+	{0x3012, 0x09},
+	{0x3013, 0x10},
+	{0x3014, 0x00},
+	{0x3015, 0x28},
+	{0x3016, 0xf0},
+	{0x3017, 0xf0},
+	{0x3018, 0xf0},
+	{0x301b, 0xb4},
+	{0x301d, 0x02},
+	{0x3021, 0x00},
+	{0x3022, 0x01},
+	{0x3028, 0x44},
+	{0x3098, 0x03},
+	{0x3099, 0x1e},
+	{0x309a, 0x05},
+	{0x309b, 0x01},
+	{0x309c, 0x00},
+	{0x30a0, 0xd2},
+	{0x30a2, 0x01},
+	{0x30b2, 0x00},
+	{0x30b3, 0x64},
+	{0x30b4, 0x03},
+	{0x30b5, 0x04},
+	{0x30b6, 0x01},
+	{0x3104, 0x21},
+	{0x3106, 0x00},
+	{0x3400, 0x04},
+	{0x3401, 0x00},
+	{0x3402, 0x04},
+	{0x3403, 0x00},
+	{0x3404, 0x04},
+	{0x3405, 0x00},
+	{0x3406, 0x01},
+	{0x3500, 0x00},
+	{0x3501, 0x7b},
+	{0x3502, 0x00},
+	{0x3503, 0x07},
+	{0x3504, 0x00},
+	{0x3505, 0x00},
+	{0x3506, 0x00},
+	{0x3507, 0x02},
+	{0x3508, 0x00},
+	{0x3509, 0x10},
+	{0x350a, 0x00},
+	{0x350b, 0x20},
+	{0x3600, 0xbc},
+	{0x3601, 0x0a},
+	{0x3602, 0x38},
+	{0x3612, 0x80},
+	{0x3620, 0x44},
+	{0x3621, 0xb5},
+	{0x3622, 0x0c},
+	{0x3625, 0x10},
+	{0x3630, 0x55},
+	{0x3631, 0xf4},
+	{0x3632, 0x00},
+	{0x3633, 0x34},
+	{0x3634, 0x02},
+	{0x364d, 0x0d},
+	{0x364f, 0xdd},
+	{0x3660, 0x04},
+	{0x3662, 0x10},
+	{0x3663, 0xf1},
+	{0x3665, 0x00},
+	{0x3666, 0x20},
+	{0x3667, 0x00},
+	{0x366a, 0x80},
+	{0x3680, 0xe0},
+	{0x3681, 0x00},
+	{0x3700, 0x42},
+	{0x3701, 0x14},
+	{0x3702, 0xa0},
+	{0x3703, 0xd8},
+	{0x3704, 0x78},
+	{0x3705, 0x02},
+	{0x3708, 0xe2},
+	{0x3709, 0xc3},
+	{0x370a, 0x00},
+	{0x370b, 0x20},
+	{0x370c, 0x0c},
+	{0x370d, 0x11},
+	{0x370e, 0x00},
+	{0x370f, 0x40},
+	{0x3710, 0x00},
+	{0x371a, 0x1c},
+	{0x371b, 0x05},
+	{0x371c, 0x01},
+	{0x371e, 0xa1},
+	{0x371f, 0x0c},
+	{0x3721, 0x00},
+	{0x3724, 0x10},
+	{0x3726, 0x00},
+	{0x372a, 0x01},
+	{0x3730, 0x10},
+	{0x3738, 0x22},
+	{0x3739, 0xe5},
+	{0x373a, 0x50},
+	{0x373b, 0x02},
+	{0x373c, 0x41},
+	{0x373f, 0x02},
+	{0x3740, 0x42},
+	{0x3741, 0x02},
+	{0x3742, 0x18},
+	{0x3743, 0x01},
+	{0x3744, 0x02},
+	{0x3747, 0x10},
+	{0x374c, 0x04},
+	{0x3751, 0xf0},
+	{0x3752, 0x00},
+	{0x3753, 0x00},
+	{0x3754, 0xc0},
+	{0x3755, 0x00},
+	{0x3756, 0x1a},
+	{0x3758, 0x00},
+	{0x3759, 0x0f},
+	{0x376b, 0x44},
+	{0x375c, 0x04},
+	{0x3774, 0x10},
+	{0x3776, 0x00},
+	{0x377f, 0x08},
+	{0x3780, 0x22},
+	{0x3781, 0x0c},
+	{0x3784, 0x2c},
+	{0x3785, 0x1e},
+	{0x378f, 0xf5},
+	{0x3791, 0xb0},
+	{0x3795, 0x00},
+	{0x3796, 0x64},
+	{0x3797, 0x11},
+	{0x3798, 0x30},
+	{0x3799, 0x41},
+	{0x379a, 0x07},
+	{0x379b, 0xb0},
+	{0x379c, 0x0c},
+	{0x37c5, 0x00},
+	{0x37c6, 0x00},
+	{0x37c7, 0x00},
+	{0x37c9, 0x00},
+	{0x37ca, 0x00},
+	{0x37cb, 0x00},
+	{0x37de, 0x00},
+	{0x37df, 0x00},
+	{0x3800, 0x00},
+	{0x3801, 0x00},
+	{0x3802, 0x00},
+	{0x3803, 0x00},
+	{0x3804, 0x0a},
+	{0x3805, 0x3f},
+	{0x3806, 0x07},
+	{0x3807, 0xa3},
+	{0x3808, 0x0a},
+	{0x3809, 0x20},
+	{0x380a, 0x07},
+	{0x380b, 0x98},
+	{0x380c, 0x0a},
+	{0x380d, 0x80},
+	{0x380e, 0x07},
+	{0x380f, 0xc0},
+	{0x3810, 0x00},
+	{0x3811, 0x02},
+	{0x3812, 0x00},
+	{0x3813, 0x02},
+	{0x3814, 0x11},
+	{0x3815, 0x11},
+	{0x3820, 0x02},
+	{0x3821, 0x1e},
+	{0x3823, 0x00},
+	{0x3824, 0x00},
+	{0x3825, 0x00},
+	{0x3826, 0x00},
+	{0x3827, 0x00},
+	{0x382a, 0x04},
+	{0x3a04, 0x06},
+	{0x3a05, 0x14},
+	{0x3a06, 0x00},
+	{0x3a07, 0xfe},
+	{0x3b00, 0x00},
+	{0x3b02, 0x00},
+	{0x3b03, 0x00},
+	{0x3b04, 0x00},
+	{0x3b05, 0x00},
+	{0x3e07, 0x20},
+	{0x4000, 0x08},
+	{0x4001, 0x04},
+	{0x4002, 0x45},
+	{0x4004, 0x08},
+	{0x4005, 0x18},
+	{0x4006, 0x20},
+	{0x4008, 0x24},
+	{0x4009, 0x10},
+	{0x400c, 0x00},
+	{0x400d, 0x00},
+	{0x4058, 0x00},
+	{0x404e, 0x37},
+	{0x404f, 0x8f},
+	{0x4058, 0x00},
+	{0x4101, 0xb2},
+	{0x4303, 0x00},
+	{0x4304, 0x08},
+	{0x4307, 0x30},
+	{0x4311, 0x04},
+	{0x4315, 0x01},
+	{0x4511, 0x05},
+	{0x4512, 0x01},
+	{0x4806, 0x00},
+	{0x4816, 0x52},
+	{0x481f, 0x30},
+	{0x4826, 0x2c},
+	{0x4831, 0x64},
+	{0x4d00, 0x04},
+	{0x4d01, 0x71},
+	{0x4d02, 0xfd},
+	{0x4d03, 0xf5},
+	{0x4d04, 0x0c},
+	{0x4d05, 0xcc},
+	{0x4837, 0x0a},
+	{0x5000, 0x06},
+	{0x5001, 0x01},
+	{0x5002, 0x00},
+	{0x5003, 0x20},
+	{0x5046, 0x0a},
+	{0x5013, 0x00},
+	{0x5046, 0x0a},
+	{0x5780, 0xfc},
+	{0x5781, 0x13},
+	{0x5782, 0x03},
+	{0x5786, 0x20},
+	{0x5787, 0x40},
+	{0x5788, 0x08},
+	{0x5789, 0x08},
+	{0x578a, 0x02},
+	{0x578b, 0x01},
+	{0x578c, 0x01},
+	{0x578d, 0x0c},
+	{0x578e, 0x02},
+	{0x578f, 0x01},
+	{0x5790, 0x01},
+	{0x5791, 0xff},
+	{0x5842, 0x01},
+	{0x5843, 0x2b},
+	{0x5844, 0x01},
+	{0x5845, 0x92},
+	{0x5846, 0x01},
+	{0x5847, 0x8f},
+	{0x5848, 0x01},
+	{0x5849, 0x0c},
+	{0x5e00, 0x00},
+	{0x5e10, 0x0c},
+	{0x0100, 0x01},
+	{0x3810, 0x00},
+	{0x3811, 0x10},
+	{0x3812, 0x00},
+	{0x3813, 0x06},
+	{OV5670_TABLE_END, 0x0000}
+};
+
+enum {
+	OV5670_MODE_2592X1944,
+	OV5670_MODE_2560X1440,
+	OV5670_MODE_1920X1080,
+
+	OV5670_MODE_START_STREAM,
+	OV5670_MODE_STOP_STREAM,
+	OV5670_MODE_TEST_PATTERN
+};
+
+static const ov5670_reg *mode_table[] = {
+	[OV5670_MODE_2592X1944]			= mode_2592x1944_regs,
+	[OV5670_MODE_2560X1440]			= mode_2560x1440_regs,
+	[OV5670_MODE_1920X1080]			= mode_1920x1080_regs,
+
+	[OV5670_MODE_START_STREAM]		= ov5670_start,
+	[OV5670_MODE_STOP_STREAM]		= ov5670_stop,
+	[OV5670_MODE_TEST_PATTERN]		= tp_colorbars,
+};
+
+static const int ov5670_15fps[] = {
+	15,
+};
+
+static const int ov5670_24fps[] = {
+	24,
+};
+
+static const int ov5670_30fps[] = {
+	30,
+};
+
+static const int ov5670_60fps[] = {
+	60,
+};
+
+static const int ov5670_120fps[] = {
+	120,
+};
+
+static const struct camera_common_frmfmt ov5670_frmfmt[] = {
+	{{2592, 1944},	ov5670_30fps,	1, 0,	OV5670_MODE_2592X1944},
+	{{2560, 1440},	ov5670_30fps,	1, 0,	OV5670_MODE_2560X1440},
+	{{1920, 1080},	ov5670_60fps,	1, 0,	OV5670_MODE_1920X1080},
+};
+#endif  /* __OV5670_TABLES__ */
+
diff --git a/nvidia/drivers/media/platform/tegra/camera/camera_common.c b/nvidia/drivers/media/platform/tegra/camera/camera_common.c
index dd2780f06f9e..2bee53a97b03 100644
--- a/nvidia/drivers/media/platform/tegra/camera/camera_common.c
+++ b/nvidia/drivers/media/platform/tegra/camera/camera_common.c
@@ -61,6 +61,11 @@ static const struct camera_common_colorfmt camera_common_color_fmts[] = {
 		V4L2_COLORSPACE_SRGB,
 		V4L2_PIX_FMT_SGRBG10,
 	},
+	{
+		MEDIA_BUS_FMT_SGBRG10_1X10,
+		V4L2_COLORSPACE_SRGB,
+		V4L2_PIX_FMT_SGBRG10,
+	},
 	{
 		MEDIA_BUS_FMT_SBGGR10_1X10,
 		V4L2_COLORSPACE_SRGB,
diff --git a/nvidia/drivers/media/platform/tegra/camera/sensor_common.c b/nvidia/drivers/media/platform/tegra/camera/sensor_common.c
index 75a3af2280f7..39813ade9744 100644
--- a/nvidia/drivers/media/platform/tegra/camera/sensor_common.c
+++ b/nvidia/drivers/media/platform/tegra/camera/sensor_common.c
@@ -202,6 +202,8 @@ static int extract_pixel_format(
 		*format = V4L2_PIX_FMT_SRGGB10;
 	else if (strncmp(pixel_t, "bayer_grbg10", size) == 0)
 		*format = V4L2_PIX_FMT_SGRBG10;
+	else if (strncmp(pixel_t, "bayer_gbrg10", size) == 0)
+		*format = V4L2_PIX_FMT_SGBRG10;
 	else if (strncmp(pixel_t, "bayer_bggr12", size) == 0)
 		*format = V4L2_PIX_FMT_SBGGR12;
 	else if (strncmp(pixel_t, "bayer_rggb12", size) == 0)
diff --git a/nvidia/include/media/imx214.h b/nvidia/include/media/imx214.h
new file mode 100644
index 000000000000..dcbf136f0473
--- /dev/null
+++ b/nvidia/include/media/imx214.h
@@ -0,0 +1,91 @@
+/*
+ * Copyright (c) 2013-2019, NVIDIA CORPORATION.  All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#ifndef __IMX214_H__
+#define __IMX214_H__
+
+#include <media/nvc.h>
+#include <uapi/media/nvc_image.h>
+#include <uapi/media/imx214.h>
+
+#define IMX214_INVALID_COARSE_TIME  -1
+
+#define IMX214_EEPROM_ADDRESS		0x50
+#define IMX214_EEPROM_SIZE		1024
+#define IMX214_EEPROM_STR_SIZE		(IMX214_EEPROM_SIZE * 2)
+#define IMX214_EEPROM_BLOCK_SIZE	(1 << 8)
+#define IMX214_EEPROM_NUM_BLOCKS \
+	(IMX214_EEPROM_SIZE / IMX214_EEPROM_BLOCK_SIZE)
+
+#define IMX214_OTP_LOAD_CTRL_ADDR	0x0A00
+#define IMX214_OTP_BANK_SELECT_ADDR	0x0A02
+#define IMX214_OTP_BANK_START_ADDR	0x0A04
+#define IMX214_OTP_BANK_END_ADDR	0x0A43
+#define IMX214_OTP_NUM_BANKS		(15)
+#define IMX214_OTP_BANK_SIZE \
+	 (IMX214_OTP_BANK_END_ADDR - IMX214_OTP_BANK_START_ADDR + 1)
+#define IMX214_OTP_SIZE \
+	 (IMX214_OTP_BANK_SIZE * IMX214_OTP_NUM_BANKS)
+#define IMX214_OTP_STR_SIZE (IMX214_OTP_SIZE * 2)
+
+#define IMX214_FUSE_ID_OTP_START_ADDR	0x3D00
+#define IMX214_FUSE_ID_OTP_BANK	0
+#define IMX214_FUSE_ID_SIZE		8
+#define IMX214_FUSE_ID_STR_SIZE	(IMX214_FUSE_ID_SIZE * 2)
+/* See notes in the nvc.h file on the GPIO usage */
+enum imx214_gpio_type {
+	IMX214_GPIO_TYPE_PWRDN = 0,
+	IMX214_GPIO_TYPE_RESET,
+};
+
+struct imx214_eeprom_data {
+	struct i2c_client *i2c_client;
+	struct i2c_adapter *adap;
+	struct i2c_board_info brd;
+	struct regmap *regmap;
+};
+
+struct imx214_power_rail {
+	struct regulator *dvdd;
+	struct regulator *avdd;
+	struct regulator *dovdd;
+};
+
+struct imx214_regulators {
+	const char *avdd;
+	const char *dvdd;
+	const char *dovdd;
+};
+
+struct imx214_platform_data {
+	unsigned cfg;
+	unsigned num;
+	const char *dev_name;
+	unsigned gpio_count; /* see nvc.h GPIO notes */
+	struct nvc_gpio_pdata *gpio; /* see nvc.h GPIO notes */
+	struct nvc_imager_static_nvc *static_info;
+	bool use_vcm_vdd;
+	int (*probe_clock)(unsigned long);
+	int (*power_on)(struct imx214_power_rail *);
+	int (*power_off)(struct imx214_power_rail *);
+	const char *mclk_name;
+	struct nvc_imager_cap *cap;
+	struct imx214_regulators regulators;
+	bool has_eeprom;
+	bool use_cam_gpio;
+};
+
+#endif  /* __IMX214_H__ */
diff --git a/nvidia/include/media/ov5640.h b/nvidia/include/media/ov5640.h
new file mode 100644
index 000000000000..a94464ef21da
--- /dev/null
+++ b/nvidia/include/media/ov5640.h
@@ -0,0 +1,87 @@
+/*
+ * Copyright (c) 2013-2019, NVIDIA CORPORATION.  All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#ifndef __OV5640_H__
+#define __OV5640_H__
+
+#include <media/nvc.h>
+#include <uapi/media/nvc_image.h>
+#include <uapi/media/ov5640.h>
+
+#define OV5640_INVALID_COARSE_TIME  -1
+
+#define OV5640_EEPROM_ADDRESS		0x50
+#define OV5640_EEPROM_SIZE		1024
+#define OV5640_EEPROM_STR_SIZE		(OV5640_EEPROM_SIZE * 2)
+#define OV5640_EEPROM_BLOCK_SIZE	(1 << 8)
+#define OV5640_EEPROM_NUM_BLOCKS \
+	(OV5640_EEPROM_SIZE / OV5640_EEPROM_BLOCK_SIZE)
+
+#define OV5640_OTP_LOAD_CTRL_ADDR	0x3D81
+#define OV5640_OTP_BANK_SELECT_ADDR	0x3D84
+#define OV5640_OTP_BANK_START_ADDR	0x3D00
+#define OV5640_OTP_BANK_END_ADDR	0x3D0F
+#define OV5640_OTP_NUM_BANKS		(32)
+#define OV5640_OTP_BANK_SIZE \
+	 (OV5640_OTP_BANK_END_ADDR - OV5640_OTP_BANK_START_ADDR + 1)
+#define OV5640_OTP_SIZE \
+	 (OV5640_OTP_BANK_SIZE * OV5640_OTP_NUM_BANKS)
+#define OV5640_OTP_STR_SIZE (OV5640_OTP_SIZE * 2)
+
+/* See notes in the nvc.h file on the GPIO usage */
+enum ov5640_gpio_type {
+	OV5640_GPIO_TYPE_PWRDN = 0,
+	OV5640_GPIO_TYPE_RESET,
+};
+
+struct ov5640_eeprom_data {
+	struct i2c_client *i2c_client;
+	struct i2c_adapter *adap;
+	struct i2c_board_info brd;
+	struct regmap *regmap;
+};
+
+struct ov5640_power_rail {
+	struct regulator *dvdd;
+	struct regulator *avdd;
+	struct regulator *dovdd;
+};
+
+struct ov5640_regulators {
+	const char *avdd;
+	const char *dvdd;
+	const char *dovdd;
+};
+
+struct ov5640_platform_data {
+	unsigned cfg;
+	unsigned num;
+	const char *dev_name;
+	unsigned gpio_count; /* see nvc.h GPIO notes */
+	struct nvc_gpio_pdata *gpio; /* see nvc.h GPIO notes */
+	struct nvc_imager_static_nvc *static_info;
+	bool use_vcm_vdd;
+	int (*probe_clock)(unsigned long);
+	int (*power_on)(struct ov5640_power_rail *);
+	int (*power_off)(struct ov5640_power_rail *);
+	const char *mclk_name;
+	struct nvc_imager_cap *cap;
+	struct ov5640_regulators regulators;
+	bool has_eeprom;
+	bool use_cam_gpio;
+};
+
+#endif  /* __OV5640_H__ */
\ No newline at end of file
diff --git a/nvidia/include/media/ov56400.h b/nvidia/include/media/ov56400.h
new file mode 100644
index 000000000000..a94464ef21da
--- /dev/null
+++ b/nvidia/include/media/ov56400.h
@@ -0,0 +1,87 @@
+/*
+ * Copyright (c) 2013-2019, NVIDIA CORPORATION.  All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#ifndef __OV5640_H__
+#define __OV5640_H__
+
+#include <media/nvc.h>
+#include <uapi/media/nvc_image.h>
+#include <uapi/media/ov5640.h>
+
+#define OV5640_INVALID_COARSE_TIME  -1
+
+#define OV5640_EEPROM_ADDRESS		0x50
+#define OV5640_EEPROM_SIZE		1024
+#define OV5640_EEPROM_STR_SIZE		(OV5640_EEPROM_SIZE * 2)
+#define OV5640_EEPROM_BLOCK_SIZE	(1 << 8)
+#define OV5640_EEPROM_NUM_BLOCKS \
+	(OV5640_EEPROM_SIZE / OV5640_EEPROM_BLOCK_SIZE)
+
+#define OV5640_OTP_LOAD_CTRL_ADDR	0x3D81
+#define OV5640_OTP_BANK_SELECT_ADDR	0x3D84
+#define OV5640_OTP_BANK_START_ADDR	0x3D00
+#define OV5640_OTP_BANK_END_ADDR	0x3D0F
+#define OV5640_OTP_NUM_BANKS		(32)
+#define OV5640_OTP_BANK_SIZE \
+	 (OV5640_OTP_BANK_END_ADDR - OV5640_OTP_BANK_START_ADDR + 1)
+#define OV5640_OTP_SIZE \
+	 (OV5640_OTP_BANK_SIZE * OV5640_OTP_NUM_BANKS)
+#define OV5640_OTP_STR_SIZE (OV5640_OTP_SIZE * 2)
+
+/* See notes in the nvc.h file on the GPIO usage */
+enum ov5640_gpio_type {
+	OV5640_GPIO_TYPE_PWRDN = 0,
+	OV5640_GPIO_TYPE_RESET,
+};
+
+struct ov5640_eeprom_data {
+	struct i2c_client *i2c_client;
+	struct i2c_adapter *adap;
+	struct i2c_board_info brd;
+	struct regmap *regmap;
+};
+
+struct ov5640_power_rail {
+	struct regulator *dvdd;
+	struct regulator *avdd;
+	struct regulator *dovdd;
+};
+
+struct ov5640_regulators {
+	const char *avdd;
+	const char *dvdd;
+	const char *dovdd;
+};
+
+struct ov5640_platform_data {
+	unsigned cfg;
+	unsigned num;
+	const char *dev_name;
+	unsigned gpio_count; /* see nvc.h GPIO notes */
+	struct nvc_gpio_pdata *gpio; /* see nvc.h GPIO notes */
+	struct nvc_imager_static_nvc *static_info;
+	bool use_vcm_vdd;
+	int (*probe_clock)(unsigned long);
+	int (*power_on)(struct ov5640_power_rail *);
+	int (*power_off)(struct ov5640_power_rail *);
+	const char *mclk_name;
+	struct nvc_imager_cap *cap;
+	struct ov5640_regulators regulators;
+	bool has_eeprom;
+	bool use_cam_gpio;
+};
+
+#endif  /* __OV5640_H__ */
\ No newline at end of file
diff --git a/nvidia/include/media/ov5670.h b/nvidia/include/media/ov5670.h
new file mode 100644
index 000000000000..566b972cd18b
--- /dev/null
+++ b/nvidia/include/media/ov5670.h
@@ -0,0 +1,90 @@
+/*
+ * Copyright (c) 2013-2019, NVIDIA CORPORATION.  All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+
+ #ifndef __OV5670_H__
+ #define __OV5670_H__
+
+
+ #include <media/nvc.h>
+ #include <uapi/media/nvc_image.h>
+ #include <uapi/media/ov5670.h>
+
+ #define OV5670_INVALID_COARSE_TIME  -1
+
+ #define OV5670_EEPROM_ADDRESS		0x50
+ #define OV5670_EEPROM_SIZE		1024
+ #define OV5670_EEPROM_STR_SIZE		(OV5670_EEPROM_SIZE * 2)
+ #define OV5670_EEPROM_BLOCK_SIZE	(1 << 8)
+ #define OV5670_EEPROM_NUM_BLOCKS \
+ 	(OV5670_EEPROM_SIZE / OV5670_EEPROM_BLOCK_SIZE)
+
+ #define OV5670_OTP_LOAD_CTRL_ADDR	0x3D81
+ #define OV5670_OTP_LOAD_CTRL_ADDR_START	0x3D88
+ #define OV5670_OTP_LOAD_CTRL_ADDR_END	0x3D8A
+ #define OV5670_OTP_BANK_SELECT_ADDR	0x3D84
+ #define OV5670_OTP_BANK_START_ADDR	0x7010
+ #define OV5670_OTP_BANK_END_ADDR	0x7063
+ #define OV5670_OTP_NUM_BANKS		(1)
+ #define OV5670_OTP_BANK_SIZE (OV5670_OTP_BANK_END_ADDR - OV5670_OTP_BANK_START_ADDR + 1)
+ #define OV5670_OTP_SIZE	 (OV5670_OTP_BANK_END_ADDR - OV5670_OTP_BANK_START_ADDR + 1)
+ #define OV5670_OTP_STR_SIZE (OV5670_OTP_SIZE * 2)
+
+/* See notes in the nvc.h file on the GPIO usage */
+enum ov5670_gpio_type {
+ 	OV5670_GPIO_TYPE_PWRDN = 0,
+ 	OV5670_GPIO_TYPE_RESET,
+ };
+
+
+ struct ov5670_eeprom_data {
+ 	struct i2c_client *i2c_client;
+ 	struct i2c_adapter *adap;
+ 	struct i2c_board_info brd;
+ 	struct regmap *regmap;
+ };
+
+ struct ov5670_power_rail {
+ 	struct regulator *dvdd;
+ 	struct regulator *avdd;
+ 	struct regulator *dovdd;
+ };
+
+ struct ov5670_regulators {
+ 	const char *avdd;
+ 	const char *dvdd;
+ 	const char *dovdd;
+ };
+
+ struct ov5670_platform_data {
+ 	unsigned cfg;
+ 	unsigned num;
+ 	const char *dev_name;
+ 	unsigned gpio_count; /* see nvc.h GPIO notes */
+ 	struct nvc_gpio_pdata *gpio; /* see nvc.h GPIO notes */
+ 	struct nvc_imager_static_nvc *static_info;
+ 	bool use_vcm_vdd;
+ 	int (*probe_clock)(unsigned long);
+ 	int (*power_on)(struct ov5670_power_rail *);
+ 	int (*power_off)(struct ov5670_power_rail *);
+ 	const char *mclk_name;
+ 	struct nvc_imager_cap *cap;
+ 	struct ov5670_regulators regulators;
+ 	bool has_eeprom;
+ 	bool use_cam_gpio;
+ };
+
+ #endif  /* __OV5670_H__ */
diff --git a/nvidia/include/trace/events/imx214.h b/nvidia/include/trace/events/imx214.h
new file mode 100644
index 000000000000..5c38e4c415e9
--- /dev/null
+++ b/nvidia/include/trace/events/imx214.h
@@ -0,0 +1,45 @@
+/*
+ * imx214.h
+ *
+ * Copyright (c) 2017, NVIDIA CORPORATION, All rights reserved.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+#undef TRACE_SYSTEM
+#define TRACE_SYSTEM imx214
+
+#if !defined(_TRACE_IMX214_H) || defined(TRACE_HEADER_MULTI_READ)
+#define _TRACE_IMX214_H
+
+#include <linux/tracepoint.h>
+
+TRACE_EVENT(imx214_s_stream,
+	TP_PROTO(const char *name, int enable, int mode),
+	TP_ARGS(name, enable, mode),
+	TP_STRUCT__entry(
+		__string(name,	name)
+		__field(int,	enable)
+		__field(int,	mode)
+	),
+	TP_fast_assign(
+		__assign_str(name, name);
+		__entry->enable = enable;
+		__entry->mode = mode;
+	),
+	TP_printk("%s: on %d mode %d", __get_str(name),
+		  __entry->enable, __entry->mode)
+);
+
+
+#endif
+
+/* This part must be outside protection */
+#include <trace/define_trace.h>
diff --git a/nvidia/include/trace/events/ov5640.h b/nvidia/include/trace/events/ov5640.h
new file mode 100644
index 000000000000..06a254dcf880
--- /dev/null
+++ b/nvidia/include/trace/events/ov5640.h
@@ -0,0 +1,45 @@
+/*
+ * ov5640.h
+ *
+ * Copyright (c) 2017, NVIDIA CORPORATION, All rights reserved.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+#undef TRACE_SYSTEM
+#define TRACE_SYSTEM ov5640
+
+#if !defined(_TRACE_OV5640_H) || defined(TRACE_HEADER_MULTI_READ)
+#define _TRACE_OV5640_H
+
+#include <linux/tracepoint.h>
+
+TRACE_EVENT(ov5640_s_stream,
+	TP_PROTO(const char *name, int enable, int mode),
+	TP_ARGS(name, enable, mode),
+	TP_STRUCT__entry(
+		__string(name,	name)
+		__field(int,	enable)
+		__field(int,	mode)
+	),
+	TP_fast_assign(
+		__assign_str(name, name);
+		__entry->enable = enable;
+		__entry->mode = mode;
+	),
+	TP_printk("%s: on %d mode %d", __get_str(name),
+		  __entry->enable, __entry->mode)
+);
+
+
+#endif
+
+/* This part must be outside protection */
+#include <trace/define_trace.h>
diff --git a/nvidia/include/trace/events/ov5670.h b/nvidia/include/trace/events/ov5670.h
new file mode 100644
index 000000000000..48e177bed50e
--- /dev/null
+++ b/nvidia/include/trace/events/ov5670.h
@@ -0,0 +1,45 @@
+/*
+ * ov5670.h
+ *
+ * Copyright (c) 2017, NVIDIA CORPORATION, All rights reserved.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+#undef TRACE_SYSTEM
+#define TRACE_SYSTEM ov5670
+
+#if !defined(_TRACE_OV5670_H) || defined(TRACE_HEADER_MULTI_READ)
+#define _TRACE_OV5670_H
+
+#include <linux/tracepoint.h>
+
+TRACE_EVENT(ov5670_s_stream,
+	TP_PROTO(const char *name, int enable, int mode),
+	TP_ARGS(name, enable, mode),
+	TP_STRUCT__entry(
+		__string(name,	name)
+		__field(int,	enable)
+		__field(int,	mode)
+	),
+	TP_fast_assign(
+		__assign_str(name, name);
+		__entry->enable = enable;
+		__entry->mode = mode;
+	),
+	TP_printk("%s: on %d mode %d", __get_str(name),
+		  __entry->enable, __entry->mode)
+);
+
+
+#endif
+
+/* This part must be outside protection */
+#include <trace/define_trace.h>
diff --git a/nvidia/include/uapi/media/imx214.h b/nvidia/include/uapi/media/imx214.h
new file mode 100644
index 000000000000..7dfedbd62d4a
--- /dev/null
+++ b/nvidia/include/uapi/media/imx214.h
@@ -0,0 +1,108 @@
+/*
+ * Copyright (c) 2013-2019, NVIDIA CORPORATION.  All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#ifndef __UAPI_IMX214_H__
+#define __UAPI_IMX214_H__
+
+#include <uapi/media/nvc.h>
+#include <uapi/media/nvc_image.h>
+
+#define IMX214_IOCTL_SET_MODE               _IOW('o', 1, struct imx214_mode)
+#define IMX214_IOCTL_SET_FRAME_LENGTH       _IOW('o', 2, __u32)
+#define IMX214_IOCTL_SET_COARSE_TIME        _IOW('o', 3, __u32)
+#define IMX214_IOCTL_SET_GAIN               _IOW('o', 4, __u16)
+#define IMX214_IOCTL_GET_STATUS             _IOR('o', 5, __u8)
+#define IMX214_IOCTL_SET_BINNING            _IOW('o', 6, __u8)
+#define IMX214_IOCTL_TEST_PATTERN           _IOW('o', 7, \
+						 enum imx214_test_pattern)
+#define IMX214_IOCTL_SET_GROUP_HOLD         _IOW('o', 8, struct imx214_ae)
+/* IOCTL to set the operating mode of camera.
+ * This can be either stereo , leftOnly or rightOnly */
+#define IMX214_IOCTL_SET_CAMERA_MODE        _IOW('o', 10, __u32)
+#define IMX214_IOCTL_SYNC_SENSORS           _IOW('o', 11, __u32)
+#define IMX214_IOCTL_GET_FUSEID             _IOR('o', 12, struct nvc_fuseid)
+#define IMX214_IOCTL_SET_HDR_COARSE_TIME    _IOW('o', 13, struct imx214_hdr)
+#define IMX214_IOCTL_READ_OTP_BANK          _IOWR('o', 14, \
+						struct imx214_otp_bank)
+#define IMX214_IOCTL_SET_CAL_DATA           _IOW('o', 15, \
+						struct imx214_cal_data)
+#define IMX214_IOCTL_GET_EEPROM_DATA        _IOR('o', 20, __u8 *)
+#define IMX214_IOCTL_SET_EEPROM_DATA        _IOW('o', 21, __u8 *)
+#define IMX214_IOCTL_GET_CAPS               _IOR('o', 22, struct nvc_imager_cap)
+#define IMX214_IOCTL_SET_POWER              _IOW('o', 23, __u32)
+
+
+#define IMX214_FRAME_LENGTH_ADDR_MSB		0x0340
+#define IMX214_FRAME_LENGTH_ADDR_LSB		0x0341
+#define IMX214_COARSE_TIME_ADDR_1		0x0202
+#define IMX214_COARSE_TIME_ADDR_2		0x0203
+
+#define IMX214_COARSE_TIME_SHORT_ADDR_1	0x0200
+#define IMX214_COARSE_TIME_SHORT_ADDR_2	0x0201
+#define IMX214_GAIN_ADDR_MSB			0x0204
+#define IMX214_GAIN_ADDR_LSB			0x0205
+#define IMX214_GROUP_HOLD_ADDR			0x0104
+#define IMX214_TIMING_REG20			0x0101
+#define VERTICAL_FLIP				(0x1 << 1)
+#define IMX214_TIMING_REG21			0x0101
+#define HORIZONTAL_MIRROR_MASK			(0x1)
+
+struct imx214_mode {
+	int res_x;
+	int res_y;
+	int fps;
+	__u32 frame_length;
+	__u32 coarse_time;
+	__u32 coarse_time_short;
+	__u16 gain;
+	__u8 hdr_en;
+};
+
+struct imx214_ae {
+	__u32 frame_length;
+	__u8  frame_length_enable;
+	__u32 coarse_time;
+	__u32 coarse_time_short;
+	__u8  coarse_time_enable;
+	__s32 gain;
+	__u8  gain_enable;
+};
+
+struct imx214_fuseid {
+	__u32 size;
+	__u8  id[16];
+};
+
+struct imx214_hdr {
+	__u32 coarse_time_long;
+	__u32 coarse_time_short;
+};
+
+struct imx214_otp_bank {
+	__u32 id;
+	__u8  buf[16];
+};
+
+struct imx214_cal_data {
+	int loaded;
+	int rg_ratio;
+	int bg_ratio;
+	int rg_ratio_typical;
+	int bg_ratio_typical;
+	__u8 lenc[62];
+};
+
+#endif  /* __UAPI_IMX214_H__ */
diff --git a/nvidia/include/uapi/media/ov5640.h b/nvidia/include/uapi/media/ov5640.h
new file mode 100644
index 000000000000..cef6ce726fb9
--- /dev/null
+++ b/nvidia/include/uapi/media/ov5640.h
@@ -0,0 +1,113 @@
+/*
+ * Copyright (c) 2013-2019, NVIDIA CORPORATION.  All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#ifndef __UAPI_OV5640_H__
+#define __UAPI_OV5640_H__
+
+#include <uapi/media/nvc.h>
+#include <uapi/media/nvc_image.h>
+
+#define OV5640_IOCTL_SET_MODE               _IOW('o', 1, struct ov5640_mode)
+#define OV5640_IOCTL_SET_FRAME_LENGTH       _IOW('o', 2, __u32)
+#define OV5640_IOCTL_SET_COARSE_TIME        _IOW('o', 3, __u32)
+#define OV5640_IOCTL_SET_GAIN               _IOW('o', 4, __u16)
+#define OV5640_IOCTL_GET_STATUS             _IOR('o', 5, __u8)
+#define OV5640_IOCTL_SET_BINNING            _IOW('o', 6, __u8)
+#define OV5640_IOCTL_TEST_PATTERN           _IOW('o', 7, \
+						 enum ov5640_test_pattern)
+#define OV5640_IOCTL_SET_GROUP_HOLD         _IOW('o', 8, struct ov5640_ae)
+/* IOCTL to set the operating mode of camera.
+ * This can be either stereo , leftOnly or rightOnly */
+#define OV5640_IOCTL_SET_CAMERA_MODE        _IOW('o', 10, __u32)
+#define OV5640_IOCTL_SYNC_SENSORS           _IOW('o', 11, __u32)
+#define OV5640_IOCTL_GET_FUSEID             _IOR('o', 12, struct nvc_fuseid)
+#define OV5640_IOCTL_SET_HDR_COARSE_TIME    _IOW('o', 13, struct ov5640_hdr)
+#define OV5640_IOCTL_READ_OTP_BANK          _IOWR('o', 14, \
+						struct ov5640_otp_bank)
+#define OV5640_IOCTL_SET_CAL_DATA           _IOW('o', 15, \
+						struct ov5640_cal_data)
+#define OV5640_IOCTL_GET_EEPROM_DATA        _IOR('o', 20, __u8 *)
+#define OV5640_IOCTL_SET_EEPROM_DATA        _IOW('o', 21, __u8 *)
+#define OV5640_IOCTL_GET_CAPS               _IOR('o', 22, struct nvc_imager_cap)
+#define OV5640_IOCTL_SET_POWER              _IOW('o', 23, __u32)
+
+#define OV5640_FUSE_ID_OTP_START_ADDR	0x3D00
+#define OV5640_FUSE_ID_OTP_BANK	0
+#define OV5640_FUSE_ID_SIZE		8
+#define OV5640_FUSE_ID_STR_SIZE	(OV5640_FUSE_ID_SIZE * 2)
+
+#define OV5640_FRAME_LENGTH_ADDR_MSB		0x380E
+#define OV5640_FRAME_LENGTH_ADDR_LSB		0x380F
+#define OV5640_COARSE_TIME_ADDR_1		0x3500
+#define OV5640_COARSE_TIME_ADDR_2		0x3501
+#define OV5640_COARSE_TIME_ADDR_3		0x3502
+#define OV5640_COARSE_TIME_SHORT_ADDR_1	0x3506
+#define OV5640_COARSE_TIME_SHORT_ADDR_2	0x3507
+#define OV5640_COARSE_TIME_SHORT_ADDR_3	0x3508
+#define OV5640_GAIN_ADDR_MSB			0x350A
+#define OV5640_GAIN_ADDR_LSB			0x350B
+#define OV5640_GROUP_HOLD_ADDR			0x3208
+#define OV5640_TIMING_REG20			0x3820
+#define VERTICAL_FLIP				((0x1 << 1) | (0x1 << 6))
+#define OV5640_TIMING_REG21			0x3821
+#define HORIZONTAL_MIRROR_MASK			(0x3 << 1)
+
+struct ov5640_mode {
+	int res_x;
+	int res_y;
+	int fps;
+	__u32 frame_length;
+	__u32 coarse_time;
+	__u32 coarse_time_short;
+	__u16 gain;
+	__u8 hdr_en;
+};
+
+struct ov5640_ae {
+	__u32 frame_length;
+	__u8  frame_length_enable;
+	__u32 coarse_time;
+	__u32 coarse_time_short;
+	__u8  coarse_time_enable;
+	__s32 gain;
+	__u8  gain_enable;
+};
+
+struct ov5640_fuseid {
+	__u32 size;
+	__u8  id[16];
+};
+
+struct ov5640_hdr {
+	__u32 coarse_time_long;
+	__u32 coarse_time_short;
+};
+
+struct ov5640_otp_bank {
+	__u32 id;
+	__u8  buf[16];
+};
+
+struct ov5640_cal_data {
+	int loaded;
+	int rg_ratio;
+	int bg_ratio;
+	int rg_ratio_typical;
+	int bg_ratio_typical;
+	__u8 lenc[62];
+};
+
+#endif  /* __UAPI_OV5640_H__ */
diff --git a/nvidia/include/uapi/media/ov5670.h b/nvidia/include/uapi/media/ov5670.h
new file mode 100644
index 000000000000..698504530275
--- /dev/null
+++ b/nvidia/include/uapi/media/ov5670.h
@@ -0,0 +1,113 @@
+/*
+ * Copyright (c) 2013-2019, NVIDIA CORPORATION.  All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#ifndef __UAPI_OV5670__OV5640_H__
+#define __UAPI_OV5670__OV5640_H__
+
+#include <uapi/media/nvc.h>
+#include <uapi/media/nvc_image.h>
+
+#define OV5670_IOCTL_SET_MODE               _IOW('o', 1, struct ov5670_mode)
+#define OV5670_IOCTL_SET_FRAME_LENGTH       _IOW('o', 2, __u32)
+#define OV5670_IOCTL_SET_COARSE_TIME        _IOW('o', 3, __u32)
+#define OV5670_IOCTL_SET_GAIN               _IOW('o', 4, __u16)
+#define OV5670_IOCTL_GET_STATUS             _IOR('o', 5, __u8)
+#define OV5670_IOCTL_SET_BINNING            _IOW('o', 6, __u8)
+#define OV5670_IOCTL_TEST_PATTERN           _IOW('o', 7, \
+						 enum ov5670_test_pattern)
+#define OV5670_IOCTL_SET_GROUP_HOLD         _IOW('o', 8, struct ov5670_ae)
+/* IOCTL to set the operating mode of camera.
+ * This can be either stereo , leftOnly or rightOnly */
+#define OV5670_IOCTL_SET_CAMERA_MODE        _IOW('o', 10, __u32)
+#define OV5670_IOCTL_SYNC_SENSORS           _IOW('o', 11, __u32)
+#define OV5670_IOCTL_GET_FUSEID             _IOR('o', 12, struct nvc_fuseid)
+#define OV5670_IOCTL_SET_HDR_COARSE_TIME    _IOW('o', 13, struct ov5670_hdr)
+#define OV5670_IOCTL_READ_OTP_BANK          _IOWR('o', 14, \
+						struct ov5670_otp_bank)
+#define OV5670_IOCTL_SET_CAL_DATA           _IOW('o', 15, \
+						struct ov5670_cal_data)
+#define OV5670_IOCTL_GET_EEPROM_DATA        _IOR('o', 20, __u8 *)
+#define OV5670_IOCTL_SET_EEPROM_DATA        _IOW('o', 21, __u8 *)
+#define OV5670_IOCTL_GET_CAPS               _IOR('o', 22, struct nvc_imager_cap)
+#define OV5670_IOCTL_SET_POWER              _IOW('o', 23, __u32)
+
+#define OV5670_FUSE_ID_OTP_START_ADDR	0x7100
+#define OV5670_FUSE_ID_OTP_BANK	0
+#define OV5670_FUSE_ID_SIZE		8
+#define OV5670_FUSE_ID_STR_SIZE	(OV5670_FUSE_ID_SIZE * 2)
+
+#define OV5670_FRAME_LENGTH_ADDR_MSB		0x380E
+#define OV5670_FRAME_LENGTH_ADDR_LSB		0x380F
+#define OV5670_COARSE_TIME_ADDR_1		0x3500
+#define OV5670_COARSE_TIME_ADDR_2		0x3501
+#define OV5670_COARSE_TIME_ADDR_3		0x3502
+#define OV5670_COARSE_TIME_SHORT_ADDR_1		0x3510
+#define OV5670_COARSE_TIME_SHORT_ADDR_2		0x3511
+#define OV5670_COARSE_TIME_SHORT_ADDR_3		0x3512
+#define OV5670_GAIN_ADDR_MSB			0x3508
+#define OV5670_GAIN_ADDR_LSB			0x3509
+#define OV5670_GROUP_HOLD_ADDR			0x3208
+#define OV5670_TIMING_REG20			0x3820
+#define VERTICAL_FLIP				((0x1 << 1) | (0x1 << 2) | (0x1 << 6))
+#define OV5670_TIMING_REG21			0x3821
+#define HORIZONTAL_MIRROR_MASK			(0x3 << 1)
+
+struct ov5670_mode {
+	int res_x;
+	int res_y;
+	int fps;
+	__u32 frame_length;
+	__u32 coarse_time;
+	__u32 coarse_time_short;
+	__u16 gain;
+	__u8 hdr_en;
+};
+
+struct ov5670_ae {
+	__u32 frame_length;
+	__u8  frame_length_enable;
+	__u32 coarse_time;
+	__u32 coarse_time_short;
+	__u8  coarse_time_enable;
+	__s32 gain;
+	__u8  gain_enable;
+};
+
+struct ov5670_fuseid {
+	__u32 size;
+	__u8  id[16];
+};
+
+struct ov5670_hdr {
+	__u32 coarse_time_long;
+	__u32 coarse_time_short;
+};
+
+struct ov5670_otp_bank {
+	__u32 id;
+	__u8  buf[16];
+};
+
+struct ov5670_cal_data {
+	int loaded;
+	int rg_ratio;
+	int bg_ratio;
+	int rg_ratio_typical;
+	int bg_ratio_typical;
+	__u8 lenc[62];
+};
+
+#endif
-- 
2.17.1

